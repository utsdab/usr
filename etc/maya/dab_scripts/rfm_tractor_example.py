# -----------------------------------------------------------------------------
#
# Copyright (c) 1986-2018 Pixar. All rights reserved.
#
# The information in this file (the "Software") is provided for the exclusive
# use of the software licensees of Pixar ("Licensees").  Licensees have the
# right to incorporate the Software into other products for use by other
# authorized software licensees of Pixar, without fee. Except as expressly
# permitted herein, the Software may not be disclosed to third parties, copied
# or duplicated in any form, in whole or in part, without the prior written
# permission of Pixar.
#
# The copyright notices in the Software and this entire statement, including the
# above license grant, this restriction and the following disclaimer, must be
# included in all copies of the Software, in whole or in part, and all permitted
# derivative works of the Software, unless such copies or derivative works are
# solely in the form of machine-executable object code generated by a source
# language processor.
#
# PIXAR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL PIXAR BE
# LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
# OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
# CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  IN NO CASE WILL
# PIXAR'S TOTAL LIABILITY FOR ALL DAMAGES ARISING OUT OF OR IN CONNECTION WITH
# THE USE OR PERFORMANCE OF THIS SOFTWARE EXCEED $50.
#
# Pixar
# 1200 Park Ave
# Emeryville CA 94608
#
# -----------------------------------------------------------------------------

# pylint: disable=import-error
import subprocess
import maya.mel as mel
import maya.cmds as mc
from rfm2.config import cfg, RfmError
from rfm2.config import DEFAULT_DISPLAY_NAME, DEFAULT_DISPLAY_NODE
import rfm2.api.strings as apistr
import rfm2.api.displays as apidspy
import rfm2.api.nodes as apinodes
import rfm2.spool.utils as sputils
import rfm2.render
from rfm2 import rfm_log
import rfm2.ui.prefs
from rfm2.utils.filepath import FilePath
import rfm2.txmanager_maya as txmgr_maya
import txmanager.core as txmgr
from maya import utils as mutils

import os
import os.path
import tractor.api.author as author
import getpass
import socket
import time
import datetime

def add_prman_render_task(parentTask, title, threads, rib, img, args=[]):
    """Create a single prman task for a Tractor job.

    Args:
    - parentTask (Task) - parent task that this prman task belongs to.
    - title (str) - title to use for this task.
    - threads (int) - number of threads to use for this prman task.
    - rib (str) - full path to the RIB file to render.
    - img (str) - full path to the image file that will be generated by the
                  prman task. This is used to create the preview/chaser task.
    - args (list) - other args to pass to prman
    """

    task = author.Task()
    task.title = title
    if img:
        task.preview = 'sho %s' % str(img)

    command = author.Command(local=False, service="PixarRender")
    command.argv = ["prman"]
    for arg in args:
        command.argv.append(arg)

    for arg in ["-Progress", "-t:%d" % threads, "%%D(%s)" % rib]:
        command.argv.append(arg)

    task.addCommand(command)
    parentTask.addChild(task)


def add_maya_batch_render_task(parentTask, title, stash_scene_name, img, is_anim, start, end,
                           by, args=[]):
    """Create a single Maya Render task for a Tractor job.

    Args:
    - parentTask (Task) - parent task that this Maya Render task belongs to.
    - title (str) - title to use for this task.
    - stash_scene_name (str) - full path to the scene file name.
    - img (str) - full path to the image file to create the preview/chaser task.
                  Only used if start==end i.e.: a single frame render.
    - is_anim (bool) - emit start, end, by args to the batch render command
    - start (int) - the start frame for an animation sequence.
    - end (int) - the end frame for an animation sequence.
    - by (int) - by frame (or step) for an animation sequence.
    - args (list) - other args to pass to maya batch
    """

    task = author.Task()
    task.title = title
    if start == end:
        if img:
            task.preview = 'sho %s' % str(img)

    command = author.Command(local=False, service="PixarRender")
    proj = mc.workspace(q=True, rd=True)

    rendercmd = "Render"
    command.argv = [ rendercmd, "-r", "renderman", "-proj", "%%D(%s)" % proj]
    for arg in args:
        command.argv.append(arg)

    if is_anim:
        command.argv.append("-s")
        command.argv.append(start)
        command.argv.append("-e")
        command.argv.append(end)
        command.argv.append("-b")
        command.argv.append(by)

    command.argv.append("%%D(%s)" % stash_scene_name)

    task.addCommand(command)
    parentTask.addChild(task)

def add_txmake_task(parentTask, title, args):
    """Create a single txmake task for Tractor job.

    Args:
    - parentTask (Task) - parent task that this txmake task belongs to.
    - title (str) - title to use for this task.
    - args (list) - txmake args including input and output name

    """
    task = author.Task()
    task.title = title

    command = author.Command(local=False, service="PixarRender")
    argv = ['txmake'] + args
    command.argv = argv

    task.addCommand(command)
    parentTask.addChild(task)


def add_denoise_task(parentTask, title, args, imgs, preview_imgs=[], variance_files=[]):
    """Create a single denoise task for Tractor job.

    Args:
    - parentTask (Task) - parent task that this denoise task belongs to.
    - title (str) - title to use for this task.
    - args (list) - arguments to denoiser
    - imgs (list) - list of images to be denoised
    - preview_imgs (list) - list of images to generate preview tasks
    - variance_files (list) - list of variance files

    """
    task = author.Task()
    task.title = title

    command = author.Command(local=False, service="PixarRender")
    command.argv = ["denoise"]
    for arg in args:
        command.argv.append(arg)
    for f in variance_files:
        command.argv.append("%%D(%s)" % f)

    for f in imgs:
        command.argv.append("%%D(%s)" % f)

    if preview_imgs:
        imgs = " ".join(str(x) for x in preview_imgs)
        task.preview = 'sho %s' % str(imgs)

    task.addCommand(command)
    parentTask.addChild(task)

def get_denoise_filtered_name(s):
    """Try to ascertain what the filtered version of
    the image filename will be after it has been denoised.

    Args:
    - s (str) - path to tokenized filename
    """

    import re

    dirname = os.path.dirname(s)
    basename = os.path.basename(s)

    # place _filtered right before frame number
    filtered = re.sub(r'.<f', '_filtered.<f', basename)
    if filtered == s:
        # hmph, re.sub didn't work try
        # placing _filtered right before the extension
        toks = os.path.splitext(basename)
        filename = toks[0]
        ext = ''
        if toks > 1:
            ext[1]
        filtered = '%s_filtered%s' % (filename, ext)

    return "%s/%s" % (dirname, filtered)


def generate_denoise_tasks(frametasktitle, frametask, displays, frame, start=1, end=1, by=1):
    """Create denoise tasks for a single frame for a Tractor job

    Args:
    - frametasktitle
    - frametask (Task) - parent task that these denoise tasks belongs to.
    - displays (dict) - displays dict
    - frame (int) - the current frame
    - start (int) - the starting frame of the sequence
    - end (int) - the end frame of the sequence
    - by (int) - how many frames to skip

    """

    DENOISE_SINGLE_FRAME = 0
    DENOISE_CROSSFRAME = 1

    # look for the variance file
    variance_file = None
    variance_display = None
    denoiseAOVs = False
    denoise_displays = {}
    for d in displays:
        if d.endswith('variance'):
            filepath = displays[d]['filePath']
            variance_display = d
            variance_file = filepath
            denoise_displays[d] = displays[d]
        else:
            dspy_node = d
            if dspy_node == DEFAULT_DISPLAY_NAME:
                # skip beauty
                continue
            if mc.objExists(dspy_node) is False:
                # this might be an 'it' splitted display
                continue
            mode = mc.getAttr('%s.denoise' % dspy_node)
            if mode == 1:
                denoiseAOVs = True
                denoise_displays[d] = displays[d]

    if denoiseAOVs and not variance_display:
        rfm_log().warning('At least one AOV has requested denoise, but could not find a variance display. No denoise tasks added.')
        return

    if variance_display:
        for d in denoise_displays:
            is_variance = False
            filepath = denoise_displays[d]['filePath']
            imgfile = FilePath(apistr.expand_string(filepath, display=d, frame=frame)).os_path()
            dspy_node = d
            if variance_display == d:
                is_variance = True
                dspy_node = dspy_node.split('_variance')[0]
                if dspy_node == DEFAULT_DISPLAY_NAME:
                    dspy_node = DEFAULT_DISPLAY_NODE
            base_args = []
            mode = mc.getAttr('%s.denoise' % dspy_node)
            frameMode = mc.getAttr('%s.frameMode' % dspy_node)

            if mode == 1:
                denoise_task_title = ("%s Image: %s (denoise)" %
                                   (frametasktitle,
                                    str(os.path.basename(imgfile))))
                if frameMode == DENOISE_SINGLE_FRAME:
                    if is_variance:
                        args = base_args
                        preview_img = imgfile.replace('_variance', '_filtered')
                        add_denoise_task(frametask, denoise_task_title, args, [imgfile], [preview_img])

                    else:
                        args = base_args
                        variance_file_expand =  FilePath(apistr.expand_string(variance_file, display=variance_display, frame=frame)).os_path()
                        filtered_path = get_denoise_filtered_name(filepath)
                        filtered_path_expand =  FilePath(apistr.expand_string(filtered_path, display=d, frame=frame)).os_path()
                        add_denoise_task(frametask, denoise_task_title, args, [imgfile], [filtered_path_expand], [variance_file_expand])

                elif frameMode == DENOISE_CROSSFRAME:
                    if (start == end) or (by > 1):
                        # Treat as if single frame denoise
                        if is_variance:
                            args = base_args
                            preview_img = imgfile.replace('_variance', '_filtered')
                            add_denoise_task(frametask, denoise_task_title, args, [imgfile], [preview_img])

                        else:
                            args = base_args
                            variance_file_expand =  FilePath(apistr.expand_string(variance_file, display=variance_display, frame=frame)).os_path()
                            filtered_path = get_denoise_filtered_name(filepath)
                            filtered_path_expand =  FilePath(apistr.expand_string(filtered_path, display=d, frame=frame)).os_path()
                            add_denoise_task(frametask, denoise_task_title, args, [imgfile], [filtered_path_expand],[variance_file_expand])

                    else:
                        base_args.append("--crossframe")
                        base_args.append("-v")
                        base_args.append("variance")

                        f1 = FilePath(apistr.expand_string(variance_file, display=variance_display, frame=frame-2)).os_path()
                        f2 = FilePath(apistr.expand_string(variance_file, display=variance_display, frame=frame-1)).os_path()
                        f3 = FilePath(apistr.expand_string(variance_file, display=variance_display, frame=frame)).os_path()
                        variance_files = [f1, f2, f3]

                        f1 = FilePath(apistr.expand_string(filepath, display=d, frame=frame-2)).os_path()
                        f2 = FilePath(apistr.expand_string(filepath, display=d, frame=frame-1)).os_path()
                        f3 = FilePath(apistr.expand_string(filepath, display=d, frame=frame)).os_path()
                        imgs = [f1, f2, f3]

                        filtered_path = get_denoise_filtered_name(filepath)
                        p0 = FilePath(apistr.expand_string(filepath, display=d, frame=frame-2)).os_path()
                        p1 = FilePath(apistr.expand_string(filepath, display=d, frame=frame-1)).os_path()
                        p2 = FilePath(apistr.expand_string(filepath, display=d, frame=frame)).os_path()

                        if (frame-1) < start or (frame-2) < start:
                            # first frame or second frame, check if it's a two-frame
                            # sequence
                            if (frame+1) > end:
                                args = [i for i in base_args]
                                if is_variance:
                                    p0 = variance_files[0]
                                    p1 = variance_files[1]
                                    p0 = p0.replace('_variance', '_filtered')
                                    p1 = p1.replace('_variance', '_filtered')
                                    add_denoise_task(frametask, denoise_task_title, args, [variance_files[0], variance_files[1]], [p0,p1])
                                else:
                                    add_denoise_task(frametask, denoise_task_title, args, [imgs[0], imgs[1]], [p0,p1], [variance_files[0], variance_files[1]])
                            continue

                        if (frame-2) == start:
                            # we need at least three frames to do crossframe
                            # check if we're on the first three
                            # doing only --skiplast will take care of the first two frames.
                            args = [i for i in base_args]

                            if frame != end:
                                # only add --skiplast if we're in a sequence that is
                                # longer than three frames. If we're on a three-frame sequence
                                # just denoise all three frames in one denoise task, otherwise
                                # the second frame will get denoise twice.
                                args.append("--skiplast")

                            if is_variance:
                                p0 = variance_files[0]
                                p1 = variance_files[1]
                                p0 = p0.replace('_variance', '_filtered')
                                p1 = p1.replace('_variance', '_filtered')
                                add_denoise_task(frametask, denoise_task_title, args, variance_files, [p0,p1])
                            else:
                                add_denoise_task(frametask, denoise_task_title, args, imgs, [p0,p1], variance_files)

                            if frame == end:
                                # this is just a three-frame sequence. See comment above.
                                return

                        if (frame-2) > start and frame < end:
                            # if we're past the first three, but the current frame
                            # is less than the end frame
                            args = [i for i in base_args]
                            args.append("--skipfirst")
                            args.append("--skiplast")

                            if is_variance:
                                p1 = variance_files[1]
                                p1 = p1.replace('_variance', '_filtered')
                                add_denoise_task(frametask, denoise_task_title, args, variance_files, [p1])
                            else:
                                add_denoise_task(frametask, denoise_task_title, args, imgs, [p1], variance_files)

                        if frame == end:
                            # if we're on the last frame, doing just --skipfirst
                            # will take care of the last and second last frames.
                            args = [i for i in base_args]
                            args.append("--skipfirst")

                            if is_variance:
                                p1 = variance_files[1]
                                p2 = variance_files[2]
                                p1 = p1.replace('_variance', '_filtered')
                                p2 = p2.replace('_variance', '_filtered')
                                add_denoise_task(frametask, denoise_task_title, args, variance_files, [p1,p2])
                            else:
                                add_denoise_task(frametask, denoise_task_title, args, imgs, [p1,p2], variance_files)


def wait_for_txmanager(mgr):
    """Wait for txmanager to finish its running tasks"""

    rfm_log().debug('Waiting for txmanager to finish before spooling...')

    if len(mgr.threads) > 0:
        main_progress_bar = mel.eval('$tmp = $gMainProgressBar')
        mutils.executeInMainThreadWithResult(
            mc.progressBar, main_progress_bar, edit=True,
            beginProgress=True, isInterruptable=True,
            status='Txmanager is still busy...', maxValue=len(mgr.threads))
        for i in range(0, len(mgr.threads)):
            p = mgr.threads[i]
            mutils.executeInMainThreadWithResult(
                mc.progressBar, main_progress_bar, edit=True, step=i + 1)
            if p.is_alive():
                p.join()

        mutils.executeInMainThreadWithResult(
            mc.progressBar, main_progress_bar, edit=True, endProgress=True)
    rfm_log().debug('Txmanager has finished. Resume batch render spool...')

def generate_txmake_tasks():
    """Generate txmake tasks to be added to a job file

    Returns
        - txmakeParentTask (Task): the parent task of all the txmake tasks
    """

    txmakeParentTask = author.Task()
    txmakeParentTask.title = 'Pre-Render TxMake Tasks'
    txmakeParentTask.serialsubtasks = False
    mgr = txmgr_maya.manager()

    queued_txmake_list = [] # list to hold txmake tasks still in the queue

    # peel the rest of txmake tasks off the txmanager work queue
    # and hand it off to LocalQueue/Tractor
    # add the outfile to queued_txmake_list
    while not mgr.workQueue.empty():
        ui, txfile, txitem, args = mgr.workQueue.get()
        infile = args[-2]
        outfile = args[-1]

        argv = args[1:-2]
        argv.append('%D(' + infile + ')')
        argv.append('%D(' + outfile + ')')
        txmaketasktitle = 'TxMake: %s' % (str(infile))
        add_txmake_task(txmakeParentTask, txmaketasktitle, argv)
        queued_txmake_list.append(outfile)
        mgr.workQueue.task_done()

    #wait_for_txmgr = rfm2.ui.prefs.get_pref_by_name('rfmTxManagerBlockOnBatch')
    wait_for_txmgr = False
    # FIXME: wait_for_txmanager seem to cause Maya to lock up.
    if wait_for_txmgr:
        # wait for txmanager to finish its txmake tasks that are still running
        # before spooling the job.
        wait_for_txmanager(mgr)

    else:
        # instead of waiting for the txmanager to finish
        # look for textures that are still being processed
        # and add them to our job file, with the addition of the "-newer"
        # flag in the args.
        # the textures being processed should be the ones that are not in
        # queued_txmake_list.
        # in theory, this should be faster than waiting for the txmanager
        # however, there is a race condition and we may txmake a texture
        # more than once.
        for txfile in mgr.txfile_list:
            if txfile._check_source_is_tex():
                continue

            # validate all output files
            txfile.check_dirty()
            if txfile.is_dirty():
                for img, item in txfile.tex_dict.iteritems():
                    if item.outfile in queued_txmake_list:
                        continue
                    if item.state is txmgr.STATE_EXISTS:
                        continue

                    all_flags = mgr.txmakeopts.get_opts_as_list() + \
                            txfile.get_params().get_params_as_list()

                    # create txmake command
                    argv = all_flags
                    argv.append('-newer') # add newer flag
                    argv.append('%D(' + img + ')')
                    argv.append('%D(' + item.outfile + ')')
                    txmaketasktitle = 'TxMake: %s' % (str(img))
                    add_txmake_task(txmakeParentTask, txmaketasktitle, argv)

    return txmakeParentTask

def add_job_level_attrs(is_localqueue, job):

    rmanversion = cfg().rfm_env['versions']['rfm']

    paused = rfm2.ui.prefs.get_pref_by_name('rfmTractorPaused')
    priority = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorPriority'))
    service = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorService'))
    envkey = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorEnvKey'))
    crews = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorCrews'))
    tier = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorTier'))
    projects = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorProjects'))
    comment = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorComment'))
    metadata = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorMetaData'))
    whendone = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorWhenDone'))
    whenerror = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorWhenError'))
    whenalways = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorWhenAlways'))
    after = str(rfm2.ui.prefs.get_pref_by_name('rfmTractorAfter'))

    if cfg().dirmaps:
        for k in cfg().dirmaps:
            dirmap = cfg().dirmaps[k]
            job.newDirMap(src=str(dirmap['from']),
                          dst=str(dirmap['to']),
                          zone=str(dirmap['zone']))

    if paused == 1:
        job.paused = True
    if priority != '':
        job.priority = float(priority)
    if service != '':
        job.service = service
    if crews != '':
        job.crews = crews.split()
    if projects != '':
        job.projects = projects.split()
    if comment != '':
        job.comment = comment
    if metadata != '':
        job.metadata = metadata
    if whendone != '':
        job.newPostscript(argv=whendone, when="done", service=service)
    if whenerror != '':
        job.newPostscript(argv=whenerror, when="error", service=service)
    if whenalways != '':
        job.newPostscript(argv=whenalways, when="always", service=service)
    if after != '':
        try:
            aftersplit = after.split(' ')
            if len(aftersplit) == 2:
                t_date = aftersplit[0].split('/')
                t_time = aftersplit[1].split(':')
                if len(t_date) == 2 and len(t_time) == 2:
                    today = datetime.datetime.today()
                    job.after = datetime.datetime(today.year, int(t_date[0]),
                                                  int(t_date[1]),
                                                  int(t_time[0]),
                                                  int(t_time[1]), 0)
                else:
                    rfm_log().warning('Could not parse after date: %s. '
                                      'Ignoring.', after)
            else:
                rfm_log().warning('Could not parse after date: %s. Ignoring.',
                                  after)
        except:
            rfm_log().warning('Could not parse after date: %s. Ignoring.',
                              after)

    rfmenvkey = 'rfm-%s' % (str(rmanversion).strip())
    mayaenvkey = 'maya-%s' % (str(rfm2.render.MAYA_VERSION_STR).strip())
    job.envkey = []
    if not is_localqueue:
        # only add envkeys for Tractor jobs
        if len(envkey) > 0:
            userenvkeys = envkey.split(' ')
            for i, k in enumerate(userenvkeys):
                userenvkeys[i] = os.path.expandvars(k)
            job.envkey.extend(userenvkeys)
        else:
            job.envkey = [rfmenvkey, mayaenvkey]

def generate_rib_render_tasks(is_localqueue, anim, parent_task, tasktitle, displays, beauty_dspy_variance, start, last, by, chunk, threads, do_bake, checkpoint):

    rmanGlobals = apinodes.rman_globals()
    ribOutputDir = mc.getAttr('%s.ribOutputDir' % rmanGlobals)
    imgOutputDir = mc.getAttr('%s.imageOutputDir' % rmanGlobals)
    imgFileFormat = mc.getAttr('%s.imageFileFormat' % rmanGlobals)
    ribFileFormat = mc.getAttr('%s.ribFileFormat' % rmanGlobals)

    ribFilename = ribFileFormat
    ribFullPath = FilePath(ribOutputDir).join(ribFilename)
    mc.sysFile(apistr.expand_string(ribOutputDir), makeDir=True)
    mc.sysFile(apistr.expand_string(imgOutputDir), makeDir=True)
    # For spooled rib renders we are responsible for iterating render layers
    # For mayabatch, maya takes care of iterating the render layers.
    renderLayers = mc.listConnections('renderLayerManager.renderLayerId')
    renderLayers = sorted(renderLayers)
    curLayer = mel.eval("editRenderLayerGlobals -q -currentRenderLayer")
    cameras = mc.ls(type='camera')
    doExpandEnvVars = is_localqueue
    foundRenderableCam = False
    bakeFlag = ""
    if do_bake:
        bakeFlag = "-bake"

    # call maya's preMel script
    preMel = mc.getAttr('defaultRenderGlobals.preMel')
    if preMel and len(preMel) > 0:
        mel.eval(preMel)

    for layer in renderLayers:
        renderable = mc.getAttr("%s.renderable" % layer)
        if not renderable:
            continue
        # switch to layer, to cause layer overrides to kick in before
        # ribgen
        mel.eval("editRenderLayerGlobals -currentRenderLayer %s" % layer)

        # call maya's pre render layer script
        preRenderLayerMel = mc.getAttr('defaultRenderGlobals.preRenderLayerMel')
        if preRenderLayerMel and len(preRenderLayerMel) > 0:
            mel.eval(preRenderLayerMel)

        for cam in cameras:
            rendercam = mc.getAttr("%s.renderable" % cam)
            if not rendercam:
                continue
            foundRenderableCam = True
            if anim is False:
                mel.eval('rmanRender "-ribFile \\\"%s\\\" -layer %s -camera %s -expandEnvVars %d %s"' %
                         (ribFullPath, layer, cam, doExpandEnvVars, bakeFlag))
                rib_expanded = FilePath(apistr.expand_string(ribFullPath)).os_path()
                if beauty_dspy_variance:
                    img_expanded = FilePath(apistr.expand_string(
                        FilePath(imgOutputDir).join(imgFileFormat), display=beauty_dspy_variance)).os_path()
                else:
                    img_expanded = FilePath(apistr.expand_string(
                        FilePath(imgOutputDir).join(imgFileFormat))).os_path()

                frametasktitle = ("%s Frame: %d Layer: %s Camera: %s" %
                                  (tasktitle, int(start), str(layer), str(cam)))
                frametask = author.Task()
                frametask.title = frametasktitle
                frametask.serialsubtasks = True

                prmantasktitle = "%s (render)" % frametasktitle
                args = []

                if checkpoint != '':
                    args.append('-checkpoint')
                    args.append(checkpoint)
                    args.append('-recover')
                    args.append('%r')

                if os.path.splitext(img_expanded)[1] == '.it':
                    if is_localqueue:
                        args.append('-dspyserver')
                        if mc.about(mac=True):
                            args.append('$RMANTREE/bin/it.app/Contents/MacOS/it')
                        else:
                            args.append('it')
                    else:
                        rfm2.render.show_it()
                    add_prman_render_task(frametask, prmantasktitle, threads,
                                          rib_expanded, '', args)
                else:
                    add_prman_render_task(frametask, prmantasktitle, threads,
                                          rib_expanded, img_expanded, args)
                    if not do_bake:
                        generate_denoise_tasks(frametasktitle, frametask, displays, start)

                parent_task.addChild(frametask)

            else:
                curFrame = mc.currentTime(query=True)
                parent_task.serialsubtasks = True
                mel.eval('rmanRender "-ribFile \\\"%s\\\" -layer %s -camera %s -expandEnvVars %d %s"' %
                         (ribFullPath, layer, cam, doExpandEnvVars, bakeFlag))

                renderframestask = author.Task()
                renderframestask.serialsubtasks = False
                renderframestasktitle = ("Render Layer: %s Camera: %s" %
                                (str(layer), str(cam)))
                renderframestask.title = renderframestasktitle

                for iframe in range(int(start), int(last + 1), int(by)):
                    mc.currentTime(iframe)
                    rib_expanded = FilePath(apistr.expand_string(ribFullPath)).os_path()
                    if beauty_dspy_variance:
                        img_expanded = FilePath(apistr.expand_string(
                            FilePath(imgOutputDir).join(imgFileFormat), display=beauty_dspy_variance)).os_path()
                    else:
                        img_expanded = FilePath(apistr.expand_string(
                            FilePath(imgOutputDir).join(imgFileFormat))).os_path()

                    prmantasktitle = ("%s Frame: %d Layer: %s Camera: %s (prman)" %
                                      (tasktitle, int(start), str(layer), str(cam)))
                    args = []

                    if checkpoint != '':
                        args.append('-checkpoint')
                        args.append(checkpoint)
                        args.append('-recover')
                        args.append('%r')

                    if os.path.splitext(img_expanded)[1] == '.it':
                        if is_localqueue:
                            args.append('-dspyserver')
                            if mc.about(mac=True):
                                args.append('$RMANTREE/bin/it.app/Contents/MacOS/it')
                            else:
                                args.append('it')
                        else:
                            rfm2.render.show_it()
                        add_prman_render_task(renderframestask, prmantasktitle, threads,
                                              rib_expanded, '', args)
                    else:
                        add_prman_render_task(renderframestask, prmantasktitle, threads,
                                              rib_expanded, img_expanded, args)

                parent_task.addChild(renderframestask)

                if not do_bake:
                    denoiseframestask = author.Task()
                    denoiseframestask.serialsubtasks = False
                    denoiseframestasktitle = ("Denoise Layer: %s Camera: %s" %
                                    (str(layer), str(cam)))
                    denoiseframestask.title = denoiseframestasktitle

                    for iframe in range(int(start), int(last + 1), int(by)):
                        mc.currentTime(iframe)
                        if beauty_dspy_variance:
                            img_expanded = FilePath(apistr.expand_string(
                                FilePath(imgOutputDir).join(imgFileFormat), display=beauty_dspy_variance)).os_path()
                        else:
                            img_expanded = FilePath(apistr.expand_string(
                                FilePath(imgOutputDir).join(imgFileFormat))).os_path()

                        denoisetasktitle = ("Denoise Frame: %d Layer: %s Camera: %s" %
                                    (int(start), str(layer), str(cam)))

                        generate_denoise_tasks(denoisetasktitle, denoiseframestask, displays, iframe, start=int(start),
                                                   end=int(last), by=int(by))

                    parent_task.addChild(denoiseframestask)

                mc.currentTime(curFrame)
        # call maya's post render layer script
        postRenderLayerMel = mc.getAttr('defaultRenderGlobals.postRenderLayerMel')
        if postRenderLayerMel and len(postRenderLayerMel) > 0:
            mel.eval(postRenderLayerMel)

    # call maya's postMel script
    postMel = mc.getAttr('defaultRenderGlobals.postMel')
    if postMel and len(postMel) > 0:
        mel.eval(postMel)

    # restore original render layer
    mel.eval("editRenderLayerGlobals -currentRenderLayer %s" % layer)
    if not foundRenderableCam:
        raise RfmError('No renderable cameras were found!')

def generate_maya_batch_render_tasks(stash_scene_name, anim, parent_task, tasktitle, displays, beauty_dspy_variance, start, last, by, chunk, threads, do_bake, checkpoint):

    rmanGlobals = apinodes.rman_globals()
    imgOutputDir = mc.getAttr('%s.imageOutputDir' % rmanGlobals)
    imgFileFormat = mc.getAttr('%s.imageFileFormat' % rmanGlobals)

    args = ['-t', '%d' % threads]
    if do_bake:
        args.append('-bake')
    if checkpoint != '':
        args.append('-checkpoint')
        args.append(checkpoint)

    if mc.about(api=True) >= 20180300 and mc.optionVar(q="renderSetupEnable"):
        args.append('-rst')
        args.append(stash_scene_name+".json")

    if anim is False:
        frametasktitle = "%s Frame: %d" % (tasktitle, int(start))

        frametask = author.Task()
        frametask.title = frametasktitle
        frametask.serialsubtasks = True

        if beauty_dspy_variance:
            img_expanded = FilePath(apistr.expand_string(
                FilePath(imgOutputDir).join(imgFileFormat), display=beauty_dspy_variance)).os_path()
        else:
            img_expanded = FilePath(apistr.expand_string(
                FilePath(imgOutputDir).join(imgFileFormat))).os_path()

	if os.path.splitext(img_expanded)[1] == '.it':
            args.append('-of')
            args.append('it')
            rfm2.render.show_it()
        mayabatch_tasktitle = "%s (mayabatch render)" % frametasktitle
        add_maya_batch_render_task(frametask, mayabatch_tasktitle, stash_scene_name,
                               img_expanded, anim, start, start, by, args)

        if not do_bake:
            generate_denoise_tasks(frametasktitle, frametask, displays, start)

        parent_task.addChild(frametask)

    else:
        parent_task.serialsubtasks = True
        renderframestask = author.Task()
        renderframestask.serialsubtasks = False
        renderframestasktitle = ("Render Frames")
        renderframestask.title = renderframestasktitle

        for iframe in range(int(start), last + 1, int(chunk * by)):
            e = iframe + (chunk * by) - by
            if e > last:
                e = last

            mayabatch_tasktitle = "%s Frames: (%d-%d) (mayabatch render)" % (tasktitle,
                                                  int(iframe), int(e))
            if beauty_dspy_variance:
                img_expanded = FilePath(apistr.expand_string(
                    FilePath(imgOutputDir).join(imgFileFormat), display=beauty_dspy_variance)).os_path()
            else:
                img_expanded = FilePath(apistr.expand_string(
                    FilePath(imgOutputDir).join(imgFileFormat))).os_path()

	    if os.path.splitext(img_expanded)[1] == '.it':
                args.append('-of')
                args.append('it')
                rfm2.render.show_it()

            add_maya_batch_render_task(renderframestask, mayabatch_tasktitle, stash_scene_name,
                                   img_expanded, anim, iframe, e, by, args)

        parent_task.addChild(renderframestask)

        denoiseframestask = author.Task()
        denoiseframestask.serialsubtasks = False
        denoiseframestasktitle = ("Denoise Frames")
        denoiseframestask.title = denoiseframestasktitle
        if not do_bake:
            for iframe in range(int(start), int(last + 1), int(by)):
                mc.currentTime(iframe)
                if beauty_dspy_variance:
                    img_expanded = FilePath(apistr.expand_string(
                        FilePath(imgOutputDir).join(imgFileFormat), display=beauty_dspy_variance)).os_path()
                else:
                    img_expanded = FilePath(apistr.expand_string(
                        FilePath(imgOutputDir).join(imgFileFormat))).os_path()

                denoisetasktitle = ("Denoise Frame: %d" % int(start) )

                generate_denoise_tasks(denoisetasktitle, denoiseframestask, displays, iframe, start=int(start),
                                            end=int(last), by=int(by))

            parent_task.addChild(denoiseframestask)

def generate_job_file(is_localqueue, scene, stash_scene_name, do_RIB, do_bake):
    """Generate a job file using the Tractor's Job Author API.

    Args:
    - is_localqueue (bool) - are we generating the job file for LocalQueue or not.
    - scene (str) - the current scene name.
    - stash_scene_name (str) - full path to the unique version of the scene file.
                             See 'stash_scene' function.
    - do_RIB (bool) - controls whether to generate RIB for the scene.
    - do_bake (bool) - controls whether to render using the bake hider,
                    which runs PxrBakeTexture nodes in bake mode.

    Returns:
    - job (Job) - Tractor job instance. See 'Job Author Python API' in the
                  Tractor documentation.
    - jobfile (str) - Full path to the job file on disk.

    """

    job = author.Job()
    job.title = str(scene)
    job.serialsubtasks = True
    add_job_level_attrs(is_localqueue, job)

    anim = mc.getAttr('defaultRenderGlobals.animation')
    start = mc.getAttr('defaultRenderGlobals.startFrame')
    end = mc.getAttr('defaultRenderGlobals.endFrame')
    by = int(mc.getAttr('defaultRenderGlobals.byFrameStep'))
    chunk = rfm2.ui.prefs.get_pref_by_name('rfmRenderBatchFrameChunk')
    do_cleanup = int(rfm2.ui.prefs.get_pref_by_name('rfmTractorCleanup'))

    dspys_asrgba = {}
    checkpoint = str(rfm2.ui.prefs.get_pref_by_name('rfmRenderBatchCheckpoint'))
    # if we're checkpointing, temporarily turn off asrgba for all openexr displays
    if checkpoint != '':
        for d in mc.ls('d_openexr*'):
            dspys_asrgba[d] = mc.getAttr('%s.asrgba' % d)
            mc.setAttr('%s.asrgba' % d, 0)

    if by == 0:
        by = 1
    if anim is False:
        start = mc.currentTime(query=True)

    last = int(start + 1)
    if anim is True and (end > start):
        last = int(end)
    else:
        anim = False

    threads = int(rfm2.ui.prefs.get_pref_by_name('rfmBatchThreads'))

    displays = apidspy.get_displays()['displays']
    beauty_dspy_variance = None
    xgen_files = []

    # check if the dspy got renamed to variance
    for d in displays:
        if d.endswith('variance'):
            beauty_dspy_variance = d
            break

    tasktitle = "Render %s" % (str(scene))
    parent_task = author.Task()
    parent_task.title = tasktitle

    if do_RIB:
        generate_rib_render_tasks(is_localqueue, anim, parent_task, tasktitle, displays, beauty_dspy_variance, start, last, by, chunk, threads, do_bake, checkpoint)
    else:
        # mayabatch
        xgen_files = sputils.stash_xgen_files(stash_scene_name)
        generate_maya_batch_render_tasks(stash_scene_name, anim, parent_task, tasktitle, displays, beauty_dspy_variance, start, last, by, chunk, threads, do_bake, checkpoint)

    # txmake tasks
    txmakeTasks = generate_txmake_tasks()
    job.addChild(txmakeTasks)

    job.addChild(parent_task)
    jobfile = os.path.splitext(stash_scene_name)[0] + '.alf'

    if do_cleanup:
        if do_RIB is False:
            stashCleanup = author.Command(local=False)
            stashCleanup.argv = ["TractorBuiltIn", "File", "delete",
                                 "%%D(%s)" % stash_scene_name]
            job.addCleanup(stashCleanup)
            if mc.about(api=True) >= 20180300 and mc.optionVar(q="renderSetupEnable"):
                stashRSCleanup = author.Command(local=False)
                stashRSCleanup.argv = ["TractorBuiltIn", "File", "delete",
                                 "%%D(%s)" % (stash_scene_name + ".json")]
                job.addCleanup(stashRSCleanup)

        if is_localqueue is False:
            jobFileCleanup = author.Command(local=False)
            jobFileCleanup.argv = ["TractorBuiltIn", "File", "delete",
                                   "%%D(%s)" % jobfile]
            job.addCleanup(jobFileCleanup)

        # clean up for stashed xgen files
        for f in xgen_files:
            xgen_cleanup = author.Command(local=False)
            xgen_cleanup.argv = ["TractorBuiltIn", "File", "delete", "%s" % f]
            job.addCleanup(xgen_cleanup)

    # turn asrgba back
    if checkpoint != '':
        for k,v in dspys_asrgba.iteritems():
            mc.setAttr('%s.asrgba' % k, dspys_asrgba[k])

    try:
        f = open(jobfile, 'w')
        as_tcl = job.asTcl()
        f.write(as_tcl)
        f.close()
    except IOError as ioe:
        raise RfmError('IO Exception when writing job file %s: %s' % (jobfile, str(ioe)))
    except Exception, e:
        raise RfmError('Could not write job file %s: %s' % (jobfile, str(e)))

    return [job, jobfile]

def batch_render_spool(do_bake=False):
    """Main entry point to start a spooled batch render job. Will spool
    to either LocalQueue or Tractor, depending on the rfmRenderBatchQueue pref.
    """
    spoolstyle = rfm2.ui.prefs.get_pref_by_name('rfmRenderBatchSpoolStyle')
    if spoolstyle == 'RIB' and mel.eval('rman ctxIsOpen'):
        rfm_log().warning("Can't generate rib while rendering");
        return

    rfm2.render.RNDR.set_render_type(rfm2.render.RT_BATCH)

    # tell texture manager to start parsing scene, before
    # we set up batch rendering
    txmgr_maya.parse_maya_scene()

    stash_scene_name = ''
    is_localqueue = False
    queue = rfm2.ui.prefs.get_pref_by_name('rfmRenderBatchQueue')
    if queue == 'Local Queue':
        is_localqueue = True

    scene_file = mc.file(query=True, sceneName=True)
    if scene_file == '':
        scene_file = 'untitled'
    scene = os.path.basename(scene_file)

    do_RIB = False
    if spoolstyle == 'RIB':
        do_RIB = True
        stash_scene_name = sputils.stash_scene(doSave=False)
    else:
        stash_scene_name = sputils.stash_scene(doSave=True)

    job, jobfile = generate_job_file(is_localqueue, scene, stash_scene_name,
                                     do_RIB, do_bake)
    if is_localqueue:
        lq = cfg().renderer_executable('LocalQueue')
        args = []
        args.append(lq.os_path())
        args.append(jobfile)
        rfm_log().info('Spooling job to LocalQueue: %s.', jobfile)
        subprocess.Popen(args)
    else:
        # spool to tractor
        tractor_engine = 'tractor-engine'
        tractor_port = '5600'
        if 'TRACTOR_ENGINE' in os.environ:
            tractor_env = os.environ['TRACTOR_ENGINE'].split(':')
            tractor_engine = tractor_env[0]
            if len(tractor_env) > 1:
                tractor_port = tractor_env[1]

        try:
            spoolhost = socket.gethostname()
            owner = getpass.getuser()
            job.spool(block=True, spoolfile=jobfile, spoolhost=spoolhost,
                      owner=owner, hostname=tractor_engine,
                      port=int(tractor_port))
            rfm_log().info('Spooling to Tractor Engine: %s:%s, Job File: %s', tractor_engine,
                           tractor_port, jobfile)
        except author.SpoolError as spoolError:
            mc.sysFile(stash_scene_name, delete=True)
            mc.sysFile(jobfile, delete=True)
            raise RfmError('A communication error has occured with Tractor '
                           'Engine (%s:%s): %s' %
                           (tractor_engine, tractor_port, str(spoolError)))
        except Exception, e:
            mc.sysFile(stash_scene_name, delete=True)
            mc.sysFile(jobfile, delete=True)
            raise RfmError('Unexpected error spooling job file to Tractor '
                           'Engine (%s:%s): %s' %
                           (tractor_engine, tractor_port, str(e)))

def batch_preview():
    """Generate a simple job file
    and spool to LocalQueue, rendering to 'it'
    """

    curLayer = mel.eval("editRenderLayerGlobals -q -currentRenderLayer")
    renderable = mc.getAttr("%s.renderable" % curLayer)
    if not renderable:
        rfm_log().error("Layer: %s is not renderable" % curLayer)
        return

    is_localqueue = False
    queue = rfm2.ui.prefs.get_pref_by_name('rfmRenderBatchQueue')
    if queue == 'Local Queue':
        is_localqueue = True

    rfm2.render.render_with_renderman()
    rfm2.render.RNDR.set_render_type(rfm2.render.RT_PREVIEW)

    # turn off animation temporarily
    anim = mc.getAttr('defaultRenderGlobals.animation')
    mc.setAttr('defaultRenderGlobals.animation', 0)

    # tell texture manager to start parsing scene,
    # before we set up batch rendering
    txmgr_maya.parse_maya_scene()

    scene_file = mc.file(query=True, sceneName=True)
    if scene_file == '':
        scene_file = 'untitled'
    scene = os.path.basename(scene_file)

    stash_scene_name = sputils.stash_scene(doSave=True)
    threads = int(rfm2.ui.prefs.get_pref_by_name('rfmBatchThreads'))

    xgen_files = sputils.stash_xgen_files(stash_scene_name)

    job = author.Job()
    job.title = str(scene)
    job.serialsubtasks = True
    job.service = 'PixarRender'

    tasktitle = "Render %s" % (str(scene))
    parentTask = author.Task()
    parentTask.title = tasktitle

    curFrame = mc.currentTime(query=True)

    frametasktitle = "%s Frame %d" % (tasktitle, int(curFrame))

    frametask = author.Task()
    frametask.title = frametasktitle
    frametask.serialsubtasks = True
    mayabatch_tasktitle = "%s (mayabatch render)" % frametasktitle
    args = ["-of", "it", "-t", "%d" % threads]
    add_maya_batch_render_task(frametask, mayabatch_tasktitle, stash_scene_name,
                           '', False, curFrame, curFrame, 1, args)

    parentTask.addChild(frametask)

    # txmake tasks
    txmakeTasks = generate_txmake_tasks()
    job.addChild(txmakeTasks)

    job.addChild(parentTask)

    stash_cleanup = author.Command(local=False)
    stash_cleanup.argv = ["TractorBuiltIn", "File", "delete", "%s" % stash_scene_name]
    job.addCleanup(stash_cleanup)

    for f in xgen_files:
        xgen_cleanup = author.Command(local=False)
        xgen_cleanup.argv = ["TractorBuiltIn", "File", "delete", "%s" % f]
        job.addCleanup(xgen_cleanup)

    jobfile = os.path.splitext(stash_scene_name)[0] + '.alf'

    try:
        f = open(jobfile, 'w')
        f.write(job.asTcl())
        f.close()
    except IOError as ioe:
        raise RfmError('IO Exception when writing job file %s: %s' % (jobfile, str(ioe)))
    except Exception, e:
        raise RfmError('Could not write job file %s: %s' % (jobfile, str(e)))

    lq = cfg().renderer_executable('LocalQueue')
    args = []
    args.append(lq.os_path())
    args.append(jobfile)
    rfm_log().info('Spooling job to LocalQueue: %s.', jobfile)
    subprocess.Popen(args)

    # restore animation setting
    mc.setAttr('defaultRenderGlobals.animation', anim)

def register_tractor_prefs():
    """Register Tractor preferences."""

    import rfm2.utils.node_desc as node_desc
    prefGroup = '0 Render'

    pref = {'name': 'rfmTractorPaused', 'type': 'int',
            'default': 0, 'label': 'Start Paused:',
            'page': 'Render/Batch Render/Tractor', 'widget': 'checkBox',
            'help': ("""Job will be set to paused when spooled.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorCleanup', 'type': 'int',
            'default': 1, 'label': 'Delete Temp Files:',
            'page': 'Render/Batch Render/Tractor', 'widget': 'checkBox',
            'help': ("""Job will clean up any temporary files needed for batch rendering.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorPriority', 'type': 'int',
            'default': 1, 'label': 'Priority:',
            'page': 'Render/Batch Render/Tractor',
            'page_open': 'false',
            'help': ("""Priority for your job.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorService', 'type': 'string',
            'default': 'PixarRender', 'label': 'Service:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Service keys for your job.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorEnvKey', 'type': 'string',
            'default': '', 'label': 'Env Keys:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Multiple keys can be specified and should be space """
                     """separated.<P>
            These environment keys are
            recognized by LocalQueue and Tractor out of box:
            <ul><li>maya-* (eg. maya-2018)
            <li>rfm-* (eg. rfm-22.0)
            <li>rmantree=* (eg. rmantree=$RMANTREE)
            <li>rfmtree=* (eg. rfmtree=$RFMTREE)</ul>""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorAfter', 'type': 'string',
            'default': '', 'label': 'After:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Delay start of job processing until given time<br>
            Format: MONTH/DAY HOUR:MINUTES<br>
            Ex: 11/24 13:45""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorCrews', 'type': 'string',
            'default': '', 'label': 'Crews:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""List of crews. See 'Crews' in the Tractor """
                     """documentation.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorTier', 'type': 'string',
            'default': '', 'label': 'Tier:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Dispatching tier that the job belongs to. See """
                     """'Scheduling Modes' in the Tractor documentation.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorProjects', 'type': 'string',
            'default': '', 'label': 'Projects:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Project that job belongs to. See 'Limits """
                     """Configuration' in the Tractor documentation.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorComment', 'type': 'string',
            'default': '', 'label': 'Comments:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Additional comment about the job.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorMetaData', 'type': 'string',
            'default': '', 'label': 'Metadata:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Meta data to add to the job.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorWhenDone', 'type': 'string',
            'default': '', 'label': 'When Done Command:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Command to run when job completes withour error.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorWhenError', 'type': 'string',
            'default': '', 'label': 'When Error Command:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Command to run if there is an error executing """
                     """the job.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

    pref = {'name': 'rfmTractorWhenAlways', 'type': 'string',
            'default': '', 'label': 'When Always Command:',
            'page': 'Render/Batch Render/Tractor',
            'help': ("""Command to run regardless if job completes with or """
                     """without errors.""")}
    rfm2.ui.prefs.register_pref_item(prefGroup,
                                     node_desc.NodeDescParamJSON(pref))

