//CopyRight Dustin Nelson 2010-2016. Please do not distribute
//http://www.creativecrash.com/maya/script/-rapid-rig-modular-procedural-auto-rig-for-maya
//Script for Modular Character Rigging.
//VERSION 1.8.3
//September 13, 2016
//FILE IS NOT INTENDED TO BE HARMFUL, HOWEVER USE AT YOUR OWN RISK
/*/////////////////////////////////////////////////////////////////////////////
// 
//	INSTRUCTIONS:
//	1. INSTALLATION
//	TYPE IN THE FOLLOWING COMMAND IN MAYA TO GET YOUR SCRIPT DIRECTORY:
//
//	internalVar -userScriptDir;
//
//	2. PUT THE RapidRig_Modular_V1.mel FILE IN THAT DIRECTORY.
//
//	3. START UP MAYA, ENTER THE FOLLOWING COMMAND INTO
//	THE COMMAND LINE OR THE SCRIPT EDITOR:
//
//	RapidRig_Modular_V1;
//
//	4. TO HAVE EASY ACCESS TO SCRIPT, CREATE A SHELF BUTTON             
//	WITH ONLY THAT COMMAND. EVERY TIME YOU HIT THE BUTTON,              
//	THE RAPID RIG INTERFACE WILL POP UP. HAPPY ANIMATING!               
//                                                                      
////////////////////////////////////////////////////////////////////////*/

global proc int RRM_CheckName_V1(string $validate)
{
	string $nameMatch = `match "^[a-zA-Z][0-9a-zA-Z_]*$" $validate`;
	int $goodMatch = ! `strcmp $nameMatch $validate`;
	
	return $goodMatch;
}

global proc RRM_CreateProxyModuleProxy_V1(string $crntUnit)
{
	//SET UNITS TO CENTIMETERS
	//string $crntUnit = `currentUnit -query -linear`;

	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	
	//CREATE PROXY BASE
	circle -n RRM_Base -nr 0 1 0 -r 0.25 -ch 0;
	duplicate -rr -n RRM_BaseB;
	rotate 90 0 0 RRM_BaseB;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_BaseB;
	duplicate -rr -n RRM_BaseCtrl;
	rotate 0 90 0 RRM_BaseCtrl; 
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_BaseCtrl;
	
	spaceLocator -n RRM_BaseD;
	setAttr ("RRM_BaseDShape.localScale", 0.25, 0.25, 0.25);
	if ($crntUnit == "m")
	{
	setAttr ("RRM_BaseDShape.localScale", 0.0025, 0.0025, 0.0025);
	}
		
	parent -r -s RRM_BaseBShape RRM_BaseCtrlShape RRM_BaseDShape RRM_Base;
	delete RRM_BaseB RRM_BaseCtrl RRM_BaseD;
	select RRM_Base;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_Base;
	
	//ADD CORE ATTRIBUTE
	addAttr -ln "core" -dt "string" RRM_Base;
	setAttr -e-keyable 1 RRM_Base.core;
	
	//ADD EXT ATTRIBUTE
	addAttr -ln "ext" -dt "string" RRM_Base;
	setAttr -e-keyable 1 RRM_Base.ext;

	//ADD CLONE ATTRIBUTE
	addAttr -ln "clone" -dt "string" RRM_Base;
	setAttr -e-keyable 1 RRM_Base.clone;

	//ADD MODNAME ATTRIBUTE
	addAttr -ln "modName" -dt "string" RRM_Base;
	setAttr -e-keyable 1 RRM_Base.modName;
	
	setAttr -lock 1 -keyable 0 "RRM_Base.v";

	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

global proc RRM_CreateProxyBaseUpProxy_V1(string $crntUnit)
{
	////SET UNITS TO CENTIMETERS
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}

	circle -n RRM_BaseUp -nr 0 1 0 -ch 0;
	circle -n RRM_BaseUpB -nr 1 0 0 -ch 0;
	circle -n RRM_BaseUpCtrl -nr 0 0 1 -ch 0;
	curve -n RRM_BaseUpD -d 1 -p 0 -1 0 -p 0 3 0 -k 0 -k 1 ;
	rename `listRelatives -c RRM_BaseUpD` RRM_BaseUpDShape;
	curve -n RRM_BaseUpE -d 1 -p 0 2.5 0.5 -p 0 3 0 -p 0 2.5 -0.5 -k 0 -k 1 -k 2 ;
	rename `listRelatives -c RRM_BaseUpE` RRM_BaseUpEShape;
	curve -n RRM_BaseUpF -d 1 -p -0.5 2.5 0 -p 0 3 0 -p 0.5 2.5 0 -k 0 -k 1 -k 2 ;
	rename `listRelatives -c RRM_BaseUpF` RRM_BaseUpFShape;
	circle -n RRM_BaseUpG -c 0 2.5 0 -nr 0 1 0 -r 0.5 -ch 0;
	rename `listRelatives -c RRM_BaseUpG` RRM_BaseUpGShape;

	
	spaceLocator -n RRM_BaseUpH;
	setAttr ("RRM_BaseUpHShape.localScale", .25, .25, .25);
	if ($crntUnit == "m")
	{
		setAttr ("RRM_BaseUpHShape.localScale", 0.0025, 0.0025, 0.0025);
	}
	
	parent -r -s RRM_BaseUpBShape RRM_BaseUpCtrlShape RRM_BaseUpDShape RRM_BaseUpEShape RRM_BaseUpFShape RRM_BaseUpGShape RRM_BaseUpHShape RRM_BaseUp;
	delete RRM_BaseUpB RRM_BaseUpCtrl RRM_BaseUpD RRM_BaseUpE RRM_BaseUpF RRM_BaseUpG RRM_BaseUpH;
	scale -r 0.25 0.25 0.25 RRM_BaseUp;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_BaseUp;
	
	//ADD CORE ATTRIBUTE
	addAttr -ln "core" -dt "string" RRM_BaseUp;
	setAttr -e-keyable 1 RRM_BaseUp.core;

	//ADD EXT ATTRIBUTE
	addAttr -ln "ext" -dt "string" RRM_BaseUp;
	setAttr -e-keyable 1 RRM_BaseUp.ext;
	
	//ADD CORE ATTRIBUTE
	addAttr -ln "clone" -dt "string" RRM_BaseUp;
	setAttr -e-keyable 1 RRM_BaseUp.clone;

	//ADD MODNAME ATTRIBUTE
	addAttr -ln "modName" -dt "string" RRM_BaseUp;
	setAttr -e-keyable 1 RRM_BaseUp.modName;

	setAttr -lock 1 -keyable 0 "RRM_BaseUp.v";


}

global proc RRM_CreateProxyRootProxy_V1(string $crntUnit)
{
	//SET UNITS TO CENTIMETERS
	//string $crntUnit = `currentUnit -query -linear`;

	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
		
	//CREATE PROXY BASE
	RRM_CreateProxyModuleProxy_V1($crntUnit);
	rename RRM_Base RRM_ROOT;
	
	curve -n RRM_ROOTE -d 1 -p 0.5 0.5 0.5 -p 0.5 0.5 -0.5 -p -0.5 0.5 -0.5 -p -0.5 0.5 0.5 -p -0.5 -0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 0.5 0.5 -p -0.5 0.5 0.5
	-p -0.5 0.5 -0.5 -p -0.5 -0.5 -0.5 -p 0.5 -0.5 -0.5 -p 0.5 0.5 -0.5 -p 0.5 0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 -0.5 -0.5 -p -0.5 -0.5 -0.5 -p -0.5 -0.5 0.5
	-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 ;
	rename `listRelatives -c RRM_ROOTE` RRM_ROOTEShape;
	parent -r -s RRM_ROOTEShape RRM_ROOT;
	delete RRM_ROOTE;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_ROOT;

	setAttr -lock 1 -keyable 0 "RRM_ROOT.v";


}

global proc RRM_CreateProxyCOG_C_V1(string $crntUnit)
{
	//SET UNITS TO CENTIMETERS
	//string $crntUnit = `currentUnit -query -linear`;

	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	
	circle -n RRM_OuterCOG_Ctrl -r 6 -nr 0 1 0 -ch 0;
	circle -n RRM_InnerCOG_Ctrl -r 3 -nr 0 1 0 -ch 0;
	rotate -r -os 0 -18 0 RRM_InnerCOG_Ctrl;
	curve -n RRM_XConnectorCOG_Ctrl -d 1 -p 6 0 0 -p -6 0 0 -k 0 -k 1 ;
	rename `listRelatives -c RRM_XConnectorCOG_Ctrl` RRM_XConnectorCOG_CtrlShape;
	curve -n RRM_YConnectorCOG_Ctrl -d 1 -p 0 0 -6 -p 0 0 6 -k 0 -k 1 ;
	rename `listRelatives -c RRM_YConnectorCOG_Ctrl` RRM_YConnectorCOG_CtrlShape;
	
	$transforms = `ls RRM_InnerCOG_Ctrl RRM_XConnectorCOG_Ctrl RRM_YConnectorCOG_Ctrl`;
	//pickWalk -d down;
	$curves = `listRelatives -c $transforms`;
	parent -r -s $curves RRM_OuterCOG_Ctrl;
	delete $transforms;
	rename RRM_OuterCOG_Ctrl RRM_COG;
	
	setAttr -lock 1 -keyable 0 "RRM_COG.v";

	setAttr -l 1 -k 0 "RRM_COG.v";
}


global proc RRM_CreateProxyParentProxy_V1(string $crntUnit)
{
	//SET UNITS TO CENTIMETERS
	//string $crntUnit = `currentUnit -query -linear`;

	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
		
	//CREATE PROXY PARENT
	curve -n RRM_Parent -d 1 -p 0.5 1 0.5 -p 0.5 1 -0.5 -p -0.5 1 -0.5 -p -0.5 1 0.5 -p -0.5 0.1 0.5 -p 0.5 0.1 0.5 -p 0.5 1 0.5 -p -0.5 1 0.5
	-p -0.5 1 -0.5 -p -0.5 0.1 -0.5 -p 0.5 0.1 -0.5 -p 0.5 1 -0.5 -p 0.5 1 0.5 -p 0.5 0.1 0.5 -p 0.5 0.1 -0.5 -p -0.5 0.1 -0.5 -p -0.5 0.1 0.5
	-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 ;
	rename `listRelatives -c RRM_Parent` RRM_ParentShape;
	scale -r 0.8 1.25 0.8 RRM_Parent;
	makeIdentity -apply true -s 1 RRM_Parent;
	
	curve -n RRM_ParentB -d 1 -p 0.5 0.5 0.5 -p 0.5 0.5 -0.5 -p -0.5 0.5 -0.5 -p -0.5 0.5 0.5 -p -0.5 -0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 0.5 0.5 -p -0.5 0.5 0.5
	-p -0.5 0.5 -0.5 -p -0.5 -0.5 -0.5 -p 0.5 -0.5 -0.5 -p 0.5 0.5 -0.5 -p 0.5 0.5 0.5 -p 0.5 -0.5 0.5 -p 0.5 -0.5 -0.5 -p -0.5 -0.5 -0.5 -p -0.5 -0.5 0.5
	-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 ;
	rename `listRelatives -c RRM_ParentB` RRM_ParentBShape;
	scale -r 0.25 0.75 0.25 RRM_Parent;
	scale -r 0.5 0.5 0.5 RRM_ParentB;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_Parent RRM_ParentB;		

	spaceLocator -n RRM_ParentCtrl;
	setAttr ("RRM_ParentCtrlShape.localScale", .25, .25, .25);
	if ($crntUnit == "m")
	{
		setAttr ("RRM_ParentCtrlShape.localScale", 0.0025, 0.0025, 0.0025);
	}
	
	parent -r -s RRM_ParentBShape RRM_ParentCtrlShape RRM_Parent;
	delete RRM_ParentB RRM_ParentCtrl;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_Parent;

	//ADD PARENT ATTRIBUTE
	addAttr -ln "parent"  -dt "string" RRM_Parent;
	setAttr -e-keyable 1 RRM_Parent.parent;

	addAttr -ln "attachNode"  -dt "string" RRM_Parent;
	setAttr -e-keyable 1 RRM_Parent.attachNode;
	
	//ADD PINNED ATTRIBUTE
	addAttr -ln "pinned"  -at bool RRM_Parent;
	setAttr -e-keyable 1 RRM_Parent.pinned;
	setAttr RRM_Parent.pinned 0;
	setAttr -lock 1 RRM_Parent.pinned;
	
	//ADD CONNECTOR VIZ ATTRIBUTE
	addAttr -ln "connectors"  -at bool RRM_Parent;
	setAttr -e-keyable 1 RRM_Parent.connectors;
	setAttr RRM_Parent.connectors 1;
	
	//SET SO CAN'T ATTACH TO PARENT OBJECT
	addAttr -ln "noAttach"  -dt "string" RRM_Parent;
	setAttr -e-keyable 1 RRM_Parent.noAttach;
	

	//ADD CORE ATTRIBUTE
	addAttr -ln "core" -dt "string" RRM_Parent;
	setAttr -e-keyable 1 RRM_Parent.core;

	//ADD EXT ATTRIBUTE
	addAttr -ln "ext" -dt "string" RRM_Parent;
	setAttr -e-keyable 1 RRM_Parent.ext;

	//ADD CLONE ATTRIBUTE
	addAttr -ln "clone" -dt "string" RRM_Parent;
	setAttr -e-keyable 1 RRM_Parent.clone;

	//ADD MODNAME ATTRIBUTE
	addAttr -ln "modName" -dt "string" RRM_Parent;
	setAttr -e-keyable 1 RRM_Parent.modName;

	setAttr -lock 1 -keyable 0 "RRM_Parent.v";


}

global proc RRM_CreateProxyEndProxy_V1(string $crntUnit)
{
	//SET UNITS TO CENTIMETERS
	//string $crntUnit = `currentUnit -query -linear`;

	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
		
	//CREATE PROXY END
	circle -n RRM_End -nr 0 1 0 -r 0.25 -ch 0;
	duplicate -rr -n RRM_EndB;
	rotate 90 0 0 RRM_EndB;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_EndB;
	duplicate -rr -n RRM_EndCtrl;
	rotate 0 90 0 RRM_EndCtrl;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_EndCtrl;
	curve -n RRM_EndD -d 1 -p 0.375 -0.25 -0.375 -p 0 0.5 0 -p 0.375 -0.25 0.375 -p 0.375 -0.25 -0.375 -p -0.375 -0.25 -0.375 -p 0 0.5 0 -p -0.375 -0.25 0.375
	-p -0.375 -0.25 -0.375 -p -0.375 -0.25 0.375 -p 0.375 -0.25 0.375 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 ;
	rename `listRelatives -c RRM_EndD` RRM_EndDShape;

	spaceLocator -n RRM_EndE;
	setAttr ("RRM_EndEShape.localScale", .25, .25, .25);
	if ($crntUnit == "m")
	{
	setAttr ("RRM_EndEShape.localScale", 0.0025, 0.0025, 0.0025);
	}
	
	parent -r -s RRM_EndBShape RRM_EndCtrlShape RRM_EndDShape RRM_EndEShape RRM_End;
	delete RRM_EndB RRM_EndCtrl RRM_EndD RRM_EndE;
	makeIdentity -apply true -t 1 -r 1 -s 1 RRM_End;

	//ADD CORE ATTRIBUTE
	addAttr -ln "core" -dt "string" RRM_End;
	setAttr -e-keyable 1 RRM_End.core;

	//ADD EXT ATTRIBUTE
	addAttr -ln "ext" -dt "string" RRM_End;
	setAttr -e-keyable 1 RRM_End.ext;

	//ADD CLONE ATTRIBUTE
	addAttr -ln "clone" -dt "string" RRM_End;
	setAttr -e-keyable 1 RRM_End.clone;

	//ADD MODNAME ATTRIBUTE
	addAttr -ln "modName" -dt "string" RRM_End;
	setAttr -e-keyable 1 RRM_End.modName;

	setAttr -lock 1 -keyable 0 "RRM_End.v";
}


global proc RRM_ProxyLockNodes_V1(string $modNodes[])
{
	lockNode $modNodes;
}

global proc RRM_ProxyLimits_V1(string $xforms[])
{
	for ($each in $xforms)
	{
		transformLimits -sx 0.01 1 -esx 1 0 $each;
		transformLimits -sy 0.01 1 -esy 1 0 $each;
		transformLimits -sz 0.01 1 -esz 1 0 $each;
	}
}
	

global proc RRM_ProxyConnectors_V1(string $modName, string $prfx, string $node1, string $node2)
{
	$selection = `ls -sl`;
	$node1Loc = `xform -q -ws -rp $node1`;
	$node2Loc = `xform -q -ws -rp $node2`;
	
	if ($prfx == "r_")
	{
		if (`objExists ($node1 + ".pair")`&&`objExists ($node2 + ".parent")`)
		{
			$rightAttachPoint = `getAttr ($node1 + ".opposite")`;
			$node1 = ("RRM_" + $rightAttachPoint);
			$node1Loc = `xform -q -ws -rp $node1`;
		}
		else if (`objExists ($node1 + ".pair")`&&`objExists ($node2 + ".modType")`)
		{
			$rightAttachPoint = `getAttr ($node1 + ".opposite")`;
			$node1 = ("RRM_" + $rightAttachPoint);
			$node1Loc = `xform -q -ws -rp $node1`;
		}
		
	}
	
	
	//NEW
	curve -n ($node1 + "_" + $node2 + "Ctrl") -d 1 -p 0 0 0 -p 1 0 0 -k 0 -k 1 ;
	rename `listRelatives ($node1 + "_" + $node2 + "Ctrl")` ($node1 + "_" + $node2 + "CtrlShape");
	spaceLocator -n ($node1 + "_" + $node2 + "_AimLctr");
	spaceLocator -n ($node1 + "_" + $node2 + "_TargetLctr");
	parent ($node1 + "_" + $node2 + "_TargetLctr") ($node1 + "_" + $node2 + "_AimLctr");
	pointConstraint $node1 ($node1 + "_" + $node2 + "_AimLctr");
	aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" $node2 ($node1 + "_" + $node2 + "_AimLctr");
	pointConstraint $node2 ($node1 + "_" + $node2 + "_TargetLctr");
	connectAttr -f ($node1 + "_" + $node2 + "_AimLctr.translate") ($node1 + "_" + $node2 + "Ctrl.translate");
	connectAttr -f ($node1 + "_" + $node2 + "_AimLctr.rotate") ($node1 + "_" + $node2 + "Ctrl.rotate");
	connectAttr -f ($node1 + "_" + $node2 + "_TargetLctr.tx") ($node1 + "_" + $node2 + "Ctrl.sx");
	setAttr ($node1 + "_" + $node2 + "_AimLctr.v") 0;
	
	//ONLY TEMPLATE IF IT IS NOT A PARENT NODE
	if (!`objExists ($node2 + ".parent")` && !`objExists ($node2 + ".modType")`)
	{
		setAttr ($node1 + "_" + $node2 + "Ctrl.template") 1;
	}
	else
	{
		setAttr ($node1 + "_" + $node2 + "Ctrl.overrideEnabled") 1;
		setAttr ($node1 + "_" + $node2 + "Ctrl.overrideColor") 6;
	}
	
	if (!`objExists ("RRM_" + $prfx + $modName + "_ConnectorGrp")`)
	{
		group -em -n ("RRM_" + $prfx + $modName + "_ConnectorGrp"); xform -os -piv 0 0 0;
		setAttr ("RRM_" + $prfx + $modName + "_ConnectorGrp.inheritsTransform") 0;
		parent ("RRM_" + $prfx + $modName + "_ConnectorGrp") ("RRM_" + $prfx + $modName);
		
		if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
		{
			connectAttr -f  ("RRM_" + $prfx + $modName + "_Parent.connectors") ("RRM_" + $prfx + $modName + "_ConnectorGrp.v");
		}
		else
		{
			connectAttr -f  ("RRM_" + $prfx + $modName + "_Aux.connectors") ("RRM_" + $prfx + $modName + "_ConnectorGrp.v");
		}
	}
	parent ($node1 + "_" + $node2 + "Ctrl") ($node1 + "_" + $node2 + "_AimLctr") ("RRM_" + $prfx + $modName + "_ConnectorGrp");
	setAttr (($node1 + "_" + $node2 + "_AimLctr.scale"), 1,1,1);
	
	setAttr -lock 1 -keyable 0 ($node1 + "_" + $node2 + "Ctrl.tx");
	setAttr -lock 1 -keyable 0 ($node1 + "_" + $node2 + "Ctrl.ty");
	setAttr -lock 1 -keyable 0 ($node1 + "_" + $node2 + "Ctrl.tz");
	setAttr -lock 1 -keyable 0 ($node1 + "_" + $node2 + "Ctrl.rx");
	setAttr -lock 1 -keyable 0 ($node1 + "_" + $node2 + "Ctrl.ry");
	setAttr -lock 1 -keyable 0 ($node1 + "_" + $node2 + "Ctrl.rz");
	setAttr -lock 1 -keyable 0 ($node1 + "_" + $node2 + "Ctrl.sx");
	setAttr -lock 1 -keyable 0 ($node1 + "_" + $node2 + "Ctrl.sy");
	setAttr -lock 1 -keyable 0 ($node1 + "_" + $node2 + "Ctrl.sz");
	setAttr -lock 1 -keyable 0 ($node1 + "_" + $node2 + "Ctrl.v");	
	
	
	$modNodes = `ls -sl`;
	RRM_ProxyLockNodes_V1($modNodes);
	select $selection;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//changeLinearUnit $crntUnit;	
}
	

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////MAIN & ROOT/////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyMainProxy_V1(int $checkTemplate)
{

	
	if (`objExists "RRM_MAIN"`)
	{
		string $selectControl = `confirmDialog
			-title "A Proxy Rig Already Exists In This Scene"
			-message "You must either delete the existing Proxy rig or RRM_Generate a final rig before creating a new Proxy rig."
			-button "OK"
			-defaultButton "OK"
			-icon "information"`;
	}
	else
	{
		//SET UNITS TO CENTIMETERS
		string $crntUnit = `currentUnit -query -linear`;

		//if ($crntUnit != "cm")
		//{
		//	//changeLinearUnit "centimeter"
		//}
		
		curve -n RRM_MAIN -d 1 -p 0 0 11 -p 2 0 9 -p 2 0 7 -p 7 0 7 -p 7 0 2 -p 9 0 2 -p 10 0 0 -p 9 0 -2 -p 7 0 -2 -p 7 0 -7 -p 2 0 -7 -p 2 0 -9 -p 0 0 -10 -p -2 0 -9 -p -2 0 -7 -p -7 0 -7 -p -7 0 -2 -p -9 0 -2 -p -10 0 0 -p -9 0 2 -p -7 0 2 -p -7 0 7 -p -2 0 7 -p -2 0 9 -p 0 0 11 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 ;
		rename `listRelatives -c RRM_MAIN` RRM_MAINShape;
		
		curve -n RRM_MAIN2 -d 1 -p 6.5 0 6.5 -p 6.5 0 -6.5 -p -6.5 0 -6.5 -p -6.5 0 6.5 -p 6.5 0 6.5 -k 0 -k 1 -k 2 -k 3 -k 4 ;
		rename `listRelatives -c RRM_MAIN2` RRM_MAIN2Shape;
		parent -r -s RRM_MAIN2Shape RRM_MAIN;
		delete RRM_MAIN2;
		
		setAttr -lock 1 -keyable 0 "RRM_MAIN.translate";
		setAttr -lock 1 -keyable 0 "RRM_MAIN.rotate";
		setAttr -lock 1 -keyable 0 "RRM_MAIN.v";
    	
		transformLimits -sx 0.01 1 -esx 1 0 RRM_MAIN;
		transformLimits -sy 0.01 1 -esy 1 0 RRM_MAIN;
		transformLimits -sz 0.01 1 -esz 1 0 RRM_MAIN;
		
		RRM_CreateProxyRootProxy_V1($crntUnit);
    	
		transformLimits -sx 0.01 1 -esx 1 0 RRM_ROOT;
		transformLimits -sy 0.01 1 -esy 1 0 RRM_ROOT;
		transformLimits -sz 0.01 1 -esz 1 0 RRM_ROOT;

		setAttr -lock 1 -keyable 0 "RRM_ROOT.v";
    	
		setAttr "RRM_ROOT.overrideEnabled" 1;
		setAttr "RRM_ROOT.overrideColor" 17;
		
		parent RRM_ROOT RRM_MAIN;
    	
		addAttr -ln "core" -dt "string" RRM_MAIN;
		setAttr -e-keyable 1 RRM_MAIN.core;
		setAttr -type "string" RRM_MAIN.core "MAIN";
		setAttr -l true "RRM_MAIN.core";	
    	
		setAttr -type "string" RRM_ROOT.core "ROOT";
		setAttr -l true "RRM_ROOT.core";
		
		RRM_CreateProxyCOG_C_V1($crntUnit);
		//ADD CORE ATTRIBUTE
		addAttr -ln "core" -dt "string" RRM_COG;
		setAttr -e-keyable 1 RRM_COG.core;
		
		//ADD EXT ATTRIBUTE
		addAttr -ln "ext" -dt "string" RRM_COG;
		setAttr -e-keyable 1 RRM_COG.ext;
	
		//ADD CLONE ATTRIBUTE
		addAttr -ln "clone" -dt "string" RRM_COG;
		setAttr -e-keyable 1 RRM_COG.clone;
	
		//ADD MODNAME ATTRIBUTE
		addAttr -ln "modName" -dt "string" RRM_COG;
		setAttr -e-keyable 1 RRM_COG.modName;

		setAttr -type "string" RRM_COG.core "COG_Ctrl";
		setAttr -l true "RRM_COG.core";

		parent RRM_COG RRM_ROOT;
		
		addAttr -ln "twistAxis"  -at "enum" -en "X-axis:Y-axis:"  "RRM_ROOT";
		setAttr -e-keyable 1 "RRM_ROOT.twistAxis";
		setAttr "RRM_ROOT.twistAxis" 1;
		
		addAttr -ln "template_COG_Ctrl"  -at bool  RRM_ROOT;
		setAttr -e-keyable 1 RRM_ROOT.template_COG_Ctrl;
		setAttr RRM_ROOT.template_COG_Ctrl 1;
		connectAttr -f RRM_ROOT.template_COG_Ctrl RRM_COG.template;	
		
		setAttr -lock 1 -keyable 0 RRM_ROOT.v;
		
		
		//LAYER
		if (!`objExists RRM_ProxiesLayer`)
		{
			select RRM_MAIN;
			createDisplayLayer -n RRM_ProxiesLayer -number 1 -nr;
		}
		
		//PRESETS
		if ($checkTemplate == 1)
		{
			$RRM_TemplateType = `optionMenu -q -sl RRM_TemplateType`;
			if ($RRM_TemplateType == 1)
			{//HUMAN BIPED
				move -r -os -wd 0 16 0 RRM_ROOT;
				select RRM_ROOT;
				RRM_CreateProxySpline_V1("Spine", 4, 2, 0);
				move -r -os -wd 0 4 0 RRM_Spine_Top;
				//ARMS
				select RRM_Spine_Top;
				RRM_CreateProxyArm_V1("Arm", 0, 0, 0, 1, 1, 2);
				//HANDS
				select RRM_l_Arm_Wrist;
				RRM_CreateProxyFKChain_V1("Finger", 4, 4, 1, 0, 1, 1);
				select RRM_l_Arm_Wrist;
				RRM_CreateProxyFKChain_V1("Thumb", 1, 4, 3, 0, 1, 1);
				move -r -os -wd -1.5 0 -1 RRM_l_Thumb_01_01;
				move -r -os -wd 1.5 0 -1 RRM_r_Thumb_01_01;
				//HEAD
				select RRM_Spine_Top;
				RRM_CreateProxySpline_V1("Neck", 2, 2, 0);
				move -r -os -wd 0 -4.5 0 RRM_Neck_Top;
				select RRM_Neck_Top;
				RRM_CreateProxyHead_V1("Head", 1, 0);
				select RRM_Head_Top;
				RRM_CreateProxyLookAt_V1("Eye", 1, 3, 0, 1);
				move -r -os -wd 0 -1 0 RRM_l_Eye_Parent RRM_r_Eye_Parent;
				//LEGS
				select RRM_ROOT;
				RRM_CreateProxyLeg_V1("Leg", 0, 0, 0, 1, 1, 2);
			}
			else if ($RRM_TemplateType == 2)
			{//QUADRUPED
				move -r -os -wd 0 10 -7 RRM_ROOT;
				rotate -r 0 0 0 RRM_ROOT;
				select RRM_ROOT;
				RRM_CreateProxySpline_V1("Spine", 4, 2, 0);
				rotate -r -os 90 0 0 RRM_Spine_Parent;
				move -r -os -wd 0 4 0 RRM_Spine_Top;
				//HIND LEGS
				select RRM_ROOT;
				RRM_CreateProxyLeg_V1("HindLeg", 0, 0, 0, 2, 1, 2);
				//FRONT LEGS
				select RRM_Spine_Top;
				RRM_CreateProxyFKChain_V1("Clavicle", 1, 1, 1, 0, 1, 1);
				move -r -os -wd -3 0 0 RRM_l_Clavicle_01_01;
				move -r -os -wd -.5 0 0 RRM_l_Clavicle_Parent;
				select RRM_l_Clavicle_01_01;
				RRM_CreateProxyLeg_V1("FrontLeg", 0, 0, 0, 1, 1, 2);
				rotate -r -os -90 0 0 RRM_l_FrontLeg_Parent;
				move -r -os -wd -1 0 0 RRM_l_FrontLeg_Hip;
				//HEAD
				select RRM_Spine_Top;
				RRM_CreateProxySpline_V1("Neck", 2, 2, 0);
				rotate -r -90 0 0 RRM_Neck_Parent;
				move -r 0 -4 0 RRM_Neck_Top;
				select RRM_Neck_Top;
				RRM_CreateProxyHead_V1("Head", 1, 0);
				select RRM_Head_Top;
				RRM_CreateProxyLookAt_V1("Eye", 1, 3, 0, 1);
				move -r -os -wd 0 -1 0 RRM_l_Eye_Parent RRM_r_Eye_Parent;	
				RRM_TransferProxies_V1("left", 4);
			}
			else if ($RRM_TemplateType == 3)
			{//ARACHNID
				setAttr RRM_ROOT.ty 2;
				//FRONT LEG
				select RRM_ROOT;
				RRM_CreateProxyLeg_V1("FrontLeg", 0, 0, 0, 2, 1, 2);
				setAttr ("RRM_l_FrontLeg_Parent.translate", 0.625, 0, 1.1);
				setAttr ("RRM_l_FrontLeg_Hip.translate", -1.48, 1, -0.04);
				setAttr "RRM_l_FrontLeg_Hip.ry" 37;
				setAttr ("RRM_l_FrontLeg_Ground.translate", 9.45, 0, 11.8);
				setAttr ("RRM_l_FrontLeg_Ground.scale", 0.275, 0.275, 0.275);
				setAttr ("RRM_l_FrontLeg_Ankle.translate",  -1.96, 1.86, -0.1);
				setAttr ("RRM_l_FrontLeg_Ankle.rotate", 45, 58.7, 0);
				setAttr "RRM_l_FrontLeg_FootLeftTilt.tx" -0.5;
				setAttr "RRM_l_FrontLeg_FootRightTilt.tx" 0.5;
				setAttr "RRM_l_FrontLeg_HeelPivot.tz" 2.5;
				setAttr "RRM_l_FrontLeg_Toe.tz" -1;
				setAttr ("RRM_l_FrontLeg_Knee2.translate", 0, -1.95, 3.15);
				setAttr ("RRM_l_FrontLeg_Knee1.translate", 0, 1.6, 3.75);
				//MIDFRONT LEG
				select RRM_ROOT;
				RRM_CreateProxyLeg_V1("MidFrontLeg", 0, 0, 0, 2, 1, 2);
				setAttr ("RRM_l_MidFrontLeg_Parent.translate", 0.86, 0, 0.36);
				setAttr ("RRM_l_MidFrontLeg_Hip.translate", -1.48, 1, -0.04);
				setAttr "RRM_l_MidFrontLeg_Hip.ry" 60;
				setAttr ("RRM_l_MidFrontLeg_Ground.translate", 13.706, 0, 7.152);
				setAttr ("RRM_l_MidFrontLeg_Ground.scale", 0.275, 0.275, 0.275);
				setAttr ("RRM_l_MidFrontLeg_Ankle.translate", -2.9, 1.8, 0.8);
				setAttr ("RRM_l_MidFrontLeg_Ankle.rotate", 46, 37.6, 0);
				setAttr "RRM_l_MidFrontLeg_FootLeftTilt.tx" -0.5;
				setAttr "RRM_l_MidFrontLeg_FootRightTilt.tx" 0.5;
				setAttr "RRM_l_MidFrontLeg_HeelPivot.tz" 2.5;
				setAttr "RRM_l_MidFrontLeg_Toe.tz" -1;
				setAttr ("RRM_l_MidFrontLeg_Knee2.translate", 0, -1.95, 3.15);
				setAttr ("RRM_l_MidFrontLeg_Knee1.translate", 0, 1.6, 3.75);
				//MID BACK LEG
				select RRM_ROOT;
				RRM_CreateProxyLeg_V1("MidBackLeg", 0, 0, 0, 2, 1, 2);
				setAttr ("RRM_l_MidBackLeg_Parent.translate", 0.91, 0, -.431);
				setAttr ("RRM_l_MidBackLeg_Hip.translate", -1.48, 1, -0.04);
				setAttr "RRM_l_MidBackLeg_Hip.ry" 99.25;
				setAttr ("RRM_l_MidBackLeg_Ground.translate", 15.47, 0, -3.2);
				setAttr ("RRM_l_MidBackLeg_Ground.scale", 0.275, 0.275, 0.275);
				setAttr ("RRM_l_MidBackLeg_Ankle.translate", -3.3, 1.85, 3);
				setAttr ("RRM_l_MidBackLeg_Ankle.rotate", -5.55, 5.57, -45);
				setAttr "RRM_l_MidBackLeg_FootLeftTilt.tx" -0.5;
				setAttr "RRM_l_MidBackLeg_FootRightTilt.tx" 0.5;
				setAttr "RRM_l_MidBackLeg_HeelPivot.tz" 2.5;
				setAttr "RRM_l_MidBackLeg_Toe.tz" -1;
				setAttr ("RRM_l_MidBackLeg_Knee2.translate", 0, -1.95, 3.15);
				setAttr ("RRM_l_MidBackLeg_Knee1.translate", 0, 1.6, 3.75);
				//BACK LEG
				select RRM_ROOT;
				RRM_CreateProxyLeg_V1("BackLeg", 0, 0, 0, 2, 1, 2);
				setAttr ("RRM_l_BackLeg_Parent.translate", 0.493, 0, -1.112);
				setAttr ("RRM_l_BackLeg_Hip.translate", -1.48, 1, -0.04);
				setAttr "RRM_l_BackLeg_Hip.ry" 152.5;
				setAttr ("RRM_l_BackLeg_Ground.translate", 7.25, 0, -14.65);
				setAttr ("RRM_l_BackLeg_Ground.scale", 0.275, 0.275, 0.275);
				setAttr ("RRM_l_BackLeg_Ankle.translate", -1.49, 1.85, 5.6);
				setAttr ("RRM_l_BackLeg_Ankle.rotate", -57.74, 40.14, -67.9);
				setAttr "RRM_l_BackLeg_FootLeftTilt.tx" -0.5;
				setAttr "RRM_l_BackLeg_FootRightTilt.tx" 0.5;
				setAttr "RRM_l_BackLeg_HeelPivot.tz" 2.5;
				setAttr "RRM_l_BackLeg_Toe.tz" -1;
				setAttr ("RRM_l_BackLeg_Knee2.translate", 0, -1.95, 3.15);
				setAttr ("RRM_l_BackLeg_Knee1.translate", 0, 1.6, 3.75);
				//ABDOMEN
				select RRM_ROOT;
				RRM_CreateProxyFKChain_V1("Abdomen", 1, 5, 0, 3, 0, 1);
				setAttr "RRM_Abdomen_Parent.tz" -0.73;
				setAttr ("RRM_Abdomen_Parent.scale", 0.76, 0.76, 0.76);
				setAttr ("RRM_Abdomen_01_01.translate", -2.44, 0.1, 0);
				setAttr "RRM_Abdomen_01_01.rz" 26.7;
				setAttr "RRM_Abdomen_01_02.rz" -9.45;
				setAttr "RRM_Abdomen_01_03.rz" -9.45;
				setAttr "RRM_Abdomen_01_04.rz" -9.45;
				setAttr "RRM_Abdomen_01_05.rz" -9.45;
				//EYES
				select RRM_ROOT;
				RRM_CreateProxyLookAt_V1("Eye", 1, 3, 0, 1);
				setAttr ("RRM_l_Eye_Parent.scale", 0.6, 0.6, 0.6);
				setAttr ("RRM_l_Eye_Parent.translate", 0.41, 0.77, 0.84);
				setAttr "RRM_l_Eye_01.tz" -.315;
				//PEDIPALPS
				select RRM_ROOT;
				RRM_CreateProxyFKChain_V1("Pedipalp", 1, 6, 0, 0, 1, 1);
				setAttr ("RRM_l_Pedipalp_Parent.translate", 0.72, -.025, 1.27);
				setAttr "RRM_l_Pedipalp_Parent.ry" 22;
				setAttr ("RRM_l_Pedipalp_Parent.scale", 0.6, 0.6, 0.6);
				setAttr "RRM_l_Pedipalp_01_01.tx" -2.869;
				setAttr ("RRM_l_Pedipalp_01_02.translate", -0.637, 0, 0);
				setAttr "RRM_l_Pedipalp_01_02.rz" -3.225;
				setAttr ("RRM_l_Pedipalp_01_03.translate", -0.4, -0.05, 0);
				setAttr ("RRM_l_Pedipalp_01_03.rotate", 0, -5, -6);
				setAttr ("RRM_l_Pedipalp_01_04.translate", -0.125, -0.67, 0);
				setAttr "RRM_l_Pedipalp_01_04.rz" -42;
				setAttr ("RRM_l_Pedipalp_01_05.translate", -0.46, -0.2, 0);
				setAttr "RRM_l_Pedipalp_01_05.rz" -37;
				setAttr ("RRM_l_Pedipalp_01_06.translate", -0.25, -0.17, 0);
				setAttr "RRM_l_Pedipalp_01_06.rz" -15;
				//CHELICERAE
				select RRM_ROOT;
				RRM_CreateProxyFKChain_V1("Chelicera", 1, 3, 0, 0, 1, 1);
				setAttr ("RRM_l_Chelicera_Parent.translate", 0.33, -0.13, 1.5);
				setAttr ("RRM_l_Chelicera_Parent.scale", 0.4, 0.4, 0.4);
				setAttr "RRM_l_Chelicera_01_01.tx" -2.34;
				setAttr "RRM_l_Chelicera_01_01.rz" -70;
				setAttr ("RRM_l_Chelicera_01_02.translate", -0.15, -0.05, 0);
				setAttr "RRM_l_Chelicera_01_02.rz" -24;
				setAttr ("RRM_l_Chelicera_01_03.translate", -0.15, -0.24, 0.095);
				setAttr "RRM_l_Chelicera_01_03.rz" 9;
				RRM_TransferProxies_V1("left", 4);
			}
			else if ($RRM_TemplateType == 4)
			{//BIRD
				move -r -os -wd 0 10 -3 RRM_ROOT;
				rotate -r 90 0 0 RRM_ROOT;
				setAttr "RRM_ROOT.template_COG_Ctrl" 0;
				setAttr ("RRM_COG.translate", 0, 5, 0);
				setAttr ("RRM_COG.scale", 0.5, 0.5, 0.5);
				setAttr "RRM_ROOT.template_COG_Ctrl" 1;
				
				select RRM_ROOT;
				//LEGS
				RRM_CreateProxyLeg_V1("Leg", 0, 0, 0, 1, 1, 2);
				rotate -r -90 0 0 "RRM_l_Leg_Parent";
				move -r -os -wd 0 0.5 1 "RRM_l_Leg_Knee";
				move -r -os -wd 0 0.75 0 "RRM_l_Leg_Ankle";
				move -r -os -wd 0 0.5 -1.5 "RRM_l_Leg_Ball";
				move -r -os -wd 0 0 -2.5 "RRM_l_Leg_Toe";
				//TOES
				select "RRM_l_Leg_Toe";
				RRM_CreateProxyFKChain_V1("InnerToe", 1, 4, 3, 0, 1, 1);
				setAttr ("RRM_l_InnerToe_Parent.translate", -.45, 0.2, 0.4);
				setAttr ("RRM_l_InnerToe_Parent.rotate", 0, -25, 0);
				setAttr ("RRM_l_InnerToe_Parent.scale", 0.6, 0.6, 0.6);
				setAttr ("RRM_l_InnerToe_01_01.translate", -3, 0, 0);
				
				select "RRM_l_Leg_Toe";
				RRM_CreateProxyFKChain_V1("MiddleToe", 1, 5, 3, 0, 1, 1);
				setAttr ("RRM_l_MiddleToe_Parent.translate", 0, 0.2, 0.5);
				setAttr ("RRM_l_MiddleToe_Parent.scale", 0.5, 0.5, 0.5);
				setAttr ("RRM_l_MiddleToe_01_01.translate", -3, 0, 0);
				
				select "RRM_l_Leg_Toe";
				RRM_CreateProxyFKChain_V1("OuterToe", 1, 6, 3, 0, 1, 1);
				setAttr ("RRM_l_OuterToe_Parent.translate", .55, 0.2, 0.15);
				setAttr ("RRM_l_OuterToe_Parent.rotate", 0, 25, 0);
				setAttr ("RRM_l_OuterToe_Parent.scale", 0.5, 0.5, 0.5);
				setAttr ("RRM_l_OuterToe_01_01.translate", -3, 0, 0);

				select "RRM_l_Leg_Toe";
				RRM_CreateProxyFKChain_V1("HindToe", 1, 5, 0, 3, 1, 1);
				setAttr ("RRM_l_HindToe_Parent.translate", 0, 0.2, -0.5);
				setAttr ("RRM_l_HindToe_Parent.scale", 0.5, 0.5, 0.5);
				setAttr ("RRM_l_HindToe_01_01.translate", -2, 0, 0);

				//TAIL
				select RRM_ROOT;
				RRM_CreateProxyFKChain_V1("Tail", 1, 4, 0, 2, 0, 1);
				setAttr ("RRM_Tail_Parent.scale", 0.75, 0.75, 0.75);
				setAttr ("RRM_Tail_Parent.translate", 0, 2, 0);
				
				//SPINE
				select RRM_ROOT;
				RRM_CreateProxySpline_V1("Spine", 4, 2, 0);
				setAttr ("RRM_Spine_Top.translate", 0, -1, 0); 
				
				//WINGS
				select "RRM_Spine_Top";
				RRM_CreateProxyArm_V1("Wing", 0, 0, 0, 2, 1, 2);
				setAttr ("RRM_l_Wing_Parent.translate", 0, 0, 1.75);

				setAttr ("RRM_l_Wing_Clavicle.translate", -.85, 0, 0.6);
				
				setAttr ("RRM_l_Wing_Shoulder.translate", -1.5, 0, -2.5);
				setAttr ("RRM_l_Wing_Shoulder.rotate", 90, 0, 0);
				
				setAttr ("RRM_l_Wing_Shoulder.translate", -1.5, 0, -2.5);
				setAttr ("RRM_l_Wing_Shoulder.rotate", 90, 0, 0);
				
				setAttr ("RRM_l_Wing_Elbow1.translate", 0, 0, 0.1);
				setAttr ("RRM_l_Wing_Elbow2.translate", 0.6, 0, 0);
				
				setAttr ("RRM_l_Wing_Wrist.translate", -1.5, 0, -2.5);
				
				//DIGITS
				select "RRM_l_Wing_Elbow2";
				RRM_CreateProxyFKChain_V1("Alula", 1, 2, 1, 0, 1, 1);
				setAttr ("RRM_l_Alula_Parent.translate", 0.5, 0, -0.5);
				setAttr ("RRM_l_Alula_Parent.rotate", 90, 0, 0);
				setAttr ("RRM_l_Alula_Parent.scale", 0.5, 0.5, 0.5);
				
				setAttr ("RRM_l_Alula_01_01.translate", -3, 0, 0);
				
				select "RRM_l_Wing_Wrist";
				RRM_CreateProxyFKChain_V1("Digit", 1, 2, 1, 0, 1, 1);
				setAttr ("RRM_l_Digit_01_01.translate", -2.5, 0, 0);
				
				//NECK
				select "RRM_Spine_Top";
				RRM_CreateProxySpline_V1("Neck", 6, 2, 0);
				setAttr ("RRM_Neck_Top.translate", 0, -5.5, -5.5);
				setAttr ("RRM_Neck_Top.rotate", -90, 0, 0);
				
				setAttr ("RRM_Neck_01.translate", 0, 0.845, 0.563);
				setAttr ("RRM_Neck_01.rotate", -20, 0, 0);

				setAttr ("RRM_Neck_02.translate", 0, 1.314, 0.77);
				setAttr ("RRM_Neck_02.rotate", -57, 0, 0);

				setAttr ("RRM_Neck_03.translate", 0, 1.352, 0.582);
				setAttr ("RRM_Neck_03.rotate", -90, 0, 0);

				setAttr ("RRM_Neck_04.translate", 0, 1.014, 0.376);
				setAttr ("RRM_Neck_04.rotate", -100, 0, 0);

				setAttr ("RRM_Neck_05.translate", 0, 0.563, 0.207);
				setAttr ("RRM_Neck_05.rotate", -101, 0, 0);

				setAttr ("RRM_Neck_06.translate", 0, 0.225, 0.075);
				setAttr ("RRM_Neck_06.rotate", -90, 0, 0);
				
				//HEAD
				select "RRM_Neck_Top";
				RRM_CreateProxyHead_V1("Head", 1, 0);
				setAttr ("RRM_Head_Top.translate", 0, 2, 0);
				setAttr ("RRM_Head_Jaw.translate", 0, 0.5, 0.4);
				setAttr ("RRM_Head_JawEnd.translate", 0, 0, 2.5);
				setAttr ("RRM_Head_JawEnd.rotate", 90, 0, 0);
				
				select "RRM_Head_Top";
				RRM_CreateProxyLookAt_V1("Eye", 1, 1, 0, 1);
				setAttr ("RRM_l_Eye_Parent.translate", 0.2, -0.6, 1);
				setAttr ("RRM_l_Eye_Parent.scale", 0.75, 0.75, 0.75);
				setAttr ("RRM_l_Eye_01.translate", -1, 0, 0);

				RRM_TransferProxies_V1("left", 4);
			}
		}
		
		//if ($crntUnit == "m")
		//{
		//	setAttr ("RRM_MAIN.scale", 10,10,10);
		//}
    	
		$modNodes = `ls RRM_ROOT RRM_MAIN`;
		RRM_ProxyLockNodes_V1($modNodes);
		select RRM_ROOT;
    	
		//REVERT UNITS
		//if ($crntUnit != "cm")
		//{
		//	//changeLinearUnit "centimeter"
		//}
		//changeLinearUnit $crntUnit;
	}
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;	
}

//ATTACH TO RIG
global proc RRM_AttachToRig_V1(string $attachMod, string $modName, string $prfx, string $crntSide, string $oppSide, string $attachModCore, int $mirrorMod, int $mirrorCheck)
{

	if ($mirrorMod == $mirrorCheck)
	{
		if (`objExists ($attachMod + ".pair")`)
		{
			string $side = `getAttr ($attachMod + ".pair")`;
			if ($side == $crntSide)
			{
				parentConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
				scaleConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
				setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_MAINW1") 0;
				setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_MAINW1") 0;
				
				//ADD ATTACH NODE NAME
				if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
				{
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.attachNode") $attachModCore;
					setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.attachNode");
				}
				else if (`objExists ("RRM_" + $prfx + $modName + "_Aux.modType")`)
				{
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.attachNode") $attachModCore;
					setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.attachNode");
				}
			}
			else if ($side == $oppSide)
			{
				$sideCheck = `getAttr ($attachMod + ".opposite")`;
				parentConstraint ("RRM_" + $sideCheck) "RRM_MAIN" ("RRM_" + $prfx + $modName);
				scaleConstraint ("RRM_" + $sideCheck) "RRM_MAIN" ("RRM_" + $prfx + $modName);
				setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_MAINW1") 0;
				setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_MAINW1") 0;

				//ADD ATTACH NODE NAME
				if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
				{
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.attachNode") $sideCheck;
					setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.attachNode");
				}
				else if (`objExists ("RRM_" + $prfx + $modName + "_Aux.modType")`)
				{
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.attachNode") $sideCheck;
					setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.attachNode");
				}
			}
		}
		else
		{
			parentConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
			scaleConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
			setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_MAINW1") 0;
			setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_MAINW1") 0;			

			//ADD ATTACH NODE NAME
			if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
			{
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.attachNode") $attachModCore;
				setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.attachNode");
			}
			else if (`objExists ("RRM_" + $prfx + $modName + "_Aux.modType")`)
			{
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.attachNode") $attachModCore;
				setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.attachNode");
			}
		}
	
	}
	else
	{
		parentConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
		scaleConstraint $attachMod "RRM_MAIN" ("RRM_" + $prfx + $modName);
		setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_MAINW1") 0;
		setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_MAINW1") 0;

		//ADD ATTACH NODE NAME
		if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.attachNode") $attachModCore;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.attachNode");
		}
		else if (`objExists ("RRM_" + $prfx + $modName + "_Aux.modType")`)
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.attachNode") $attachModCore;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.attachNode");
		}
	}

	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//changeLinearUnit $crntUnit;	
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////SPLINE////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxySpline_V12_V1(string $modName, int $mirrorMod, string $prfx, string $oppPrfx, int $splineNum, int $twistAxis, string $crntUnit)
{
	$i1 = 1;
	$i2 = $splineNum;
	string $nPd = "_0";
	string $nPdPrev = "_0";

	while ($i1 <= $splineNum)
	{
		if ($i1 >= 10)
		{$nPd = "_";}
		if ($i1 >= 11)
		{$nPdPrev = "_";}
	
		//SET SPLINE NUM IN PARENT NODE
		lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.splineNum");
		setAttr ("RRM_" + $prfx + $modName + "_Parent.splineNum") $splineNum;
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.splineNum");
		
		//SET TWIST AXIS IN PARENT NODE
		//lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");
		if (!`objExists ("RRM_" + $prfx + $modName + "_Parent.twistAxis")`)
		{
			addAttr -ln "twistAxis"  -at "enum" -en "X-axis:Y-axis:" -k 1 ("RRM_" + $prfx + $modName + "_Parent");
		}
		setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.twistAxis");
		setAttr ("RRM_" + $prfx + $modName + "_Parent.twistAxis") $twistAxis;
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.twistAxis");
		
		//SET SPLINE NUM IN TOP NODE
		lockNode -lock off ("RRM_" + $modName);
		setAttr -l false ("RRM_" + $modName + ".jointsNum");
		setAttr ("RRM_" + $modName + ".jointsNum") $splineNum;
		setAttr -l true ("RRM_" + $modName + ".jointsNum");
		
		//SET TWIST AXIS IN TOP NODE
		if (!`objExists ("RRM_" + $modName + ".twistAxis")`)
		{
			addAttr -ln "twistAxis"  -at "enum" -en "X-axis:Y-axis:" ("RRM_" + $modName);
		}
		setAttr -l false ("RRM_" + $modName + ".twistAxis");
		setAttr ("RRM_" + $modName + ".twistAxis") $twistAxis;
		setAttr -l true ("RRM_" + $modName + ".twistAxis");
		
		RRM_CreateProxyModuleProxy_V1($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + $nPd + $i1);
		group -n ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp") ("RRM_" + $prfx + $modName + $nPd + $i1); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $i1 + ".core") ($prfx + $modName + $nPd + $i1);
		setAttr -l true ("RRM_" + $prfx + $modName + $nPd + $i1 + ".core");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $i1 + ".ext") ($nPd + $i1);
		setAttr -l true ("RRM_" + $prfx + $modName + $nPd + $i1 + ".ext");

		if ($mirrorMod == 1)
		{
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + $nPd + $i1);
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + $nPd + $i1 + ".opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $i1 + ".opposite") ($oppPrfx + $modName + $nPd + $i1);
			setAttr -l true ("RRM_" + $prfx + $modName + $nPd + $i1 + ".opposite");
		}
	
		pointConstraint ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Top")  ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp");
		setAttr ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_ParentW0") $i2;
		setAttr ("RRM_" + $prfx + $modName + $nPd + $i1 + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_TopW1") $i1;		
		setAttr ("RRM_" + $prfx + $modName + $nPd + $i1 + ".overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + $nPd + $i1 + ".overrideColor") 29;
		
		//CONNECTORS
		int $prev = ($i1 -1);
		if ($i1 == 1){
			RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + $nPd + $i1));
		}
		else {
			RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + $nPdPrev + $prev), ("RRM_" + $prfx + $modName + $nPd + $i1));
		}
		if ($i1 == $splineNum){
			RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + $nPd + $i1), ("RRM_" + $prfx + $modName + "_Top"));
		}
		$i1++;
		$i2--;
		
	}
}
		
global proc RRM_CreateProxySpline_V1(string $modName, int $splineNum, int $twistAxis, int $mirrorMod)
{
	string $crntUnit = `currentUnit -query -linear`;

	//CONVERT RADIO BUTTON TO ENUM VALUE
	$twistAxis = ($twistAxis - 1);

	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;

	$i = 0;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 0)
		{
			$prfx = "";
			$posOffset = 0;
		}
		
		if (`objExists ($attachMod[0] + (".opposite"))`)
		{
			$posOffset = 0;
		}
		
		//CREATE JOINT BASE
		RRM_CreateProxyParentProxy_V1($crntUnit);
		rename RRM_Parent ("RRM_" + $prfx + $modName + "_Parent");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;
		move -r $posOffset 0 0 ("RRM_" + $prfx + $modName + "_Parent");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "spline";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");
		
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideColor") 29;
		
		//ADD SPINE NUMBERS TO PARENT
		addAttr -ln "splineNum"  -at long -dv 1 ("RRM_" + $prfx + $modName + "_Parent");
		//ADD TWIST AXIS TO PARENT
		addAttr -ln "twistAxis"  -at "enum" -en "X-axis:Y-axis:" -k 1 ("RRM_" + $prfx + $modName + "_Parent");

		
		RRM_CreateProxyEndProxy_V1($crntUnit);
		rename RRM_End ("RRM_" + $prfx + $modName + "_Top");
		parent ("RRM_" + $prfx + $modName + "_Top") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Top");
		move -r 0 7 0 ("RRM_" + $prfx + $modName + "_Top");
		makeIdentity -apply true -t 1 ("RRM_" + $prfx + $modName + "_Top");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.core") ($prfx + $modName + "_Top");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Top.core");
			
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.ext") ("_Top");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Top.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Top.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Top.overrideColor") 29;
	
		if ($mirrorMod == 1)
		{
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Parent.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.opposite");
	
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Top");
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Top.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.opposite") ($oppPrfx + $modName + "_Top");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Top.opposite");

			//ADD EXTRA ATTRIBUTES
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
				addAttr -ln "pair"  -dt "string" ("RRM_" + $modName);
				setAttr -e-keyable 1 ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");
			}
			else
			{
				parent  ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
			}
		}	
	
		//ADD SPINE NUMBERS TO TOP GROUP
		if ($i == 0)
		{
			addAttr -ln "jointsNum"  -at long -dv 1 ("RRM_" + $modName);
			addAttr -ln "twistAxis"  -at "enum" -en "X-axis:Y-axis:" ("RRM_" + $modName);
		}

		RRM_CreateProxySpline_V12_V1($modName, $mirrorMod, $prfx, $oppPrfx, $splineNum, $twistAxis, $crntUnit);
	
		//ADD EXTRA ATTRIBUTES
		if ($mirrorMod == 1)
		{
			select ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Top")
			("RRM_" + $prfx + $modName + "_??");
			
			$RRM_Splines = `ls -sl`;
			string $crntMod;
			for ($crntMod in $RRM_Splines)
			{
				//PAIR AND TYPE
				addAttr -ln "pair"  -dt "string"  $crntMod;
				setAttr -e-keyable 1 ($crntMod + ".pair");
				setAttr -type "string" ($crntMod + ".pair") $crntSide;
				setAttr -l true ($crntMod + ".pair");
			}
		}
			

		//ATTACH TO RIG
		int $mirrorCheck = 1;
		RRM_AttachToRig_V1($attachMod[0], $modName, $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);
	
		select ("RRM_" + $prfx + $modName + "_*Grp");
		select -d ("RRM_" + $prfx + $modName + "_ConnectorGrp");
		$modGroups = `ls-sl`;
		string $selectedModGroup;
		for ($selectedModGroup in $modGroups)
		{
		setAttr -lock 1 -keyable 0 ($selectedModGroup + ".tx");
		setAttr -lock 1 -keyable 0 ($selectedModGroup + ".ty");
		setAttr -lock 1 -keyable 0 ($selectedModGroup + ".tz");
		setAttr -lock 1 -keyable 0 ($selectedModGroup + ".rx");
		setAttr -lock 1 -keyable 0 ($selectedModGroup + ".ry");
		setAttr -lock 1 -keyable 0 ($selectedModGroup + ".rz");
		setAttr -lock 1 -keyable 0 ($selectedModGroup + ".sx");
		setAttr -lock 1 -keyable 0 ($selectedModGroup + ".sy");
		setAttr -lock 1 -keyable 0 ($selectedModGroup + ".sz");
		setAttr -lock 1 -keyable 0 ($selectedModGroup + ".v");
		setAttr -lock 1 -keyable 0 ($selectedModGroup + "_pointConstraint1.nds");
		setAttr -lock 1 -keyable 0 ($selectedModGroup + "_pointConstraint1.ox");
		setAttr -lock 1 -keyable 0 ($selectedModGroup + "_pointConstraint1.oy");
		setAttr -lock 1 -keyable 0 ($selectedModGroup + "_pointConstraint1.oz");
		setAttr -lock 1 -keyable 0 ($selectedModGroup + "_pointConstraint1.w0");
		setAttr -lock 1 -keyable 0 ($selectedModGroup + "_pointConstraint1.w1");
		}

		if (!`objExists ("RRM_" + $modName + ".top")`)
		{
			//ADD TOP ATTRIBUTE
			addAttr -ln "top"  -dt "string" ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".top");
			setAttr -type "string" ("RRM_" + $modName + ".top") "spline";
			setAttr -l true ("RRM_" + $modName + ".top");
			
			//ADD PARENT ATTRIBUTE
			$parentCore = `getAttr ($attachMod[0] + ".core")`;
			addAttr -ln "parent"  -dt "string"  ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".parent");
			setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
			setAttr -l true ("RRM_" + $modName + ".parent");
			
			//ADD CORE NAME ATTRIBUTE
			addAttr -ln "core"  -dt "string"  ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".core");
			setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
			setAttr -l true ("RRM_" + $modName + ".core");


			parent ("RRM_" + $modName) $attachMod[0];
		}
		select ("RRM_" + $prfx + $modName + "_Parent");
		
		//PARENT CONNECTOR
		RRM_ProxyConnectors_V1($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
	}

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}
		
	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	
	RRM_ProxyLimits_V1($xforms);
	
	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes_V1($modNodes);
		
	select -cl;
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

global proc RRM_SplinePrompts_V1_V1(string $modName, int $splineNum, int $twistAxis, int $mirrorMod)
{
	if (`size $modName` == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName_V1($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid modName must begin with a letter.\n    The rest of the modName may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text RRM_TextFieldSplineName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "A module already exists with this name. Please use a unique modName\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			if (`size $attachMod` == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`size $attachMod` > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						RRM_CreateProxySpline_V1($modName, $splineNum, $twistAxis, $mirrorMod);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					RRM_CreateProxySpline_V1($modName, $splineNum, $twistAxis, $mirrorMod);
				}
			}
		}
	}
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////ARMS////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyArm2_V1(string $modName, int $upperArmNum, int $lowerArmNum, int $elbowNum, int $elbowJoints, int $toon, int $mirrorMod, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, int $multiplier, string $crntUnit)
{
	//SET ARM NUM'S IN PARENT NODE
	lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.upperRollNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.upperRollNum") $upperArmNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.upperRollNum");
	

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.lowerRollNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.lowerRollNum") $lowerArmNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.lowerRollNum");
	

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.elbowNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.elbowNum") $elbowJoints;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.elbowNum");
	

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.midRollNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.midRollNum") $elbowNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.midRollNum");
	
	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.toonArms");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.toonArms") $toon;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.toonArms");
	
	
	
	//ELBOW
	if ($elbowJoints == 1)
	{
		RRM_CreateProxyModuleProxy_V1($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Elbow");
		curve -n ("RRM_" + $prfx + $modName + "_ElbowAim") -d 1 -p -0.25 0 0 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 0-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_ElbowAim")` ("RRM_" + $prfx + $modName + "_ElbowAimShape");
		parent -r -s ("RRM_" + $prfx + $modName + "_ElbowAimShape") ("RRM_" + $prfx + $modName + "_Elbow");
		delete ("RRM_" + $prfx + $modName + "_ElbowAim");
		group -n ("RRM_" + $prfx + $modName + "_ElbowGrp") ("RRM_" + $prfx + $modName + "_Elbow"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_ElbowGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ElbowGrp");		
		move -r ($multiplier * 6.45) 0 0 ("RRM_" + $prfx + $modName + "_ElbowGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ElbowGrp");	
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow.core") ($prfx + $modName + "_Elbow");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow.core");
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow.ext") ("_Elbow");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow.ext");
	
		setAttr ("RRM_" + $prfx + $modName + "_Elbow.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Elbow.overrideColor") 7;
	}
	else
	{
		RRM_CreateProxyModuleProxy_V1($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Elbow1");
		curve -n ("RRM_" + $prfx + $modName + "_Elbow1Aim") -d 1 -p -0.25 0 0 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 0-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_Elbow1Aim")` ("RRM_" + $prfx + $modName + "_Elbow1AimShape");
		parent -r -s ("RRM_" + $prfx + $modName + "_Elbow1AimShape") ("RRM_" + $prfx + $modName + "_Elbow1");
		delete ("RRM_" + $prfx + $modName + "_Elbow1Aim");
		group -n ("RRM_" + $prfx + $modName + "_Elbow1Grp") ("RRM_" + $prfx + $modName + "_Elbow1"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_Elbow1Grp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Elbow1Grp");		
		move -r ($multiplier * 6.45) 0 0 ("RRM_" + $prfx + $modName + "_Elbow1Grp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Elbow1Grp");	
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow1.core") ($prfx + $modName + "_Elbow1");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow1.core");
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow1.ext") ("_Elbow1");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow1.ext");
	
		setAttr ("RRM_" + $prfx + $modName + "_Elbow1.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Elbow1.overrideColor") 7;
		
		RRM_CreateProxyModuleProxy_V1($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Elbow2");
		makeIdentity -apply true -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Elbow2");
		curve -n ("RRM_" + $prfx + $modName + "_Elbow2Aim") -d 1 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 1 -p 0.5 0 1 -p 0 0 1.5 -p -0.5 0 1 -p -0.25 0 1 -p -0.25 0 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_Elbow2Aim")` ("RRM_" + $prfx + $modName + "_Elbow2AimShape");
		rotate -r 0 0 ($multiplier * 90) ("RRM_" + $prfx + $modName + "_Elbow2Aim");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Elbow2Aim");
		parent -r -s ("RRM_" + $prfx + $modName + "_Elbow2AimShape") ("RRM_" + $prfx + $modName + "_Elbow2");
		delete ("RRM_" + $prfx + $modName + "_Elbow2Aim");
		group -n ("RRM_" + $prfx + $modName + "_Elbow2Grp") ("RRM_" + $prfx + $modName + "_Elbow2"); xform -os -piv 0 0 0;
		parent ("RRM_" + $prfx + $modName + "_Elbow2Grp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Elbow2Grp");
        
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow2.core") ($prfx + $modName + "_Elbow2");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow2.core");
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow2.ext") ("_Elbow2");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Elbow2.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Elbow2.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Elbow2.overrideColor") 7;
	}
	
	//ARM CONSTRAINTS
	if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
	{
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_ElbowGrp");
		setAttr ("RRM_" + $prfx + $modName + "_ElbowGrp_pointConstraint1.offsetZ") -.0001;
		spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		group -n ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp") ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		parent ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp") ("RRM_" + $prfx + $modName + "_AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_AimLctr");
	
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp");
		aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_AimLctr");
		parent ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Shoulder");
		orientConstraint ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_ElbowGrp");
		
		pointConstraint -skip y -skip z ("RRM_" + $prfx + $modName + "_Elbow") ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector -1 0 0 -worldUpType "objectrotation" -worldUpObject ("RRM_" + $prfx + $modName + "_AimLctr") -worldUpVector -1 0 0
		-skip y -skip z ("RRM_" + $prfx + $modName + "_ElbowAimLctr") ("RRM_" + $prfx + $modName + "_Elbow");
		
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Clavicle"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Clavicle"), ("RRM_" + $prfx + $modName + "_Shoulder"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Shoulder"), ("RRM_" + $prfx + $modName + "_Elbow"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Elbow"), ("RRM_" + $prfx + $modName + "_Wrist"));
	}
	else
	{
		//CONNECT ELBOW 2
		aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "none" -skip x ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_Elbow2");
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_Elbow2Grp");
		setAttr ("RRM_" + $prfx + $modName + "_Elbow2Grp_pointConstraint1." + "RRM_" + $prfx + $modName + "_WristW1") 2;
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Elbow2AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Elbow2AimLctr");
    
		aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_Elbow2AimLctr");
		parent ("RRM_" + $prfx + $modName + "_Elbow2AimLctr") ("RRM_" + $prfx + $modName + "_Shoulder");
		orientConstraint ("RRM_" + $prfx + $modName + "_Elbow2AimLctr") ("RRM_" + $prfx + $modName + "_Elbow2Grp");
		setAttr ("RRM_" + $prfx + $modName + "_Elbow2AimLctr.v") 0;
        
		//CONNECT ELBOW 1
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Elbow2") ("RRM_" + $prfx + $modName + "_Elbow1Grp");
		setAttr ("RRM_" + $prfx + $modName + "_Elbow1Grp_pointConstraint1.offsetZ") -.0001;
		spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		group -n ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp") ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		parent ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp") ("RRM_" + $prfx + $modName + "_AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_AimLctr");
	
		pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Elbow2") ("RRM_" + $prfx + $modName + "_ElbowAimLctrGrp");
		aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Elbow2") ("RRM_" + $prfx + $modName + "_AimLctr");
		parent ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Shoulder");
		orientConstraint ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Elbow1Grp");
		
		pointConstraint -skip y -skip z ("RRM_" + $prfx + $modName + "_Elbow1") ("RRM_" + $prfx + $modName + "_ElbowAimLctr");
		aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 1 0 0 -worldUpType "objectrotation" -worldUpObject ("RRM_" + $prfx + $modName + "_AimLctr") -worldUpVector 1 0 0
		-skip y -skip z ("RRM_" + $prfx + $modName + "_ElbowAimLctr") ("RRM_" + $prfx + $modName + "_Elbow1");

		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Clavicle"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Clavicle"), ("RRM_" + $prfx + $modName + "_Shoulder"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Shoulder"), ("RRM_" + $prfx + $modName + "_Elbow1"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Elbow1"), ("RRM_" + $prfx + $modName + "_Elbow2"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Elbow2"), ("RRM_" + $prfx + $modName + "_Wrist"));
	}	
	
	//UPPER ARM JOINTS
	if ($upperArmNum > 0)
	{
		$shoulderInf = $upperArmNum;
		$elbowInf = 1;
		$crntInt = 1;
		while ($crntInt <= $upperArmNum)
		{
			RRM_CreateProxyModuleProxy_V1($crntUnit);
			rename RRM_Base ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
			group -n ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
			parent ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Shoulder");
			scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".core") ($prfx + $modName + "_Upper" + $crntInt);
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ext") ("_Upper" + $crntInt);
			setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".core");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ext");
			if ($mirrorMod == 2)
			{
				addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".pair") ($crntSide);
				addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Upper" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".pair");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".opposite");
			}
			//SCALE LOCATOR
			setAttr (("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScale"), .125, .125, .125); 
			if ($crntUnit == "m")
			{
				setAttr (("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScale"), .00125, .00125, .00125);
			}
			
			connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".template");

			if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Elbow") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_ShoulderW0") $shoulderInf;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_ElbowW1") $elbowInf;
			}
			else
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Elbow1") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_ShoulderW0") $shoulderInf;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Elbow1W1") $elbowInf;
			}

			//LOCK ATTRIBUTES
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".rx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ry");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".rz");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sy");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sz");

			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.tx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.ty");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.tz");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.rx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.ry");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.rz");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sy");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sz");

			$shoulderInf--;
			$elbowInf++;
			$crntInt++;
		}
	}
		
	//LOWER ARM JOINTS
	if ($lowerArmNum > 0)                                                         
	{
		$elbowInf = $lowerArmNum;
		$wristInf = 1;
		$crntInt = 1;
		while ($crntInt <= $lowerArmNum)
		{
			RRM_CreateProxyModuleProxy_V1($crntUnit);
			rename RRM_Base ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
			group -n ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
			parent ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Shoulder");
			scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".core") ($prfx + $modName + "_Lower" + $crntInt);
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ext") ("_Lower" + $crntInt);
			setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".core");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ext");
			if ($mirrorMod == 2)
			{
				addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".pair") ($crntSide);
				addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Lower" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".pair");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".opposite");
			}
			//SCALE LOCATOR
			setAttr (("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScale"), .125, .125, .125);
			if ($crntUnit == "m")
			{
				setAttr (("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScale"), .00125, .00125, .00125);
			}

			connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".template");

			if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Elbow") ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_ElbowW0") $elbowInf;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_WristW1") $wristInf;
			}
			else
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Elbow2") ("RRM_" + $prfx + $modName + "_Wrist") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Elbow2W0") $elbowInf;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_WristW1") $wristInf;
			}

			//LOCK ATTRIBUTES
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".rx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ry");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".rz");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sy");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sz");

			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.tx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.ty");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.tz");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.rx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.ry");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.rz");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sy");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sz");

			$elbowInf--;
			$wristInf++;
			$crntInt++;
		}
	}
	
	//ELBOW JOINTS
	if ($elbowJoints == 2)
	{
		if ($elbowNum > 0)
		{
			$elbow1Inf = $elbowNum;
			$elbow2Inf = 1;
			$crntInt = 1;
			while ($crntInt <= $elbowNum)
			{
				RRM_CreateProxyModuleProxy_V1($crntUnit);
				rename RRM_Base ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
				group -n ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
				parent ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Shoulder");
				scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");
				makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");

				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".core") ($prfx + $modName + "_Middle" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ext") ("_Middle" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".core");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ext");
				if ($mirrorMod == 2)
				{
					addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".pair") ($crntSide);
					addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Middle" + $crntInt);
					setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".pair");
					setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".opposite");
				}
				//SCALE LOCATOR
				setAttr (("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScale"), .125, .125, .125);
				if ($crntUnit == "m")
				{
					setAttr (("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScale"), .00125, .00125, .00125);
				}
				connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".template");
				
				pointConstraint ("RRM_" + $prfx + $modName + "_Elbow1") ("RRM_" + $prfx + $modName + "_Elbow2") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Elbow1W0") $elbow1Inf;
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Elbow2W1") $elbow2Inf;
				
				//LOCK ATTRIBUTES
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".rx");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ry");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".rz");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sx");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sy");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sz");

				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.tx");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.ty");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.tz");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.rx");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.ry");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.rz");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sx");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sy");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sz");
				
				$elbow1Inf--;
				$elbow2Inf++;
				$crntInt++;
			}
		}
	}
	
	//LOCK CHANNELS
	if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
	{
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow.rx");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow.ry");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow.rz");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow.sx");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow.sy");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow.sz");
	}
	else
	{
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow1.rx");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow1.ry");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow1.rz");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow1.sx");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow1.sy");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow1.sz");
    
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow2.ry");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow2.rz");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow2.sx");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow2.sy");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Elbow2.sz");
	}

	//ADD EXTRA ATTRIBUTES
	if ($mirrorMod == 2)
	{
		if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
		{
			select ("RRM_" + $prfx + $modName + "_Elbow");
		}
		else
		{
			select ("RRM_" + $prfx + $modName + "_Elbow1") ("RRM_" + $prfx + $modName + "_Elbow2");
		}
		
		$armMods = `ls -sl`;
		string $crntMod;
		for ($crntMod in $armMods)
		{
			//PAIR AND TYPE
			addAttr -ln "pair"  -dt "string"  $crntMod;
			setAttr -e-keyable 1 ($crntMod + ".pair");
			setAttr -type "string" ($crntMod + ".pair") $crntSide;
			setAttr -l true ($crntMod + ".pair");
			//OPPOSITE NAME
			addAttr -ln "opposite" -dt "string"  $crntMod;
			setAttr -e-keyable 1 ($crntMod + ".opposite");
		}
		if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow.opposite") ($oppPrfx + $modName + "_Elbow");
		}
		else
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow1.opposite") ($oppPrfx + $modName + "_Elbow1");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow2.opposite") ($oppPrfx + $modName + "_Elbow2");
		}
		
		for ($crntMod in $armMods)
		{
			setAttr -l true ($crntMod + ".opposite");
		}
	}

	setAttr ("RRM_" + $prfx + $modName + "_AimLctr.v")      0;
	setAttr ("RRM_" + $prfx + $modName + "_ElbowAimLctr.v") 0;
}

global proc RRM_CreateProxyArm_V1(string $modName, int $upperArmNum, int $lowerArmNum, int $elbowNum, int $elbowJoints, int $toon, int $mirrorMod)
{
	string $crntUnit = `currentUnit -query -linear`;


	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	$i = 0;
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;

	//ARM
	while ($i !=2)
	{	
		if ($mirrorMod != 2)
		{
			$prfx = "";
			$oppPrfx = "";
		}
		if ($mirrorMod == 3)
		{
			$crntSide = "right";
			$oppSide = "left"; 
			$multiplier = -1;
		}
			
			
		//ATTACH NODE
		RRM_CreateProxyParentProxy_V1($crntUnit);
		rename RRM_Parent ("RRM_" + $prfx + $modName + "_Parent");
		rotate -r 0 0 ($multiplier * -90) ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "arm";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");
	
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideColor") 7;
		
		addAttr -ln "upperRollNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "lowerRollNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "elbowNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "midRollNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		
		//TEMPLATE ROLL JOINTS
		addAttr -ln "templateRollJoints"  -at bool -dv 1 ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -e -keyable 1 ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints");
		
		//TOON ARMS
		addAttr -ln "toonArms"  -at bool -dv 1 ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -e -keyable 1 -l 1 ("RRM_" + $prfx + $modName + "_Parent.toonArms");
		
		//CLAVICLE		
		RRM_CreateProxyModuleProxy_V1($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Clavicle");
		group -n ("RRM_" + $prfx + $modName + "_ClavicleGrp") ("RRM_" + $prfx + $modName + "_Clavicle"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_ClavicleGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ClavicleGrp");
		move -r ($multiplier * 1.25) 0 0 ("RRM_" + $prfx + $modName + "_ClavicleGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ClavicleGrp");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Clavicle.core") ($prfx + $modName + "_Clavicle");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Clavicle.core");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Clavicle.ext") ("_Clavicle");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Clavicle.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Clavicle.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Clavicle.overrideColor") 7;
		
		//SHOULDER		
		RRM_CreateProxyModuleProxy_V1($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Shoulder");
		group -n ("RRM_" + $prfx + $modName + "_ShoulderGrp") ("RRM_" + $prfx + $modName + "_Shoulder"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_ShoulderGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ShoulderGrp");		
		move -r ($multiplier * 2.95) 0 0 ("RRM_" + $prfx + $modName + "_ShoulderGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_ShoulderGrp");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Shoulder.core") ($prfx + $modName + "_Shoulder");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Shoulder.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Shoulder.ext") ("_Shoulder");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Shoulder.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Shoulder.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Shoulder.overrideColor") 7;

		//WRIST
		RRM_CreateProxyEndProxy_V1($crntUnit);		
		rename RRM_End ("RRM_" + $prfx + $modName + "_Wrist");
		rotate -r 0 0 ($multiplier * -90) ("RRM_" + $prfx + $modName + "_Wrist");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Wrist");
		group -n ("RRM_" + $prfx + $modName + "_WristGrp") ("RRM_" + $prfx + $modName + "_Wrist"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_WristGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_WristGrp");		
		move -r ($multiplier * 9.95) 0 0 ("RRM_" + $prfx + $modName + "_WristGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_WristGrp");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Wrist.core") ($prfx + $modName + "_Wrist");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Wrist.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Wrist.ext") ("_Wrist");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Wrist.ext");

		setAttr ("RRM_" + $prfx + $modName + "_Wrist.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Wrist.overrideColor") 7;

		RRM_CreateProxyArm2_V1($modName, $upperArmNum, $lowerArmNum, $elbowNum, $elbowJoints, $toon, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit);

		//ADD EXTRA ATTRIBUTES
		if ($mirrorMod == 2)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
				addAttr -ln "pair"  -dt "string" ("RRM_" + $modName);
				setAttr -e-keyable 1 ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");
			}
			else
			{
				parent  ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
				
			}
			
			select ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Clavicle")
			("RRM_" + $prfx + $modName + "_Shoulder") ("RRM_" + $prfx + $modName + "_Wrist");
			
			$armMods = `ls -sl`;
			string $crntMod;
			for ($crntMod in $armMods)
			{
				//PAIR AND TYPE
				addAttr -ln "pair"  -dt "string"  $crntMod;
				setAttr -e-keyable 1 ($crntMod + ".pair");
				setAttr -type "string" ($crntMod + ".pair") $crntSide;
				setAttr -l true ($crntMod + ".pair");
				//OPPOSITE NAME
				addAttr -ln "opposite"  -dt "string"  $crntMod;
				setAttr -e-keyable 1 ($crntMod + ".opposite");
			}
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Clavicle.opposite") ($oppPrfx + $modName + "_Clavicle");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Shoulder.opposite") ($oppPrfx + $modName + "_Shoulder");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Wrist.opposite") ($oppPrfx + $modName + "_Wrist");
			
			for ($crntMod in $armMods)
			{
				setAttr -l true ($crntMod + ".opposite");
			}
		}
		else
		{
			//ADD LEFT OR RIGHT ATTRIBUTE
			addAttr -ln "single"  -dt "string" ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".single");
			setAttr -type "string" ("RRM_" + $modName + ".single") $crntSide;
			setAttr -l true ("RRM_" + $modName + ".single");
		}

		//ATTACH TO RIG
		int $mirrorCheck = 2;
		RRM_AttachToRig_V1($attachMod[0], $modName, $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);
	
		if (!`objExists ("RRM_" + $modName + ".top")`)
		{	
			//ADD TOP ATTRIBUTE
			addAttr -ln "top"  -dt "string"  ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".top");
			setAttr -type "string" ("RRM_" + $modName + ".top") "arm";
			setAttr -l true ("RRM_" + $modName + ".top");
			
			//ADD PARENT ATTRIBUTE
			$parentCore = `getAttr ($attachMod[0] + ".core")`;
			addAttr -ln "parent"  -dt "string"  ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".parent");
			setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
			setAttr -l true ("RRM_" + $modName + ".parent");

			//ADD CORE NAME ATTRIBUTE
			addAttr -ln "core"  -dt "string" ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".core");
			setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
			setAttr -l true ("RRM_" + $modName + ".core");
			
			//ADD UPPER ARM NUM ATTRIBUTE
			addAttr -ln "upperArmNum"  -at long ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".upperArmNum");
			setAttr ("RRM_" + $modName + ".upperArmNum") $upperArmNum;
			setAttr -l true ("RRM_" + $modName + ".upperArmNum");
			
			//ADD LOWER ARM NUM ATTRIBUTE
			addAttr -ln "lowerArmNum"  -at long ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".lowerArmNum");
			setAttr ("RRM_" + $modName + ".lowerArmNum") $lowerArmNum;
			setAttr -l true ("RRM_" + $modName + ".lowerArmNum");

			//ADD ELBOW NUM ATTRIBUTE
			addAttr -ln "elbowNum" -at long ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".elbowNum");
			setAttr ("RRM_" + $modName + ".elbowNum") $elbowNum;
			setAttr -l true ("RRM_" + $modName + ".elbowNum");

			//ADD UPPER ARM NUM ATTRIBUTE
			addAttr -ln "elbowJoints" -at long ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".elbowJoints");
			setAttr ("RRM_" + $modName + ".elbowJoints") $elbowJoints;
			setAttr -l true ("RRM_" + $modName + ".elbowJoints");
			
			//ADD TOON ARM ATTRIBUTE
			addAttr -ln "toonArms" -at long ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".toonArms");
			setAttr ("RRM_" + $modName + ".toonArms") $toon;
			setAttr -l true ("RRM_" + $modName + ".toonArms");
			
			
			parent ("RRM_" + $modName) $attachMod[0];
		}
		//PARENT CONNECTOR
		RRM_ProxyConnectors_V1($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	
		if ($mirrorMod != 2)
		{
			$i = 2;
		}
	}

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits_V1($xforms);

	$modNodes = `listRelatives ("RRM_" + $modName)`;
	RRM_ProxyLockNodes_V1($modNodes);

	select -cl;
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

global proc RRM_ArmPrompts_V1(string $modName, int $upperArmNum, int $lowerArmNum, int $elbowNum, int $elbowJoints, int $toon, int $mirrorMod)
{
	if (`size $modName` == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName_V1($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid modName must begin with a letter.\n    The rest of the modName may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text RRM_TextFieldArmName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this modName. Please use a unique modName\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			if (`size $attachMod` == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`size $attachMod` > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						RRM_CreateProxyArm_V1($modName, $upperArmNum, $lowerArmNum, $elbowNum, $elbowJoints, $toon, $mirrorMod);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					RRM_CreateProxyArm_V1($modName, $upperArmNum, $lowerArmNum, $elbowNum, $elbowJoints, $toon, $mirrorMod);
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////LEGS////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyLeg_V12_V1(string $modName, int $upperLegNum, int $lowerLegNum, int $kneeNum, int $kneeJoints, int $toon, int $mirrorMod, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, int $posOffset, string $crntUnit)
{
	//SET ARM NUM'S IN PARENT NODE
	lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.upperRollNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.upperRollNum") $upperLegNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.upperRollNum");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.lowerRollNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.lowerRollNum") $lowerLegNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.lowerRollNum");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.kneeNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.kneeNum") $kneeJoints;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.kneeNum");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.midRollNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.midRollNum") $kneeNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.midRollNum");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.toonLegs");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.toonLegs") $toon;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.toonLegs");

	//KNEE
	if ($kneeJoints == 1)
	{
		RRM_CreateProxyModuleProxy_V1($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Knee");
		curve -n ("RRM_" + $prfx + $modName + "_KneeAim") -d 1 -p -0.25 0 0 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 0-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_KneeAim")` ("RRM_" + $prfx + $modName + "_KneeAimShape");
		parent -r -s ("RRM_" + $prfx + $modName + "_KneeAimShape") ("RRM_" + $prfx + $modName + "_Knee");
		delete ("RRM_" + $prfx + $modName + "_KneeAim");
		group -n ("RRM_" + $prfx + $modName + "_KneeGrp") ("RRM_" + $prfx + $modName + "_Knee"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_KneeGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_KneeGrp");		
		rotate -r 0 -180 90 ("RRM_" + $prfx + $modName + "_Knee");
		move -r $posOffset -5 0 ("RRM_" + $prfx + $modName + "_KneeGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_KneeGrp");	
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee.core") ($prfx + $modName + "_Knee");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee.core");
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee.ext") ("_Knee");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee.ext");
	
		setAttr ("RRM_" + $prfx + $modName + "_Knee.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Knee.overrideColor") 31;
	}
	else
	{
		RRM_CreateProxyModuleProxy_V1($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Knee1");
		curve -n ("RRM_" + $prfx + $modName + "_Knee1Aim") -d 1 -p -0.25 0 0 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 0-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_Knee1Aim")` ("RRM_" + $prfx + $modName + "_Knee1AimShape");
		parent -r -s ("RRM_" + $prfx + $modName + "_Knee1AimShape") ("RRM_" + $prfx + $modName + "_Knee1");
		delete ("RRM_" + $prfx + $modName + "_Knee1Aim");
		group -n ("RRM_" + $prfx + $modName + "_Knee1Grp") ("RRM_" + $prfx + $modName + "_Knee1"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_Knee1Grp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Knee1Grp");		
		rotate -r 0 -180 90 ("RRM_" + $prfx + $modName + "_Knee1Grp");
		move -r $posOffset -5 0 ("RRM_" + $prfx + $modName + "_Knee1Grp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Knee1Grp");	
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee1.core") ($prfx + $modName + "_Knee1");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee1.core");
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee1.ext") ("_Knee1");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee1.ext");
	
		setAttr ("RRM_" + $prfx + $modName + "_Knee1.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Knee1.overrideColor") 31;
		
		RRM_CreateProxyModuleProxy_V1($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Knee2");
		makeIdentity -apply true -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Knee2");
		curve -n ("RRM_" + $prfx + $modName + "_Knee2Aim") -d 1 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 1 -p 0.5 0 1 -p 0 0 1.5 -p -0.5 0 1 -p -0.25 0 1 -p -0.25 0 -1 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_Knee2Aim")` ("RRM_" + $prfx + $modName + "_Knee2AimShape");
		move -r $posOffset -5 0 ("RRM_" + $prfx + $modName + "_Knee1Grp");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Knee2Aim");
		parent -r -s ("RRM_" + $prfx + $modName + "_Knee2AimShape") ("RRM_" + $prfx + $modName + "_Knee2");
		delete ("RRM_" + $prfx + $modName + "_Knee2Aim");
		group -n ("RRM_" + $prfx + $modName + "_Knee2Grp") ("RRM_" + $prfx + $modName + "_Knee2"); xform -os -piv 0 0 0;
		parent ("RRM_" + $prfx + $modName + "_Knee2Grp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Knee2Grp");
		
		setAttr ("RRM_" + $prfx + $modName + "_Knee2.rotateOrder") 1;
        
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee2.core") ($prfx + $modName + "_Knee2");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee2.core");
    
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee2.ext") ("_Knee2");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Knee2.ext");
        
		setAttr ("RRM_" + $prfx + $modName + "_Knee2.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Knee2.overrideColor") 31;
	}
	
	//LEG CONSTRAINTS
	if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
	{
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_KneeGrp");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		group -n ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp") ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		parent ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp") ("RRM_" + $prfx + $modName + "_AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_AimLctr");
	
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp");
		aimConstraint -offset 0 0 0 -aimVector 0 -1 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_AimLctr");
		parent ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Hip");
		orientConstraint ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_KneeGrp");
		
		pointConstraint -skip x -skip z ("RRM_" + $prfx + $modName + "_Knee") ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		aimConstraint -offset 0 0 0 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("RRM_" + $prfx + $modName + "_AimLctr") -worldUpVector 0 1 0
		-skip x -skip z ("RRM_" + $prfx + $modName + "_KneeAimLctr") ("RRM_" + $prfx + $modName + "_Knee");
		
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Hip"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Hip"), ("RRM_" + $prfx + $modName + "_Knee"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Knee"), ("RRM_" + $prfx + $modName + "_Ankle"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Ankle"), ("RRM_" + $prfx + $modName + "_Ball"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Ball"), ("RRM_" + $prfx + $modName + "_Toe"));
	}
	else
	{
		//CONNECT KNEE 2
		aimConstraint -offset 0 0 0 -aimVector 0 -1 0 -upVector 0 1 0 -worldUpType "none" -skip y ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Knee2");
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Knee2Grp");
		setAttr ("RRM_" + $prfx + $modName + "_Knee2Grp_pointConstraint1." + "RRM_" + $prfx + $modName + "_AnkleW1") 2;
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Knee2AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Knee2AimLctr");
    
		aimConstraint -offset 0 0 0 -aimVector 0 -1 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Knee2AimLctr");
		parent ("RRM_" + $prfx + $modName + "_Knee2AimLctr") ("RRM_" + $prfx + $modName + "_Hip");
		orientConstraint ("RRM_" + $prfx + $modName + "_Knee2AimLctr") ("RRM_" + $prfx + $modName + "_Knee2Grp");
		setAttr ("RRM_" + $prfx + $modName + "_Knee2AimLctr.v") 0;
        
		//CONNECT KNEE 1
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Knee2") ("RRM_" + $prfx + $modName + "_Knee1Grp");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
		spaceLocator -n ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		group -n ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp") ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		parent ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp") ("RRM_" + $prfx + $modName + "_AimLctr");
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_AimLctr");
	
		pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Knee2") ("RRM_" + $prfx + $modName + "_KneeAimLctrGrp");
		aimConstraint -offset 0 0 0 -aimVector 0 -1 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $modName + "_Knee2") ("RRM_" + $prfx + $modName + "_AimLctr");
		parent ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Hip");
		orientConstraint ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_Knee1Grp");
		
		pointConstraint -skip x -skip z ("RRM_" + $prfx + $modName + "_Knee1") ("RRM_" + $prfx + $modName + "_KneeAimLctr");
		aimConstraint -offset 0 0 0 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ("RRM_" + $prfx + $modName + "_AimLctr") -worldUpVector 0 1 0
		-skip x -skip z ("RRM_" + $prfx + $modName + "_KneeAimLctr") ("RRM_" + $prfx + $modName + "_Knee1");

		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Hip"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Hip"), ("RRM_" + $prfx + $modName + "_Knee1"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Knee1"), ("RRM_" + $prfx + $modName + "_Knee2"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Knee2"), ("RRM_" + $prfx + $modName + "_Ankle"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Ankle"), ("RRM_" + $prfx + $modName + "_Ball"));
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Ball"), ("RRM_" + $prfx + $modName + "_Toe"));
	}	
	
	//UPPER LEG JOINTS
	if ($upperLegNum > 0)
	{
		$shoulderInf = $upperLegNum;
		$kneeInf = 1;
		$crntInt = 1;
		while ($crntInt <= $upperLegNum)
		{
			RRM_CreateProxyModuleProxy_V1($crntUnit);
			rename RRM_Base ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
			group -n ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
			parent ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Hip");
			scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".core") ($prfx + $modName + "_Upper" + $crntInt);
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ext") ("_Upper" + $crntInt);
			setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".core");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ext");
			if ($mirrorMod == 2)
			{
				addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".pair") ($crntSide);
				addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Upper" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".pair");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".opposite");
			}
			//SCALE LOCATOR
			setAttr (("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScale"), .125, .125, .125);
			if ($crntUnit == "m")
			{
				setAttr (("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "DShape.localScale"), .00125, .00125, .00125);
			}

			connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".template");
			
			if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Knee") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_HipW0") $shoulderInf;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_KneeW1") $kneeInf;
			}
			else
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_Knee1") ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_HipW0") $shoulderInf;
				setAttr ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Knee1W1") $kneeInf;
			}
			//LOCK ATTRIBUTES
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".rx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".ry");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".rz");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sy");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + ".sz");

			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.tx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.ty");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.tz");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.rx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.ry");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.rz");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sy");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Upper" + $crntInt + "Grp.sz");

			$shoulderInf--;
			$kneeInf++;
			$crntInt++;
		}
	}

	//LOWER LEG JOINTS
	if ($lowerLegNum > 0)                                                         
	{
		$kneeInf = $lowerLegNum;
		$wristInf = 1;
		$crntInt = 1;
		while ($crntInt <= $lowerLegNum)
		{
			RRM_CreateProxyModuleProxy_V1($crntUnit);
			rename RRM_Base ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
			group -n ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
			parent ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Hip");
			scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".core") ($prfx + $modName + "_Lower" + $crntInt);
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ext") ("_Lower" + $crntInt);
			setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".core");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ext");
			if ($mirrorMod == 2)
			{
				addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".pair") ($crntSide);
				addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Lower" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".pair");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".opposite");
			}
			//SCALE LOCATOR
			setAttr (("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScale"), .125, .125, .125);
			if ($crntUnit == "m")
			{
				setAttr (("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "DShape.localScale"), .00125, .00125, .00125);
			}
			connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".template");

			if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Knee") ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_KneeW0") $kneeInf;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_AnkleW1") $wristInf;
			}
			else
			{
				pointConstraint ("RRM_" + $prfx + $modName + "_Knee2") ("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Knee2W0") $kneeInf;
				setAttr ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_AnkleW1") $wristInf;
			}
			//LOCK ATTRIBUTES
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".rx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".ry");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".rz");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sy");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + ".sz");

			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.tx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.ty");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.tz");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.rx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.ry");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.rz");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sx");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sy");
			setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Lower" + $crntInt + "Grp.sz");

			$kneeInf--;
			$wristInf++;
			$crntInt++;
		}
	}
	
	//KNEE JOINTS
	if ($kneeJoints == 2)
	{
		if ($kneeNum > 0)
		{
			$knee1Inf = $kneeNum;
			$knee2Inf = 1;
			$crntInt = 1;
			while ($crntInt <= $kneeNum)
			{
				RRM_CreateProxyModuleProxy_V1($crntUnit);
				rename RRM_Base ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
				group -n ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
				parent ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp") ("RRM_" + $prfx + $modName + "_Hip");
				scale -r 0.5 0.5 0.5 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");
				makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");

				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".core") ($prfx + $modName + "_Middle" + $crntInt);
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ext") ("_Middle" + $crntInt);
				setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".core");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ext");
				if ($mirrorMod == 2)
				{
					addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".pair") ($crntSide);
					addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt);
					setAttr -type "string" ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".opposite") ($oppPrfx + $modName + "_Middle" + $crntInt);
					setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".pair");
					setAttr -l true ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".opposite");
				}
				//SCALE LOCATOR
				setAttr (("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScale"), .125, .125, .125);
				if ($crntUnit == "m")
				{
					setAttr (("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "DShape.localScale"), .00125, .00125, .00125);
				}
				connectAttr ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".template");
				
				pointConstraint ("RRM_" + $prfx + $modName + "_Knee1") ("RRM_" + $prfx + $modName + "_Knee2") ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp");
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Knee1W0") $knee1Inf;
				setAttr ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp_pointConstraint1.RRM_" + $prfx + $modName + "_Knee2W1") $knee2Inf;
				
				//LOCK ATTRIBUTES
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".rx");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".ry");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".rz");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sx");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sy");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + ".sz");
				
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.tx");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.ty");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.tz");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.rx");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.ry");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.rz");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sx");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sy");
				setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Middle" + $crntInt + "Grp.sz");

				$knee1Inf--;
				$knee2Inf++;
				$crntInt++;
			}
		}
	}
	
	//LOCK CHANNELS
	if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
	{
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee.rx");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee.ry");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee.rz");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee.sx");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee.sy");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee.sz");
	}
	else
	{
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee1.rx");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee1.ry");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee1.rz");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee1.sx");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee1.sy");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee1.sz");
    
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee2.rx");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee2.ry");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee2.rz");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee2.sx");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee2.sy");
		setAttr -lock 1 -keyable 0 ("RRM_" + $prfx + $modName + "_Knee2.sz");
	}
    
	//ADD EXTRA ATTRIBUTES
	if ($mirrorMod == 2)
	{
		if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
		{
			select ("RRM_" + $prfx + $modName + "_Knee");
		}
		else
		{
			select ("RRM_" + $prfx + $modName + "_Knee1") ("RRM_" + $prfx + $modName + "_Knee2");
		}
		
		$legMods = `ls -sl`;
		string $crntMod;
		for ($crntMod in $legMods)
		{
			//PAIR AND TYPE
			addAttr -ln "pair"  -dt "string"  $crntMod;
			setAttr -e-keyable 1 ($crntMod + ".pair");
			setAttr -type "string" ($crntMod + ".pair") $crntSide;
			setAttr -l true ($crntMod + ".pair");
			//OPPOSITE NAME
			addAttr -ln "opposite" -dt "string"  $crntMod;
			setAttr -e-keyable 1 ($crntMod + ".opposite");
		}
		if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee.opposite") ($oppPrfx + $modName + "_Knee");
		}
		else
		{
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee1.opposite") ($oppPrfx + $modName + "_Knee1");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee2.opposite") ($oppPrfx + $modName + "_Knee2");
		}
		
		for ($crntMod in $legMods)
		{
			setAttr -l true ($crntMod + ".opposite");
		}
		
		//COLOURS
		setAttr ($crntMod + ".overrideEnabled") 1;
		setAttr ($crntMod + ".overrideColor") 31;
	}

	setAttr ("RRM_" + $prfx + $modName + "_AimLctr.v")      0;
	setAttr ("RRM_" + $prfx + $modName + "_KneeAimLctr.v") 0;
}

global proc RRM_CreateProxyLeg_V1(string $modName, int $upperLegNum, int $lowerLegNum, int $kneeNum, int $kneeJoints, int $toon, int $mirrorMod)
{
	string $crntUnit = `currentUnit -query -linear`;

	
	string $prfx = "l_";
	string $oppPrfx = "r_";
	float $posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	
	float $rotOffset = -90;

	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;

	$i = 1;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 1)
		{
			$prfx = "";
			$prfx = "";
			$posOffset = 0;
			$rotOffset = 180; 
		}
			
		//ATTACH NODE
		RRM_CreateProxyParentProxy_V1($crntUnit);
		rename RRM_Parent ("RRM_" + $prfx + $modName + "_Parent");
		rotate -r 0 0 $rotOffset ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "leg";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");
		
		addAttr -ln "upperRollNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "lowerRollNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "kneeNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "midRollNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");

		//TEMPLATE ROLL JOINTS
		addAttr -ln "templateRollJoints"  -at bool -dv 1 ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -e -keyable 1 ("RRM_" + $prfx + $modName + "_Parent.templateRollJoints");

		//TOON ARMS
		addAttr -ln "toonLegs"  -at bool -dv 1 ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -e -keyable 1 -l 1 ("RRM_" + $prfx + $modName + "_Parent.toonLegs");

		//HIP		
		RRM_CreateProxyModuleProxy_V1($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Hip");
		curve -n ("RRM_" + $prfx + $modName + "_HipAim") -d 1 -p -0.25 0 0 -p -0.25 0 -1 -p -0.5 0 -1 -p 0 0 -1.5 -p 0.5 0 -1 -p 0.25 0 -1 -p 0.25 0 0-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
		rotate -r 180 0 -90	("RRM_" + $prfx + $modName + "_HipAim");
		makeIdentity -apply true ("RRM_" + $prfx + $modName + "_HipAim");
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_HipAim")` ("RRM_" + $prfx + $modName + "_HipAimShape");
		parent -r -s ("RRM_" + $prfx + $modName + "_HipAimShape") ("RRM_" + $prfx + $modName + "_Hip");
		delete ("RRM_" + $prfx + $modName + "_HipAim");
		group -n ("RRM_" + $prfx + $modName + "_HipGrp") ("RRM_" + $prfx + $modName + "_Hip"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_HipGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_HipGrp");		
		move -r $posOffset -1 0 ("RRM_" + $prfx + $modName + "_HipGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_HipGrp");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Hip.core") ($prfx + $modName + "_Hip");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Hip.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Hip.ext") ("_Hip");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Hip.ext");

		//ANKLE
		RRM_CreateProxyModuleProxy_V1($crntUnit);		
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Ankle");
		group -n ("RRM_" + $prfx + $modName + "_AnkleGrp") ("RRM_" + $prfx + $modName + "_Ankle"); xform -os -piv 0 0 0; 
		parent ("RRM_" + $prfx + $modName + "_AnkleGrp") ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_AnkleGrp");		
		move -r 0 1.5 0 ("RRM_" + $prfx + $modName + "_AnkleGrp");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_AnkleGrp");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ankle.core") ($prfx + $modName + "_Ankle");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ankle.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ankle.ext") ("_Ankle");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ankle.ext");

		//FOOT
		//FOOT GROUND
		circle -n ("RRM_" + $prfx + $modName + "_Ground") -nr 0 1 0 -r 3.25 -ch 0;
		group -n ("RRM_" + $prfx + $modName + "_GroundGrp") ("RRM_" + $prfx + $modName + "_Ground"); xform -os -piv 0 0 0; 
		scale -r .8 1 1 ("RRM_" + $prfx + $modName + "_GroundGrp");
		makeIdentity -apply true -r 1 -s 1 ("RRM_" + $prfx + $modName + "_GroundGrp");
		move -r 0 0 2 ("RRM_" + $prfx + $modName + "_Ground.cv[0:7]");
		
		group -n ("RRM_" + $prfx + $modName + "_GroundGrp2") ("RRM_" + $prfx + $modName + "_GroundGrp"); xform -os -piv 0 0 0; 
		
		addAttr -ln "core" -dt "string" ("RRM_" + $prfx + $modName + "_Ground");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Ground.core");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ground.core") ($prfx + $modName + "_Ground");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ground.core");
		
		addAttr -ln "ext" -dt "string" ("RRM_" + $prfx + $modName + "_Ground");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Ground.ext");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ground.ext") ("_Ground");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ground.ext");
		
		addAttr -ln "clone" -dt "string" ("RRM_" + $prfx + $modName + "_Ground");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Ground.clone");

		addAttr -ln "modName" -dt "string" ("RRM_" + $prfx + $modName + "_Ground");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Ground.modName");
		
		move -r 1.3 0 0 ("RRM_" + $prfx + $modName + "_GroundShape.cv[3]") ;
		move -r 0.2 0 0 ("RRM_" + $prfx + $modName + "_GroundShape.cv[2]") ("RRM_" + $prfx + $modName + "_GroundShape.cv[4]");
		move -r -1.3 0 0 ("RRM_" + $prfx + $modName + "_GroundShape.cv[7]") ;
		move -r -0.2 0 0 ("RRM_" + $prfx + $modName + "_GroundShape.cv[2]") ("RRM_" + $prfx + $modName + "_GroundShape.cv[4]");
		
		RRM_CreateProxyModuleProxy_V1($crntUnit);
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Ball");
		parent ("RRM_" + $prfx + $modName + "_Ball") ("RRM_" + $prfx + $modName + "_Ground");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Ball");		
		move -r 0 0 2.5 ("RRM_" + $prfx + $modName + "_Ball");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Ball");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ball.core") ($prfx + $modName + "_Ball");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ball.core");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ball.ext") ("_Ball");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Ball.ext");

		RRM_CreateProxyEndProxy_V1($crntUnit);
		rename RRM_End ("RRM_" + $prfx + $modName + "_Toe");
		parent ("RRM_" + $prfx + $modName + "_Toe") ("RRM_" + $prfx + $modName + "_Ground");
		makeIdentity -apply false -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Toe");		
		move -r 0 0 4 ("RRM_" + $prfx + $modName + "_Toe");
		rotate -r 90 0 0 ("RRM_" + $prfx + $modName + "_Toe");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Toe");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Toe.core") ($prfx + $modName + "_Toe");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Toe.core");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Toe.ext") ("_Toe");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Toe.ext");

		//FOOT CONTROLS
		curve -n ("RRM_" + $prfx + $modName + "_FootRightTilt") -d 1 -p 0 0 -1 -p 0 0 1 -p 0 0 0 -p 1 0 0 -p -1 0 0 -p 0 0 0 -p 0 1 0 -p 0 -1 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_FootRightTilt")` ("RRM_" + $prfx + $modName + "_FootRightTiltShape");
		
		spaceLocator -n ("RRM_" + $prfx + $modName + "_FootRightTiltB");
		setAttr (("RRM_" + $prfx + $modName + "_FootRightTiltBShape.localScale"), .25, .25, .25);
		if ($crntUnit == "m")
		{
			setAttr (("RRM_" + $prfx + $modName + "_FootRightTiltBShape.localScale"), 0.0025, 0.0025, 0.0025);
		}
		
		parent -r -s ("RRM_" + $prfx + $modName + "_FootRightTiltBShape") ("RRM_" + $prfx + $modName + "_FootRightTilt");
		delete ("RRM_" + $prfx + $modName + "_FootRightTiltB");

		parent ("RRM_" + $prfx + $modName + "_FootRightTilt") ("RRM_" + $prfx + $modName + "_Ground");
		move -r -1 0 2.5 ("RRM_" + $prfx + $modName + "_FootRightTilt");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_FootRightTilt");
		
		addAttr -ln "core" -dt "string" ("RRM_" + $prfx + $modName + "_FootRightTilt");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_FootRightTilt.core");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootRightTilt.core") ($prfx + $modName + "_FootRightTilt");
		setAttr -l true ("RRM_" + $prfx + $modName + "_FootRightTilt.core");
		
		addAttr -ln "ext" -dt "string" ("RRM_" + $prfx + $modName + "_FootRightTilt");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_FootRightTilt.ext");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootRightTilt.ext") ("_FootRightTilt");
		setAttr -l true ("RRM_" + $prfx + $modName + "_FootRightTilt.ext");
		
		addAttr -ln "clone" -dt "string" ("RRM_" + $prfx + $modName + "_FootRightTilt");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_FootRightTilt.clone");

		addAttr -ln "modName" -dt "string" ("RRM_" + $prfx + $modName + "_FootRightTilt");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Ground.modName");

		duplicate -n ("RRM_" + $prfx + $modName + "_FootLeftTilt") ("RRM_" + $prfx + $modName + "_FootRightTilt");
		select ("RRM_" + $prfx + $modName + "_FootLeftTilt");
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_FootLeftTiltShape");
		move -r 2 0 0 ("RRM_" + $prfx + $modName + "_FootLeftTilt");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_FootLeftTilt");
		
		setAttr -l false ("RRM_" + $prfx + $modName + "_FootLeftTilt.core");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootLeftTilt.core") ($prfx + $modName + "_FootLeftTilt");
		setAttr -l true ("RRM_" + $prfx + $modName + "_FootLeftTilt.core");
		
		setAttr -l false ("RRM_" + $prfx + $modName + "_FootLeftTilt.ext");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootLeftTilt.ext") ("_FootLeftTilt");
		setAttr -l true ("RRM_" + $prfx + $modName + "_FootLeftTilt.ext");

		duplicate -n ("RRM_" + $prfx + $modName + "_HeelPivot") ("RRM_" + $prfx + $modName + "_FootRightTilt"); 
		select ("RRM_" + $prfx + $modName + "_HeelPivot");
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_HeelPivotShape");
		move -r 1 0 -3 ("RRM_" + $prfx + $modName + "_HeelPivot");
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_HeelPivot");
		
		setAttr -l false ("RRM_" + $prfx + $modName + "_HeelPivot.core");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_HeelPivot.core") ($prfx + $modName + "_HeelPivot");
		setAttr -l true ("RRM_" + $prfx + $modName + "_HeelPivot.core");
		
		setAttr -l false ("RRM_" + $prfx + $modName + "_HeelPivot.ext");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_HeelPivot.ext") ("_HeelPivot");
		setAttr -l true ("RRM_" + $prfx + $modName + "_HeelPivot.ext");

		//LOCK CHANNELS
		$footPivots = `ls ("RRM_" + $prfx + $modName + "_FootRightTilt") ("RRM_" + $prfx + $modName + "_FootLeftTilt") ("RRM_" + $prfx + $modName + "_HeelPivot")`;
		string $crntControl;
		for ($crntControl in $footPivots)
		{
			setAttr -lock 1 -keyable 0 ($crntControl + ".ty");
			setAttr -lock 1 -keyable 0 ($crntControl + ".rx");
			setAttr -lock 1 -keyable 0 ($crntControl + ".ry");
			setAttr -lock 1 -keyable 0 ($crntControl + ".rz");
			setAttr -lock 1 -keyable 0 ($crntControl + ".sx");
			setAttr -lock 1 -keyable 0 ($crntControl + ".sy");
			setAttr -lock 1 -keyable 0 ($crntControl + ".sz");
		}
		//CONNECT FOOT
		parent ("RRM_" + $prfx + $modName + "_AnkleGrp") ("RRM_" + $prfx + $modName + "_Ground");
		setAttr ("RRM_" + $prfx + $modName + "_AnkleGrp.ty") 0;
		
		RRM_CreateProxyLeg_V12_V1($modName, $upperLegNum, $lowerLegNum, $kneeNum, $kneeJoints, $toon, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $posOffset, $crntUnit);

		//ADD EXTRA ATTRIBUTES, CHANGE COLOURS
		select ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Hip")
		("RRM_" + $prfx + $modName + "_Ankle") ("RRM_" + $prfx + $modName + "_Ball")
		("RRM_" + $prfx + $modName + "_Toe") ("RRM_" + $prfx + $modName + "_FootRightTilt")
		("RRM_" + $prfx + $modName + "_FootLeftTilt") ("RRM_" + $prfx + $modName + "_HeelPivot")
		("RRM_" + $prfx + $modName + "_Ground") ;

			
		$legMods = `ls -sl`;
		string $crntMod;
		for ($crntMod in $legMods)
		{
			if ($mirrorMod == 2)
			{
				addAttr -ln "pair"  -dt "string"  $crntMod;
				setAttr -e-keyable 1 ($crntMod + ".pair");
				setAttr -type "string" ($crntMod + ".pair") $crntSide;
				setAttr -l true ($crntMod + ".pair");
				
				addAttr -ln "opposite"  -dt "string" $crntMod;
				setAttr -e-keyable 1 ($crntMod + ".opposite");
			}

			//COLOURS
			setAttr ($crntMod + ".overrideEnabled") 1;
			setAttr ($crntMod + ".overrideColor") 31;
		}
		
		if ($mirrorMod == 2)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
				addAttr -ln "pair"  -dt "string" ("RRM_" + $modName);
				setAttr -e-keyable 1 ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");
			}
			else
			{
				parent  ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
			}

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Hip.opposite") ($oppPrfx + $modName + "_Hip");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ankle.opposite") ($oppPrfx + $modName + "_Ankle");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ball.opposite") ($oppPrfx + $modName + "_Ball");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Toe.opposite") ($oppPrfx + $modName + "_Toe");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ground.opposite") ($oppPrfx + $modName + "_Ground");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootLeftTilt.opposite") ($oppPrfx + $modName + "_FootRightTilt");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootRightTilt.opposite") ($oppPrfx + $modName + "_FootLeftTilt");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_HeelPivot.opposite") ($oppPrfx + $modName + "_HeelPivot");
	
			for ($crntMod in $legMods)
			{
				setAttr -l true ($crntMod + ".opposite");
			}
		}
		setAttr ("RRM_" + $prfx + $modName + "_AimLctr.v") 0;
		setAttr ("RRM_" + $prfx + $modName + "_KneeAimLctr.v") 0;
		
		//ATTACH TO RIG
		int $mirrorCheck = 2;
		RRM_AttachToRig_V1($attachMod[0], $modName, $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);

		pointConstraint -skip y ("RRM_" + $prfx + $modName + "_Hip") ("RRM_" + $prfx + $modName + "_GroundGrp");
		parentConstraint -mo RRM_MAIN ("RRM_" + $prfx + $modName + "_GroundGrp2");
		parent ("RRM_" + $prfx + $modName + "_GroundGrp2") ("RRM_" + $prfx + $modName + "_Parent");
		scale 1 1 1 ("RRM_" + $prfx + $modName + "_GroundGrp") ("RRM_" + $prfx + $modName + "_GroundGrp2");


		//PARENT CONNECTOR
		RRM_ProxyConnectors_V1($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$rotOffset = 90;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
	}

	//ADD TOP ATTRIBUTE
	addAttr -ln "top"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".top");
	setAttr -type "string" ("RRM_" + $modName + ".top") "leg";
	setAttr -l true ("RRM_" + $modName + ".top");
	
	//ADD PARENT ATTRIBUTE
	$parentCore = `getAttr ($attachMod[0] + ".core")`;
	addAttr -ln "parent"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".parent");
	setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
	setAttr -l true ("RRM_" + $modName + ".parent");
	
	//ADD CORE NAME ATTRIBUTE
	addAttr -ln "core"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".core");
	setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
	setAttr -l true ("RRM_" + $modName + ".core");
	
	//ADD UPPER LEG NUM ATTRIBUTE
	addAttr -ln "upperLegNum" -at long ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".upperLegNum");
	setAttr ("RRM_" + $modName + ".upperLegNum") $upperLegNum;
	setAttr -l true ("RRM_" + $modName + ".upperLegNum");
	
	//ADD LOWER LEG NUM ATTRIBUTE
	addAttr -ln "lowerLegNum" -at long ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".lowerLegNum");
	setAttr ("RRM_" + $modName + ".lowerLegNum") $lowerLegNum;
	setAttr -l true ("RRM_" + $modName + ".lowerLegNum");

	//ADD KNEE NUM ATTRIBUTE
	addAttr -ln "kneeNum" -at long ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".kneeNum");
	setAttr ("RRM_" + $modName + ".kneeNum") $kneeNum;
	setAttr -l true ("RRM_" + $modName + ".kneeNum");

	//ADD UPPER LEG NUM ATTRIBUTE
	addAttr -ln "kneeJoints" -at long ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".kneeJoints");
	setAttr ("RRM_" + $modName + ".kneeJoints") $kneeJoints;
	setAttr -l true ("RRM_" + $modName + ".kneeJoints");	

	//ADD TOON LEG ATTRIBUTE
	addAttr -ln "toonLegs" -at long ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".toonLegs");
	setAttr ("RRM_" + $modName + ".toonLegs") $toon;
	setAttr -l true ("RRM_" + $modName + ".toonLegs");
			
	parent ("RRM_" + $modName) $attachMod[0];

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits_V1($xforms);

	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes_V1($modNodes);

	select -cl;
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

global proc RRM_LegPrompts_V1(string $modName, int $upperLegNum, int $lowerLegNum, int $kneeNum, int $kneeJoints, int $toon, int $mirrorMod)
{
	string $modName = `textField -q -text RRM_TextFieldLegName`;
	if (`size $modName` == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName_V1($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid name must begin with a letter.\n    The rest of the name may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text RRM_TextFieldLegName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this name. Please use a unique name\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			if (`size $attachMod` == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`size $attachMod` > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						RRM_CreateProxyLeg_V1($modName, $upperLegNum, $lowerLegNum, $kneeNum, $kneeJoints, $toon, $mirrorMod);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					RRM_CreateProxyLeg_V1($modName, $upperLegNum, $lowerLegNum, $kneeNum, $kneeJoints, $toon, $mirrorMod);
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////FK CHAINS/////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyFKChain_V12_V1(string $modName, int $chainsNum, int $jointsNum, int $direction, int $mirrorMod, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, int $multiplier, int $enableIK, string $crntUnit, int $create)
{
	//SET FK NUM'S IN PARENT NODE
	lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.chainNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.chainNum") $chainsNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.chainNum");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.jointNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.jointNum") $jointsNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.jointNum");
	
	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.direction");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.direction") $direction;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.direction");
	

	//SET FK NUM'S IN TOP NODE
	lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");

	setAttr -l false ("RRM_" + $modName + ".chainsNum");
	setAttr ("RRM_" + $modName + ".chainsNum") $chainsNum;
	setAttr -l true ("RRM_" + $modName + ".chainsNum");

	setAttr -l false ("RRM_" + $modName + ".jointsNum");
	setAttr ("RRM_" + $modName + ".jointsNum") $jointsNum;
	setAttr -l true ("RRM_" + $modName + ".jointsNum");
	
	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.direction");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.direction") $direction;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.direction");
	
	//SET IK ENABLED 
	setAttr -l false ("RRM_" + $modName + ".ikEnabled");
	setAttr ("RRM_" + $modName + ".ikEnabled") $enableIK;
	setAttr -l true ("RRM_" + $modName + ".ikEnabled");
	
	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.ikEnabled");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.ikEnabled") $enableIK;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ikEnabled");	

	//CREATE ATTACH LOCATION
	$point0 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[0]")`;
	$point1 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[1]")`;
	$point2 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[2]")`;
	$point3 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[3]")`;
	spaceLocator -n ("RRM_" + $prfx + $modName + "_targetLctr");
	move -ws (($point0[0] + $point1[0] + $point2[0] + $point3[0])/4)
	(($point0[1] + $point1[1] + $point2[1] + $point3[1])/4)
	(($point0[2] + $point1[2] + $point2[2] + $point3[2])/4) ("RRM_" + $prfx + $modName + "_targetLctr");
	
	$point0 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[5]")`;
	$point1 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[10]")`;
	$point2 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[9]")`;
	$point3 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[4]")`;
	spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
	move -ws (($point0[0] + $point1[0] + $point2[0] + $point3[0])/4)
	(($point0[1] + $point1[1] + $point2[1] + $point3[1])/4)
	(($point0[2] + $point1[2] + $point2[2] + $point3[2])/4) ("RRM_" + $prfx + $modName + "_AimLctr");

	$point0 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[0]")`;
	$point1 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[3]")`;
	$point2 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[4]")`;
	$point3 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[5]")`;
	spaceLocator -n ("RRM_" + $prfx + $modName + "_UpLctr");
	move -ws (($point0[0] + $point1[0] + $point2[0] + $point3[0])/4)
	(($point0[1] + $point1[1] + $point2[1] + $point3[1])/4)
	(($point0[2] + $point1[2] + $point2[2] + $point3[2])/4) ("RRM_" + $prfx + $modName + "_UpLctr");

	delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object"
	-worldUpObject ("RRM_" + $prfx + $modName + "_UpLctr") ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_AimLctr")`;
	parent ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_AimLctr");
	makeIdentity -apply false -r 1 ("RRM_" + $prfx + $modName + "_targetLctr");
	$targetLoc = `getAttr ("RRM_" + $prfx + $modName + "_targetLctr.translate")`;
	setAttr ("RRM_" + $prfx + $modName + "_targetLctr.tx") ($targetLoc[0] * 3.1304347826087);
	parentConstraint -mo ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_AimLctr");
	
	//CREATE FIRST NODE
	if ($jointsNum != 1)
	{
		RRM_CreateProxyBaseUpProxy_V1($crntUnit);
		rename RRM_BaseUp ("RRM_" + $prfx + $modName + "_01_");
		setAttr ("RRM_" + $prfx + $modName + "_01_.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_01_.overrideColor") 9;
	}
	else
	{
		RRM_CreateProxyEndProxy_V1($crntUnit);
		rename RRM_End ("RRM_" + $prfx + $modName + "_01_");
		rotate -r -os -90 0 0 ("RRM_" + $prfx + $modName + "_01_");
		setAttr ("RRM_" + $prfx + $modName + "_01_.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_01_.overrideColor") 9;
	}
	parent ("RRM_" + $prfx + $modName + "_01_") ("RRM_" + $prfx + $modName + "_Grp");
	makeIdentity -apply 0 -r 1 ("RRM_" + $prfx + $modName + "_01_");
	delete `parentConstraint ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_Grp")`;
	if ($crntSide == "right")
	{
		$rY = `getAttr ("RRM_" + $prfx + $modName + "_Grp.ry")`;
		setAttr ("RRM_" + $prfx + $modName + "_Grp.ry") (180 + $rY);
	}
	
	setAttr -type "string" ("RRM_" + $prfx + $modName + "_01_.core") ($prfx + $modName + "_01_");
	
	setAttr -type "string" ("RRM_" + $prfx + $modName + "_01_.ext") ("_01_");

	delete ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_UpLctr");

	RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_01_"));

	if ($mirrorMod ==1)
	{
		addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_01_");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_01_.pair");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_01_.pair") $crntSide;
		setAttr -l true ("RRM_" + $prfx + $modName + "_01_.pair");
		
		addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_01_");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_01_.opposite");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_01_.opposite") ($oppPrfx + $modName + "_01_");
	}
    
	//CHAINS
	int $crntChNum = 2;
	while ($crntChNum <= $chainsNum)
	{
		$previousMod = ($crntChNum -1);
		string $namePadding = "";
		if ($crntChNum < 10)
		{
			$namePadding = "0";
		}
		string $namePaddingPrev = "";
		if ($crntChNum < 11)
		{
			$namePaddingPrev = "0";
		}
		duplicate -n ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_") ("RRM_" + $prfx + $modName + "_" + $namePaddingPrev + $previousMod + "_");
		move -r -ls  0 0 -0.75 ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_");
		
		if ($mirrorMod ==1)
		{
			setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.opposite") ($oppPrfx + $modName + "_" + $namePadding + $crntChNum + "_");			
		}
    
		setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.core");			
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.core") ($prfx + $modName + "_" + $namePadding + $crntChNum + "_");
    
		setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.ext");			
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_.ext") ("_" + $namePadding + $crntChNum + "_");
		
		//CONNECTORS
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntChNum + "_"));

		$crntChNum++;
	}
	
	//FIX JOINT OFFSET
	spaceLocator -n  ("RRM_" + $prfx + $modName + "chainCenterLctr");
	$chainStart = `ls ("RRM_" + $prfx + $modName + "_??_")`;
	delete `pointConstraint $chainStart ("RRM_" + $prfx + $modName + "chainCenterLctr")`;
	parent $chainStart ("RRM_" + $prfx + $modName + "chainCenterLctr");
	delete `pointConstraint ("RRM_" + $prfx + $modName + "_Grp") ("RRM_" + $prfx + $modName + "chainCenterLctr")`;
	parent $chainStart ("RRM_" + $prfx + $modName + "_Grp");
	delete ("RRM_" + $prfx + $modName + "chainCenterLctr");
	makeIdentity -apply 1 -t 1 -r 1 -s 1 $chainStart;

    
	//JOINTS
	$chains = `listRelatives -ad -type "transform" ("RRM_" + $prfx + $modName + "_Grp")`;
	int $crntJntNum = 2;
    
	for ($crntJnt in $chains)
	{
		$crntJntNum = 2;
		while ($crntJntNum <= $jointsNum)
		{
			string $namePadding = "";
			string $prevPadding = "";
			$prevJntNum = ($crntJntNum - 1);
			//CHECK IF END NODE OR NOT
			if ($crntJntNum < 10)
			{
				$namePadding = "0";
			}
			if ($crntJntNum <= 10)
			{
				$prevPadding = "0";
			}
			if ($crntJntNum != $jointsNum)
			{
				if ($crntJntNum ==2)
				{
					duplicate -n ($crntJnt + $namePadding + $crntJntNum) $crntJnt;
					move -r -ls (1 * $multiplier) 0 0 ($crntJnt + $namePadding + $crntJntNum);
					parent ($crntJnt + $namePadding + $crntJntNum) $crntJnt;
				}
				else
				{
					duplicate -n ($crntJnt + $namePadding + $crntJntNum) ($crntJnt + $prevPadding + $prevJntNum);
					move -r -ls (1 * $multiplier) 0 0 ($crntJnt + $namePadding + $crntJntNum);
					parent ($crntJnt + $namePadding + $crntJntNum) ($crntJnt + $prevPadding + $prevJntNum);
				}
			}
			else
			{
				RRM_CreateProxyEndProxy_V1($crntUnit);
				rename RRM_End ($crntJnt + $namePadding + $crntJntNum);
				if ($crntSide == "left")
				{
					rotate -r 0 0 -90 ($crntJnt + $namePadding + $crntJntNum);
					makeIdentity -apply 1 -r 1 ($crntJnt + $namePadding + $crntJntNum);
				}
				else
				{
					rotate -r 0 0 90 ($crntJnt + $namePadding + $crntJntNum);					
					makeIdentity -apply 1 -r 1 ($crntJnt + $namePadding + $crntJntNum);
				}
				if ($crntJntNum ==2)
				{
					parent ($crntJnt + $namePadding + $crntJntNum) $crntJnt;
					delete `parentConstraint $crntJnt ($crntJnt + $namePadding + $crntJntNum)`;
				}
				else
				{
					parent ($crntJnt + $namePadding + $crntJntNum) ($crntJnt + $prevPadding + $prevJntNum);
					delete `parentConstraint ($crntJnt + $prevPadding + $prevJntNum) ($crntJnt + $namePadding + $crntJntNum)`;
				}
				if ($mirrorMod ==1)
				{
					addAttr -ln "pair"  -dt "string" ($crntJnt + $namePadding + $crntJntNum);
					setAttr -e-keyable 1 ($crntJnt + $namePadding + $crntJntNum + ".pair");
					setAttr -type "string" ($crntJnt + $namePadding + $crntJntNum + ".pair") $crntSide;
					setAttr -l true ($crntJnt + $namePadding + $crntJntNum + ".pair");
					
					
					addAttr -ln "opposite"  -dt "string" ($crntJnt + $namePadding + $crntJntNum);
					setAttr -e-keyable 1 ($crntJnt + $namePadding + $crntJntNum + ".opposite");
				}
				move -r -ls  (1 * $multiplier) 0 0 ($crntJnt + $namePadding + $crntJntNum);
			}
			//ATTRIBUTES
			$coreName = `getAttr ($crntJnt + ".core")`;
			setAttr -l false ($crntJnt + $namePadding + $crntJntNum + ".core");
			setAttr -type "string" ($crntJnt + $namePadding + $crntJntNum + ".core") ($coreName + $namePadding + $crntJntNum);
			setAttr -l true ($crntJnt + $namePadding + $crntJntNum + ".core");

			$extName = `getAttr ($crntJnt + ".ext")`;
			setAttr -l false ($crntJnt + $namePadding + $crntJntNum + ".ext");
			setAttr -type "string" ($crntJnt + $namePadding + $crntJntNum + ".ext") ($extName + $namePadding + $crntJntNum);
			setAttr -l true ($crntJnt + $namePadding + $crntJntNum + ".ext");

			if ($mirrorMod == 1)
			{
				$oppositeName = `getAttr ($crntJnt + ".opposite")`;
				setAttr -l false ($crntJnt + $namePadding + $crntJntNum + ".opposite");
				setAttr -type "string" ($crntJnt + $namePadding + $crntJntNum + ".opposite") ($oppositeName + $namePadding + $crntJntNum);
				setAttr -l true ($crntJnt + $namePadding + $crntJntNum + ".opposite");
			}
			//CONNECTORS
			if ($crntJntNum == 2)
			{
				RRM_ProxyConnectors_V1($modName, $prfx, $crntJnt, ($crntJnt + $namePadding + $crntJntNum));
			}
			else
			{
				RRM_ProxyConnectors_V1($modName, $prfx, ($crntJnt + $prevPadding + $prevJntNum), ($crntJnt + $namePadding + $crntJntNum));
			}
			makeIdentity -apply 1 -t 1 -r 1 -s 1 ($crntJnt + $namePadding + $crntJntNum);
			
			$crntJntNum++;
		}
	}
    
	//RENAME 01 JOINTS
	$topJoints = `ls ("RRM_" + $prfx + $modName + "_??_")`;
	$previousJnt = ("RRM_" + $prfx + $modName + "_Parent_");
	$i =0;
	for ($crntJnt in $topJoints)
	{
		rename $crntJnt ($crntJnt + "01");

		$coreName = `getAttr ($crntJnt + "01.core")`;
		setAttr -type "string" ($crntJnt + "01.core") ($coreName + "01");
		setAttr -l true ($crntJnt + "01.core");

		$extName = `getAttr ($crntJnt + "01.ext")`;
		setAttr -type "string" ($crntJnt + "01.ext") ($extName + "01");
		setAttr -l true ($crntJnt + "01.ext");
		
		if ($mirrorMod == 1)
		{
			$oppositeName = `getAttr ($crntJnt + "01.opposite")`;
			setAttr -type "string" ($crntJnt + "01.opposite") ($oppositeName + "01");		
			setAttr -l true ($crntJnt + "01.opposite");
		}
	}
	/*
	//ONLY FREEZE IF IT IS NOT AN EDIT
	if ($create == 1)
	{
		//FIX UP AND DOWN
		if ($direction == 2)
		{
			rotate -r 0 -90 0 ("RRM_" + $prfx + $modName + "_Parent");
			makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
		}
		if ($direction == 5)
		{
			rotate -r 0 90 0 ("RRM_" + $prfx + $modName + "_Parent");
			makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
		}
		makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Grp");
	}//*/
}

global proc RRM_CreateProxyFKChain_V1(string $modName, int $chainsNum, int $jointsNum, int $modDirection, int $modDirection2, int $mirrorMod, int $enableIK)
{
	//SET UNITS TO CENTIMETERS
	string $crntUnit = `currentUnit -query -linear`;

	//if ($crntUnit != "cm")
	//{
	//}
	if ($modDirection == 0)
	{
		$modDirection = ($modDirection2 + 3);
	}
	
	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$rotOffset = 0;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	$create = 1;

	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	
	//FK CHAIN
	$i = 0;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 0)
		{
			$prfx = "";
			$oppSide = "";
		}
		
		RRM_CreateProxyParentProxy_V1($crntUnit);
		rename RRM_Parent ("RRM_" + $prfx + $modName + "_Parent");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;

		addAttr -ln "ikEnabled" -at bool ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Parent.ikEnabled");
		setAttr ("RRM_" + $prfx + $modName + "_Parent.ikEnabled") $enableIK;
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ikEnabled");
			
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "fkChain";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");

		addAttr -ln "chainNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "jointNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
		addAttr -ln "direction"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");
	
		//CHECK IF MIRRORED
		if ($mirrorMod ==1)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
	
				addAttr -ln "pair"  -dt "string" ("RRM_" + $modName);
				setAttr -e-keyable 1 ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");
			}
			else
			{
				parent ("RRM_" + $prfx + $modName) ("RRM_" + $modName);
			}
			
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Parent.pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.pair");
			
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Parent.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.opposite");			
		}

		if (!`objExists ("RRM_" + $modName + ".chainsNum")`)
		{
			//ADD CHAIN NUM ATTRIBUTE	
			addAttr -ln "chainsNum" -at long ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".chainsNum");
			setAttr ("RRM_" + $modName + ".chainsNum") $chainsNum;
			setAttr -l true ("RRM_" + $modName + ".chainsNum");
		
			//ADD JOINT NUM ATTRIBUTE	
			addAttr -ln "jointsNum" -at long ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".jointsNum");
			setAttr ("RRM_" + $modName + ".jointsNum") $jointsNum;
			setAttr -l true ("RRM_" + $modName + ".jointsNum");
			
			//ADD IK ENABLED ATTR
			addAttr -ln "ikEnabled" -at bool ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".ikEnabled");
			setAttr ("RRM_" + $modName + ".ikEnabled") $enableIK;
			setAttr -l true ("RRM_" + $modName + ".ikEnabled");
		}

		//X
		string $selectedMod;
		float $xValue = 0;
		rotate -r -90 -90 0 ("RRM_" + $prfx + $modName + "_Parent");
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
		
		//CREATE GROUPS
		group -em -n ("RRM_" + $prfx + $modName + "_Grp");
		parent ("RRM_" + $prfx + $modName + "_Grp") ("RRM_" + $prfx + $modName + "_Parent");
		
		if ($crntSide == "left")
		{
			if ($modDirection == 1)
			{
				//CHECK LOCATION
				for ($selectedMod in $attachMod)
				{
					$modTX = `xform -q -ws -rp $selectedMod`;
					$xValue = ($xValue + $modTX[0]);
					if ($xValue < 0)
					{
						rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Parent");
						//rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Grp");
					}
				}
			}
			if ($modDirection == 4)
			{
				//CHECK LOCATION
				$xValue = 0;
				for ($selectedMod in $attachMod)
				{
					$modTX = `xform -q -ws -rp $selectedMod`;
					$xValue = ($xValue + $modTX[0]);
					
					if ($xValue >= 0)
					{
						rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Parent");
						rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Grp");
					}
				}
			}
		}
		else if ($crntSide == "right")
		{
			if ($modDirection == 1)
			{
				//CHECK LOCATION
				for ($selectedMod in $attachMod)
				{
					$modTX = `xform -q -ws -rp $selectedMod`;
					$xValue = ($xValue + $modTX[0]);
					if ($xValue >= 0)
					{
						rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Parent");
						//rotate -r 0 -180 0 ("RRM_" + $prfx + $modName + "_Grp");
					}
				}

			}
			if ($modDirection == 4)
			{
				//CHECK LOCATION
				$xValue = 0;
				for ($selectedMod in $attachMod)
				{
					$modTX = `xform -q -ws -rp $selectedMod`;
					$xValue = ($xValue + $modTX[0]);
					
					if ($xValue < 0)
					{
						rotate -r 0 180 0 ("RRM_" + $prfx + $modName + "_Parent");
						//rotate -r 0 -180 0 ("RRM_" + $prfx + $modName + "_Grp");
					}
				}
			}
		}
		//Y
		if ($modDirection == 2)
		{
			setAttr (("RRM_" + $prfx + $modName + "_Parent.rotate"), -90, 0, 90);
			//setAttr (("RRM_" + $prfx + $modName + "_Grp.rotate"), -90, 0, 90);
		}
		if ($modDirection == 5)
		{
			setAttr (("RRM_" + $prfx + $modName + "_Parent.rotate"), -90, 0, -90);
			//setAttr (("RRM_" + $prfx + $modName + "_Grp.rotate"), -90, 0, -90);
		}		
		//Z
		if ($modDirection == 3)
		{
			rotate -r 0 -90 0 ("RRM_" + $prfx + $modName + "_Parent");
			//rotate -r 0 90 0 ("RRM_" + $prfx + $modName + "_Grp");
		}
		if ($modDirection == 6)
		{
			rotate -r 0 90 0 ("RRM_" + $prfx + $modName + "_Parent");
			//rotate -r 0 -90 0 ("RRM_" + $prfx + $modName + "_Grp");
		}
		
		if (!`objExists ($attachMod[0] + ".pair")`)
		{
			if ($mirrorMod == 1)
			{
				move -r ($multiplier * 1) 0 0  ("RRM_" + $prfx + $modName + "_Parent");
			}
		}
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");

		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideColor") 9;
		
			
		//ATTACH TO RIG
		int $mirrorCheck = 1;
		RRM_AttachToRig_V1($attachMod[0], $modName, $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);

		RRM_CreateProxyFKChain_V12_V1($modName, $chainsNum, $jointsNum, $modDirection, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $enableIK, $crntUnit, $create);

		//PARENT CONNECTOR

		RRM_ProxyConnectors_V1($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$rotOffset = 180;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}

	//ADD TOP ATTRIBUTE
	addAttr -ln "top"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".top");
	setAttr -type "string" ("RRM_" + $modName + ".top") "fkChain";
	setAttr -l true ("RRM_" + $modName + ".top");

	//ADD PARENT ATTRIBUTE
	$parentCore = `getAttr ($attachMod[0] + ".core")`;
	addAttr -ln "parent"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".parent");
	setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
	setAttr -l true ("RRM_" + $modName + ".parent");

	//ADD CORE NAME ATTRIBUTE	
	addAttr -ln "core"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".core");
	setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
	setAttr -l true ("RRM_" + $modName + ".core");
	
	//ADD DIRECTION ATTRIBUTE	
	addAttr -ln "direction" -at long ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".direction");
	setAttr ("RRM_" + $modName + ".direction") $modDirection;
	setAttr -l true ("RRM_" + $modName + ".direction");

	parent ("RRM_" + $modName) $attachMod[0];

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits_V1($xforms);

	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes_V1($modNodes);
	

	select -cl;
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{
			select ("RRM_l_" + $modName + "_Parent") ("RRM_r_" + $modName + "_Parent");
		}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}


}

global proc RRM_FKChainPrompts_V1(string $modName, int $chainsNum, int $jointsNum, int $enableIK, int $mirrorMod, int $modDirection, int $modDirection2)
{
	if (`size $modName` == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName_V1($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid name must begin with a letter.\n    The rest of the name may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	//else if (`objExists ($modName)`)
	//{
	//	string $returnVal_Generate = `confirmDialog
	//		-title "The Module's Name is not Unique"
	//		-message "A module already exists with that name.\nYou must create a unique name.\n"
	//		-button "OK"
	//		-defaultButton "OK"
	//		-cancelButton "OK"
	//		-icon "critical"`;
	//}
	else
	{
		string $modName = `textField -q -text RRM_TextFieldFKChainName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this name. Please use a unique name\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			if (`size $attachMod` == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`size $attachMod` > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						$chainSize = ($chainsNum * $jointsNum * $mirrorMod);
						if ($chainSize <= 100)
						{
							RRM_CreateProxyFKChain_V1($modName, $chainsNum, $jointsNum, $modDirection, $modDirection2, $mirrorMod, $enableIK);
						}
						else
						{
							string $returnVal_Generate2 = `confirmDialog
							-title "Large Number of proxies in module"
							-message "The FK Chain you are about to create has over 100 proxies. This could take several minutes to generate. Proceed?\n"
							-button "OK" -button "Cancel"
							-defaultButton "OK"
							-cancelButton "Cancel"
							-icon "warning"`;
							
							if ($returnVal_Generate2 == "OK")
							{
								RRM_CreateProxyFKChain_V1($modName, $chainsNum, $jointsNum, $modDirection, $modDirection2, $mirrorMod, $enableIK);
							}
						}
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					$chainSize = ($chainsNum * $jointsNum * $mirrorMod);
					if ($chainSize <= 100)
					{
						RRM_CreateProxyFKChain_V1($modName, $chainsNum, $jointsNum, $modDirection, $modDirection2, $mirrorMod, $enableIK);
					}
					else
					{
						string $returnVal_Generate2 = `confirmDialog
						-title "Large Number of proxies in module"
						-message "The FK Chain you are about to create has over 100 proxies. This could take several minutes to generate. Proceed?\n"
						-button "OK" -button "Cancel"
						-defaultButton "OK"
						-cancelButton "Cancel"
						-icon "warning"`;
						
						if ($returnVal_Generate2 == "OK")
						{
							RRM_CreateProxyFKChain_V1($modName, $chainsNum, $jointsNum, $modDirection, $modDirection2, $mirrorMod, $enableIK);
						}
					}
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////HEAD///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyHead_V1(string $modName, int $RRM_Jaw, int $mirrorMod)
{
	string $crntUnit = `currentUnit -query -linear`;


	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 1;
	$crntSide = "left";
	$oppSide = "right";
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;

	$i = 0;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 0)
		{
			$prfx = "";
			$posOffset = 0;
		}
		
		if (`objExists ($attachMod[0] + (".opposite"))`)
		{
			$posOffset = 0;
		}
		
		RRM_CreateProxyParentProxy_V1($crntUnit);
		rename RRM_Parent ("RRM_" + $prfx + $modName + "_Parent");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "head";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");
		
		addAttr -ln "jaw"  -at bool -dv $RRM_Jaw ("RRM_" + $prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.jaw");
		
		

		RRM_CreateProxyEndProxy_V1($crntUnit);
		rename RRM_End ("RRM_" + $prfx  + $modName + "_Top");
		move -r 0 3 0 ("RRM_" + $prfx + $modName + "_Top");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.core") ($prfx + $modName + "_Top");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Top.core");
		
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.ext") ("_Top");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Top.ext");
		
		RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx  + $modName + "_Top"));
		
		if ($RRM_Jaw == 1)
		{
			RRM_CreateProxyModuleProxy_V1($crntUnit);
			rename RRM_Base	 ("RRM_" + $prfx + $modName + "_Jaw");
			move -r 0 1.5 0.25 ("RRM_" + $prfx + $modName + "_Jaw");
			
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.core") ($prfx + $modName + "_Jaw");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Jaw.core");
			
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.ext") ("_Jaw");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Jaw.ext");
		
			RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Jaw"));
			
			RRM_CreateProxyEndProxy_V1($crntUnit);
			rename RRM_End ("RRM_" + $prfx + $modName + "_JawEnd");
			move -r 0 1 1.5 ("RRM_" + $prfx + $modName + "_JawEnd");
			rotate -r 90 0 0 ("RRM_" + $prfx + $modName + "_JawEnd");
			parent ("RRM_" + $prfx + $modName + "_JawEnd") ("RRM_" + $prfx + $modName + "_Jaw");
			parent ("RRM_" + $prfx + $modName + "_Jaw") ("RRM_" + $prfx + $modName + "_Parent");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.core") ($prfx + $modName + "_JawEnd");
			setAttr -l true ("RRM_" + $prfx + $modName + "_JawEnd.core");

			setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.ext") ("_JawEnd");
			setAttr -l true ("RRM_" + $prfx + $modName + "_JawEnd.ext");

			RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Jaw"), ("RRM_" + $prfx + $modName + "_JawEnd"));
		}
		
		parent ("RRM_" + $prfx + $modName + "_Top") ("RRM_" + $prfx + $modName + "_Parent");

		if ($mirrorMod ==1)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
			
				addAttr -ln "pair"  -dt "string" ("RRM_" + $modName);
				setAttr -e-keyable 1 ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");
			}
			else
			{
				parent  ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
			}
			//MIRROR ATTRIBUTES
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + ".pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + ".pair");

			
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + ".opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".opposite") ($oppPrfx + $modName);
			setAttr -l true ("RRM_" + $prfx + $modName + ".opposite");
			
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Parent.pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.pair");
			
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Parent.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.opposite");
				
			if ($RRM_Jaw == 1)
			{
				addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Jaw");
				setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Jaw.pair");
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.pair") $crntSide;
				setAttr -l true ("RRM_" + $prfx + $modName + "_Jaw.pair");
				
				addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Jaw");
				setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Jaw.opposite");
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.opposite") ($oppPrfx + $modName + "_Jaw");
				setAttr -l true ("RRM_" + $prfx + $modName + "_Jaw.opposite");
        	
				addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_JawEnd");
				setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_JawEnd.pair");
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.pair") $crntSide;
				setAttr -l true ("RRM_" + $prfx + $modName + "_JawEnd.pair");
				
				addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_JawEnd");
				setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_JawEnd.opposite");
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.opposite") ($oppPrfx + $modName + "_JawEnd");
				setAttr -l true ("RRM_" + $prfx + $modName + "_JawEnd.opposite");
			}
				
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Top");
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Top.pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Top.pair");
			
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Top");
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Top.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.opposite") ($oppPrfx + $modName + "_Top");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Top.opposite");
		}
		//OFFSET FROM CENTER IF NOT ATTACHED TO PAIR		
		if (!`objExists ($attachMod[0] + ".pair")`)
		{
			move -r $posOffset 0 0 ("RRM_" + $prfx + $modName + "_Parent");
		}
				
		//ATTACH TO RIG
		int $mirrorCheck = 1;
		RRM_AttachToRig_V1($attachMod[0], $modName, $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);

		//ASSIGN COLOURS
		select ("RRM_" + $prfx + $modName + "_Top") ("RRM_" + $prfx + $modName + "_Parent");
		if ($RRM_Jaw == 1)
		{
			select -add ("RRM_" + $prfx + $modName + "_Jaw") ("RRM_" + $prfx + $modName + "_JawEnd");
		}
		$headProxies = `ls -sl`;
		string $crntHead;
		for ($crntHead in $headProxies)
		{
			setAttr ($crntHead + ".overrideEnabled") 1;
			setAttr ($crntHead + ".overrideColor") 4;
		}
		select ("RRM_" + $prfx + $modName + "_Parent");
		
		//PARENT CONNECTOR
		RRM_ProxyConnectors_V1($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -1;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
	}

	//ADD TOP ATTRIBUTE
	addAttr -ln "top"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".top");
	setAttr -type "string" ("RRM_" + $modName + ".top") "head";
	setAttr -l true ("RRM_" + $modName + ".top");

	//ADD PARENT ATTRIBUTE
	$parentCore = `getAttr ($attachMod[0] + ".core")`;
	addAttr -ln "parent"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".parent");
	setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
	setAttr -l true ("RRM_" + $modName + ".parent");

	//ADD CORE NAME ATTRIBUTE
	addAttr -ln "core"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".core");
	setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
	setAttr -l true ("RRM_" + $modName + ".core");
	
	//ADD JAW ATTRIBUTE
	addAttr -ln "jaw" -at long ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".jaw");
	setAttr ("RRM_" + $modName + ".jaw") $RRM_Jaw;
	setAttr -l true ("RRM_" + $modName + ".jaw");	

	parent ("RRM_" + $modName) $attachMod[0];

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits_V1($xforms);

	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes_V1($modNodes);

	select -cl;
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

global proc RRM_HeadPrompts_V1(string $modName, int $RRM_Jaw, int $mirrorMod)
{
	string $modName = `textField -q -text RRM_TextFieldHeadName`;
	if (`size $modName` == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName_V1($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid modName must begin with a letter.\n    The rest of the modName may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text RRM_TextFieldHeadName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this modName. Please use a unique modName\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			if (`size $attachMod` == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`size $attachMod` > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						RRM_CreateProxyHead_V1($modName, $RRM_Jaw, $mirrorMod);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					RRM_CreateProxyHead_V1($modName, $RRM_Jaw, $mirrorMod);
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////LOOK AT///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyLookAt_V12_V1(string $modName, int $jointsNum, int $mirrorMod, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, int $multiplier, string $crntUnit)
{
	//SET EYE NUM IN PARENT NODE
	lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");

	setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.eyeNum");
	setAttr ("RRM_" + $prfx + $modName + "_Parent.eyeNum") $jointsNum;
	setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.eyeNum");

	lockNode -lock off ("RRM_" + $modName);

	setAttr -l false ("RRM_" + $modName + ".eyeNum");
	setAttr ("RRM_" + $modName + ".eyeNum") $jointsNum;
	setAttr -l true ("RRM_" + $modName + ".eyeNum");
	

	//CREATE ATTACH LOCATION
	$point0 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[0]")`;
	$point1 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[1]")`;
	$point2 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[2]")`;
	$point3 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentShape.cv[3]")`;
	spaceLocator -n ("RRM_" + $prfx + $modName + "_targetLctr");
	move -ws (($point0[0] + $point1[0] + $point2[0] + $point3[0])/4)
	(($point0[1] + $point1[1] + $point2[1] + $point3[1])/4)
	(($point0[2] + $point1[2] + $point2[2] + $point3[2])/4) ("RRM_" + $prfx + $modName + "_targetLctr");
	
	$point0 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[5]")`;
	$point1 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[10]")`;
	$point2 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[9]")`;
	$point3 = `xform -q -ws -t ("RRM_" + $prfx + $modName + "_ParentBShape.cv[4]")`;
	spaceLocator -n ("RRM_" + $prfx + $modName + "_AimLctr");
	move -ws (($point0[0] + $point1[0] + $point2[0] + $point3[0])/4)
	(($point0[1] + $point1[1] + $point2[1] + $point3[1])/4)
	(($point0[2] + $point1[2] + $point2[2] + $point3[2])/4) ("RRM_" + $prfx + $modName + "_AimLctr");
	delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation"
	-worldUpVector 0 1 0 -worldUpObject ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_AimLctr")`;
	parent ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_AimLctr");
	makeIdentity -apply false -r 1 ("RRM_" + $prfx + $modName + "_targetLctr");
	$targetLoc = `getAttr ("RRM_" + $prfx + $modName + "_targetLctr.translate")`;
	setAttr ("RRM_" + $prfx + $modName + "_targetLctr.tx") ($targetLoc[0] * 1.65);
	parentConstraint -mo ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_AimLctr");
	
	//CREATE FIRST NODE
	RRM_CreateProxyBaseUpProxy_V1($crntUnit);
	rename RRM_BaseUp ("RRM_" + $prfx + $modName + "_01");
	scale -r  3 3.2 3 ("RRM_" + $prfx + $modName + "_01DShape.cv[1]") ("RRM_" + $prfx + $modName + "_01EShape.cv[0:2]")
	("RRM_" + $prfx + $modName + "_01FShape.cv[0:2]") ("RRM_" + $prfx + $modName + "_01GShape.cv[0:7]");
	
	move -r -os -wd 0 8 0 ("RRM_" + $prfx + $modName + "_01DShape.cv[1]") ("RRM_" + $prfx + $modName + "_01EShape.cv[0:2]")
	("RRM_" + $prfx + $modName + "_01FShape.cv[0:2]") ("RRM_" + $prfx + $modName + "_01GShape.cv[0:7]");
	move -r 0 1 0 ("RRM_" + $prfx + $modName + "_01");
	rotate -r -os 0 0 -90 ("RRM_" + $prfx + $modName + "_01");
	makeIdentity -apply true -t 1-r 1 ("RRM_" + $prfx + $modName + "_01");
    
	setAttr -type "string" ("RRM_" + $prfx + $modName + "_01.core") ($prfx + $modName + "_01");
	setAttr -l true ("RRM_" + $prfx + $modName + "_01.core");
    
	setAttr -type "string" ("RRM_" + $prfx + $modName + "_01.ext") ("_01");
	setAttr -l true ("RRM_" + $prfx + $modName + "_01.ext");
	
	RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_01"));

	if ($mirrorMod ==1)
	{
		//MIRROR ATTRIBUTES
		addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_01");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_01.pair");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_01.pair") $crntSide;
		setAttr -l true ("RRM_" + $prfx + $modName + "_01.pair");
		
		addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_01");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_01.opposite");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_01.opposite") ($oppPrfx + $modName + "_01");
		setAttr -l true ("RRM_" + $prfx + $modName + "_01.opposite");
	}
	group -n ("RRM_" + $prfx + $modName + "_Grp") ("RRM_" + $prfx + $modName + "_01"); xform -os -piv 0 0 0;
	
	if ($jointsNum > 1)
	{
		//JOINTS
		int $crntjointNum = 2;
		while ($crntjointNum <= $jointsNum)
		{
			$previousMod = ($crntjointNum -1);
			string $namePadding = "";
			if ($crntjointNum < 10)
			{
				$namePadding = "0";
			}
			string $namePaddingPrev = "";
			if ($crntjointNum < 11)
			{
				$namePaddingPrev = "0";
			}
			duplicate -n ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum) ("RRM_" + $prfx + $modName + "_" + $namePaddingPrev + $previousMod);
			move -r -ls 0 0 -0.75 ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum);
			
			setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".core");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".core") ($prfx + $modName + "_" + $namePadding + $crntjointNum);
			setAttr -l true ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".core");
			
			setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".ext");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".ext") ("_" + $namePadding + $crntjointNum);
			setAttr -l true ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".ext");
		
			if ($mirrorMod ==1)
			{
				setAttr -l false ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".opposite");
				setAttr -type "string" ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".opposite") ($oppPrfx + $modName + "_" + $namePadding + $crntjointNum);			
				setAttr -l true ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum + ".opposite");
			}
			RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_" + $namePadding + $crntjointNum));

			$crntjointNum++;
		}
	}
	//FIX JOINT OFFSET
	spaceLocator -n ("RRM_" + $prfx + $modName + "_CenterLctr");
	$lookAts = `ls ("RRM_" + $prfx + $modName + "_??")`;
	delete `pointConstraint $lookAts ("RRM_" + $prfx + $modName + "_CenterLctr")`;
	parent $lookAts ("RRM_" + $prfx + $modName + "_CenterLctr");
	delete `pointConstraint ("RRM_" + $prfx + $modName + "_Grp") ("RRM_" + $prfx + $modName + "_CenterLctr")`;
	parent $lookAts ("RRM_" + $prfx + $modName + "_Grp");
	delete `parentConstraint ("RRM_" + $prfx + $modName + "_targetLctr") ("RRM_" + $prfx + $modName + "_Grp")`;
	parent ("RRM_" + $prfx + $modName + "_Grp") ("RRM_" + $prfx + $modName + "_Parent");
	makeIdentity -apply true -t 1 -r 1 ("RRM_" + $prfx + $modName + "_Grp");
	setAttr (("RRM_" + $prfx + $modName + "_Grp.scale"), 1, 1, 1);

	delete ("RRM_" + $prfx + $modName + "_AimLctr") ("RRM_" + $prfx + $modName + "_CenterLctr");
}


global proc RRM_CreateProxyLookAt_V1(string $modName, int $jointsNum, int $modDirection, int $modDirection2, int $mirrorMod)
{
	string $crntUnit = `currentUnit -query -linear`;


	if ($modDirection == 0)
	{
		$modDirection = ($modDirection2 + 3);
	}

	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	
	$i = 0;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 0)
		{
			$prfx = "";
			$oppPrfx = "";
		}
		
		RRM_CreateProxyParentProxy_V1($crntUnit);
		rename RRM_Parent ("RRM_" + $prfx + $modName + "_Parent");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Parent"); xform -os -piv 0 0 0;

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.parent") "lookAt";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.parent");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.core") ($prfx + $modName + "_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.core");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.ext") ("_Parent");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.ext");

		addAttr -ln "eyeNum"  -at long -dv 0 ("RRM_" + $prfx + $modName + "_Parent");

		if ($mirrorMod ==1)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
				addAttr -ln "pair"  -dt "string" ("RRM_" + $modName);
				setAttr -e-keyable 1 ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");

			}
			else
			{
				parent  ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
			}
			
			//MIRROR ATTRIBUTES
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + ".pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + ".pair");

			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + ".opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".opposite") ($oppPrfx + $modName);
			setAttr -l true ("RRM_" + $prfx + $modName + ".opposite");
			
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Parent.pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.pair");
			
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Parent");
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Parent.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.opposite") ($oppPrfx + $modName + "_Parent");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.opposite");		
		}
			
		if (!`objExists ("RRM_" + $modName + ".eyeNum")`)
		{
			//ADD EYE NUM ATTRIBUTE
			addAttr -ln "eyeNum" -at long ("RRM_" + $modName);
			setAttr -e-keyable 1 ("RRM_" + $modName + ".eyeNum");
			setAttr ("RRM_" + $modName + ".eyeNum") $jointsNum;
			setAttr -l true ("RRM_" + $modName + ".eyeNum");
		}

		//X
		string $selectedMod;
		float $xValue = 0;
		rotate -r ($multiplier * -90) -90 0 ("RRM_" + $prfx + $modName);
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName);
		if ($modDirection == 1)
		{
			//CHECK LOCATION
			for ($selectedMod in $attachMod)
			{
			    $modTX = `xform -q -ws -rp $selectedMod`;
			    $xValue = ($xValue + $modTX[0]);
			}
			if ($xValue < 0)
			{
				rotate -r 0 ($multiplier * 180) 0 ("RRM_" + $prfx + $modName);
			}
		}
		if ($modDirection == 4)
		{
			//CHECK LOCATION
			$xValue = 0;
			for ($selectedMod in $attachMod)
			{
			    $modTX = `xform -q -ws -rp $selectedMod`;
			    $xValue = ($xValue + $modTX[0]);
			}
			if ($xValue >= 0)
			{
				rotate -r 0 ($multiplier * 180) 0 ("RRM_" + $prfx + $modName);
			}
		}
		//Y
		if ($modDirection == 2)
		{
			rotate -r -90 0 ($multiplier * 90) ("RRM_" + $prfx + $modName);
		}
		if ($modDirection == 5)
		{
			rotate -r 90 0 ($multiplier * -90) ("RRM_" + $prfx + $modName);
		}		
		//Z
		if ($modDirection == 3)
		{
			rotate -r 0 ($multiplier * -90) 0 ("RRM_" + $prfx + $modName);
		}
		if ($modDirection == 6)
		{
			rotate -r 0 ($multiplier * 90) 0 ("RRM_" + $prfx + $modName);
		}
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName);
		
		//OFFSET FROM CENTER IF NOT ATTACHED TO PAIR		
		if (!`objExists ($attachMod[0] + ".pair")`)
		{
			if ($mirrorMod == 1)
			{
				move -r ($multiplier * 1) 0 0  ("RRM_" + $prfx + $modName + "_Parent");
			}
		}
		makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
				
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Parent.overrideColor") 30;
		
		//ATTACH TO RIG
		int $mirrorCheck = 1;
		RRM_AttachToRig_V1($attachMod[0], $modName, $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);
		
		RRM_CreateProxyLookAt_V12_V1($modName, $jointsNum, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit);

	
		//PARENT CONNECTOR
		RRM_ProxyConnectors_V1($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Parent"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}

	//ADD TOP ATTRIBUTE
	addAttr -ln "top"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".top");
	setAttr -type "string" ("RRM_" + $modName + ".top") "lookAt";
	setAttr -l true ("RRM_" + $modName + ".top");

	//ADD PARENT ATTRIBUTE
	$parentCore = `getAttr ($attachMod[0] + ".core")`;
	addAttr -ln "parent"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".parent");
	setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
	setAttr -l true ("RRM_" + $modName + ".parent");

	//ADD CORE NAME ATTRIBUTE
	addAttr -ln "core"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".core");
	setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
	setAttr -l true ("RRM_" + $modName + ".core");

	//ADD DIRECTION ATTRIBUTE	
	addAttr -ln "direction" -at long ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".direction");
	setAttr ("RRM_" + $modName + ".direction") $modDirection;
	setAttr -l true ("RRM_" + $modName + ".direction");	

	parent ("RRM_" + $modName) $attachMod[0];

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits_V1($xforms);

	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes_V1($modNodes);

	select -cl;
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

global proc RRM_LookAtPrompts_V1_V1(string $modName, int $jointsNum, int $mirrorMod, int $modDirection, int $modDirection2)
{
	if (`size $modName` == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName_V1($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid modName must begin with a letter.\n    The rest of the modName may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text textFieldLookAtModName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this modName. Please use a unique modName\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			if (`size $attachMod` == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`size $attachMod` > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						RRM_CreateProxyLookAt_V1($modName, $jointsNum, $modDirection, $modDirection2, $mirrorMod);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					RRM_CreateProxyLookAt_V1($modName, $jointsNum, $modDirection, $modDirection2, $mirrorMod);
				}
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////Auxiliary///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_CreateProxyAuxiliary_V1(string $modName, int $mirrorMod)
{
	string $crntUnit = `currentUnit -query -linear`;


	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	
	$i = 0;
	while ($i <= $mirrorMod)
	{
		if ($mirrorMod == 0)
		{
			$prfx = "";
			$oppPrfx = "";
		}
		
		//GET OPPOSITE ATTACHMENT
		//if ($i == 1)
		//{
		//	if (`objExists ($attachMod[0] + ".opposite")`)
		//	{
		//		$oppAttach = `getAttr ($attachMod[0] + ".opposite")`;
		//		$attachMod[0] = ("RRM_" + $oppAttach);
		//		$attachModCore = `getAttr ($attachMod[0] + ".core")`;
		//	}
		//}
		
		RRM_CreateProxyModuleProxy_V1($crntUnit);
		scale -r 1.5 1.5 1.5 RRM_Base;
		makeIdentity -apply true -s 1 RRM_Base;
		rename RRM_Base ("RRM_" + $prfx + $modName + "_Aux");
		group -n ("RRM_" + $prfx + $modName) ("RRM_" + $prfx + $modName + "_Aux"); xform -os -piv 0 0 0;
		
		addAttr -ln "modType" -dt "string" ("RRM_" + $prfx + $modName + "_Aux");
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.modType") "auxiliary";
		setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.modType");

		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.core") ($prfx + $modName + "_Aux");
		setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.core");

		addAttr -ln "attachNode"  -dt "string" ("RRM_" + $prfx + $modName + "_Aux");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Aux.attachNode");
		
		//CREATE COLOURED AXES CURVES
		curve  -n ("RRM_" + $prfx + $modName + "_Aux_X") -d 1 -p 0 0 0 -p 1 0 0 -k 0 -k 1 ;
		pickWalk -d down;
		rename ("RRM_" + $prfx + $modName + "_Aux_XShape");
		setAttr ("RRM_" + $prfx + $modName + "_Aux_XShape.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Aux_XShape.overrideColor") 13;
		
		curve -n ("RRM_" + $prfx + $modName + "_Aux_Y") -d 1 -p 0 0 0 -p 0 1 0 -k 0 -k 1 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_Aux_Y")` ("RRM_" + $prfx + $modName + "_Aux_YShape");
		setAttr ("RRM_" + $prfx + $modName + "_Aux_YShape.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Aux_YShape.overrideColor") 14;
		
		curve -n ("RRM_" + $prfx + $modName + "_Aux_Z") -d 1 -p 0 0 0 -p 0 0 1 -k 0 -k 1 ;
		rename `listRelatives -c ("RRM_" + $prfx + $modName + "_Aux_Z")` ("RRM_" + $prfx + $modName + "_Aux_ZShape");
		setAttr ("RRM_" + $prfx + $modName + "_Aux_ZShape.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Aux_ZShape.overrideColor") 6;
		
		parent -r -s ("RRM_" + $prfx + $modName + "_Aux_XShape") ("RRM_" + $prfx + $modName + "_Aux_YShape") ("RRM_" + $prfx + $modName + "_Aux_ZShape")("RRM_" + $prfx + $modName + "_Aux");
		delete ("RRM_" + $prfx + $modName + "_Aux_X") ("RRM_" + $prfx + $modName + "_Aux_Y") ("RRM_" + $prfx + $modName + "_Aux_Z");


		//ADD PINNED ATTRIBUTE
		addAttr -ln "pinned"  -at bool ("RRM_" + $prfx + $modName + "_Aux");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Aux.pinned");
		setAttr ("RRM_" + $prfx + $modName + "_Aux.pinned") 0;
		setAttr -lock 1 ("RRM_" + $prfx + $modName + "_Aux.pinned");
		
		//ADD CONNECTOR VIZ ATTRIBUTE
		addAttr -ln "connectors"  -at bool ("RRM_" + $prfx + $modName + "_Aux");
		setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Aux.connectors");
		setAttr ("RRM_" + $prfx + $modName + "_Aux.connectors") 1;

		if ($mirrorMod ==1)
		{
			if (!`objExists ("RRM_" + $modName)`)
			{
				group -n ("RRM_" + $modName) ("RRM_" + $prfx + $modName); xform -os -piv 0 0 0;
				addAttr -ln "pair"  -dt "string" ("RRM_" + $modName);
				setAttr -e-keyable 1 ("RRM_" + $modName + ".pair");
				setAttr -l true ("RRM_" + $modName + ".pair");

			}
			else
			{
				parent  ("RRM_" + $prfx + $modName) ("RRM_" + $modName); xform -os -piv 0 0 0;
			}
			
			//MIRROR ATTRIBUTES
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + ".pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + ".pair");

			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName);
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + ".opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + ".opposite") ($oppPrfx + $modName);
			setAttr -l true ("RRM_" + $prfx + $modName + ".opposite");
			
			addAttr -ln "pair"  -dt "string" ("RRM_" + $prfx + $modName + "_Aux");
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Aux.pair");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.pair") $crntSide;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.pair");
			
			addAttr -ln "opposite"  -dt "string" ("RRM_" + $prfx + $modName + "_Aux");
			setAttr -e-keyable 1 ("RRM_" + $prfx + $modName + "_Aux.opposite");
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.opposite") ($oppPrfx + $modName + "_Aux");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Aux.opposite");		
		}
		
		//ATTACH TO RIG
		int $mirrorCheck = 1;
		RRM_AttachToRig_V1($attachMod[0], $modName, $prfx, $crntSide, $oppSide, $attachModCore, $mirrorMod, $mirrorCheck);
		
		
		//makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_Parent");
				
		setAttr ("RRM_" + $prfx + $modName + "_Aux.overrideEnabled") 1;
		setAttr ("RRM_" + $prfx + $modName + "_Aux.overrideColor") 24;
		
		//RRM_CreateProxyLookAt_V12_V1($modName, $jointsNum, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit);

	
		//PARENT CONNECTOR
		RRM_ProxyConnectors_V1($modName, $prfx, $attachMod[0], ("RRM_" + $prfx + $modName + "_Aux"));
	
		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}

	//ADD TOP ATTRIBUTE
	addAttr -ln "top"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".top");
	setAttr -type "string" ("RRM_" + $modName + ".top") "auxiliary";
	setAttr -l true ("RRM_" + $modName + ".top");

	//ADD PARENT ATTRIBUTE
	$parentCore = `getAttr ($attachMod[0] + ".core")`;
	addAttr -ln "parent"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".parent");
	setAttr -type "string" ("RRM_" + $modName + ".parent") $parentCore;
	setAttr -l true ("RRM_" + $modName + ".parent");

	//ADD CORE NAME ATTRIBUTE
	addAttr -ln "core"  -dt "string"  ("RRM_" + $modName);
	setAttr -e-keyable 1 ("RRM_" + $modName + ".core");
	setAttr -type "string" ("RRM_" + $modName + ".core") $modName;
	setAttr -l true ("RRM_" + $modName + ".core");

	parent ("RRM_" + $modName) $attachMod[0];

	//ADD MOD NAME ATTRIBUTE
	$nodes = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			setAttr -type "string" ($each + ".modName") $modName;
			setAttr -l true ($each + ".modName");
		}
	}

	//SET LIMITS OF HIERARCHY
	$xforms = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	RRM_ProxyLimits_V1($xforms);

	$modNodes = `listRelatives -ad ("RRM_" + $modName)`;
	RRM_ProxyLockNodes_V1($modNodes);

	select -cl;
	
	if (`objExists ("RRM_l_" + $modName + "_Aux")`)
	{
		move -r 1 0 0 ("RRM_l_" + $modName + "_Aux");
		move -r -1 0 0 ("RRM_r_" + $modName + "_Aux");
		select ("RRM_l_" + $modName + "_Aux") ("RRM_r_" + $modName + "_Aux");
	}
	else if (`objExists ("RRM_" + $modName + "_Aux")`)
		{select ("RRM_" + $modName + "_Aux");}
}

global proc RRM_AuxiliaryPrompts_V1(string $modName, int $mirrorMod)
{
	if (`size $modName` == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the module Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName_V1($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid modName must begin with a letter.\n    The rest of the modName may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $modName = `textField -q -text textFieldAuxiliaryModName`;
	
		if (`objExists ("RRM_" + $modName)`)
		{
			string $returnVal_Generate = `confirmDialog
				-title "Name is Not Unique"
				-message "Module already exists with this modName. Please use a unique modName\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
		}
		else
		{
			$attachMod = `ls -sl`;
			string $attachModCore;
			if (`size $attachMod` == 0)
			{
				string $returnVal_Generate = `confirmDialog
						-title "No Attachment Selected"
						-message "Please select a module node to attach your spline to.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
				$attachModCore = `getAttr ($attachMod[0] + ".core")`;
			}
			else if (!`objExists ($attachMod[0]+ ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to the selected object.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`objExists ($attachMod[0]+ ".noAttach")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Attach Node"
					-message "You cannot attach to a Parent node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if (`size $attachMod` > 1)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Multiple Attachments Selected"
					-message "You can only attach to one object. Attach to first selected module?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					if ($attachMod[0] == "RRM_MAIN")
					{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
					}
					else
					{
						RRM_CreateProxyAuxiliary_V1($modName, $mirrorMod);
					}
				}
			}
			else
			{
				if ($attachMod[0] == "RRM_MAIN")
				{
					string $returnVal_Generate = `confirmDialog
						-title "Invalid Attach Node"
						-message "You cannot attach modules to RRM_MAIN.\n"
							-button "OK"
							-defaultButton "OK"
							-cancelButton "OK"
							-icon "critical"`;
				}
				else
				{
					RRM_CreateProxyAuxiliary_V1($modName, $mirrorMod);
				}
			}
		}
	}
}



//OVERRIDE COLOUR
global proc RRM_ProxyOverrideColor_V1(int $colorVal)
{
	$selection = `ls -sl -type "transform"`;
	for ($each in $selection)
	{
		//MAKE SURE EACH IN SELECTION IS A VALID PROXY
		if (`objExists ($each + ".modName")`)
		{
			$modName = `getAttr ($each + ".modName")`;
			$modNodes = `ls -type "transform" ("RRM_*" + $modName + "*")`;
			//MAKE SURE NODE IS PART OF THE SELECTED MODULE
			for ($each2 in $modNodes)
			{
				//VALIDATE EACH IS PART OF THE MODULE OF THE INITIAL SELECTED BRANCH
				if (`objExists ($each2 + ".modName")`)
				{
					$checkModName = `getAttr ($each2 + ".modName")`;
					if ($checkModName == $modName)
					{
						//CHECK IF IT IS RESET
						if ($colorVal == 0)
						{
							string $modType =`getAttr ("RRM_" + $checkModName + ".top")`;
							if ($modType == "spline")
							{
								setAttr ($each2 + ".overrideColor") 29;
							}
							else if ($modType == "arm")
							{
								setAttr ($each2 + ".overrideColor") 7;
							}
							else if ($modType == "leg")
							{
								setAttr ($each2 + ".overrideColor") 31;
							}
							else if ($modType == "fkChain")
							{
								setAttr ($each2 + ".overrideColor") 9;
							}
							else if ($modType == "head")
							{
								setAttr ($each2 + ".overrideColor") 4;
							}
							else if ($modType == "lookAt")
							{
								setAttr ($each2 + ".overrideColor") 30;
							}
						}
						else
						{
							setAttr ($each2 + ".overrideColor") $colorVal;
						}
					}
				}
			}
		}
	}
	select $selection;
}
////////////////////////////////////////////////////////////////////////////////
//////////////////////////////RENAME MODULE/////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//RENAME MODULE	
global proc RRM_Rename_V1(string $name, string $selection, int $call)
{
	//string $crntUnit = `currentUnit -query -linear`;
	
	string $modName;
	string $modType;
	string $attachNode;
	string $side;
	string $ext;
	
	string $eachModName;
	
	if ($call == 0)
	{
		$modName = `getAttr ($selection + ".modName")`;
		$modType = `getAttr ("RRM_" + $modName + ".top")`;
		$attachNode = `getAttr ("RRM_" + $modName + ".parent")`;
	}
	else
	{
		$modName = `getAttr ("RRM_" + $selection + ".core")`;
		$modType = `getAttr ("RRM_" + $selection + ".top")`;
		//ORIGINAL MODULE'S ATTACH NODE
		$sourceAttachNode = `getAttr ("RRM_" + $modName + ".parent")`;

		//GET ATTACH NODE'S CLONED ATTRIBUTE
		string $cloneName = `getAttr ("RRM_" + $sourceAttachNode + ".clone")`;
		if (`gmatch $cloneName ""`)
		{//ATTACH NODE IS NOT A CLONE
			$attachNode = ($sourceAttachNode);
		}
		else
		{//ATTACH NODE IS A CLONE
			$attachNode = `getAttr ("RRM_" + $sourceAttachNode + ".clone")`;
		}
	}
	string $clonedParentNodes[];	

	int $mirrorMod = 1;
	string $prfx = "l_";
	string $prfxReset = "l_";
	if (!`objExists ("RRM_" + $modName + ".pair")`)
	{
		$mirrorMod = 0;
		$prfx = "";
		$prfxReset = "";
	}
	int $firstTimeThrough;

	//CHECK IF SPLINE
	if (`gmatch $modType "spline"`)
	{
		RRM_Clone_V1_Spline_V1($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "arm"`)
	{//CHECK IF ARM
		RRM_Clone_V1_Arm_V1($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "leg"`)
	{//CHECK IF LEG
		RRM_Clone_V1_Leg_V1($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "fkChain"`)
	{//CHECK IF FKCHAIN
		RRM_Clone_V1_FkChain_V1($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "head"`)
	{//CHECK IF HEAD
		RRM_Clone_V1_Head_V1($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "lookAt"`)
	{//CHECK IF LOOKAT
		RRM_Clone_V1_LookAt_V1($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "auxiliary"`)
	{//CHECK IF AUXILIARY
		RRM_Clone_V1_Auxiliary_V1($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
		
	if ($call <= 1)
	{
		//CHECK TO SEE IF IT IS NOT AN AUXILIARY
		if (!`objExists ("RRM_" + $name + "_Aux")` && !`objExists ("RRM_l_" + $name + "_Aux")`)
		{
			spaceLocator -n ("RRM_Clone_V1_Lctr");
			addAttr -ln "topCloneNode"  -dt "string" "RRM_Clone_V1_Lctr";
			setAttr -e-keyable 1 "RRM_Clone_V1_Lctr.topCloneNode";
			setAttr -type "string" "RRM_Clone_V1_Lctr.topCloneNode" ("RRM_" + $name + "_Parent");
			if (!`objExists ("RRM_" + $name + "_Parent")`)
			{
				setAttr -type "string" "RRM_Clone_V1_Lctr.topCloneNode" ("RRM_l_" + $name + "_Parent");
			}
		}
		else
		{
			spaceLocator -n ("RRM_Clone_V1_Lctr");
			addAttr -ln "topCloneNode"  -dt "string" "RRM_Clone_V1_Lctr";
			setAttr -e-keyable 1 "RRM_Clone_V1_Lctr.topCloneNode";
			setAttr -type "string" "RRM_Clone_V1_Lctr.topCloneNode" ("RRM_" + $name + "_Aux");
			if (!`objExists ("RRM_" + $name + "_Aux")`)
			{
				setAttr -type "string" "RRM_Clone_V1_Lctr.topCloneNode" ("RRM_l_" + $name + "_Aux");
			}
		}			
	}
	
	//FIND CHILDREN MODULES AND ATTACH TO RENAMED DUPLICATE
	$hierarchy = `listRelatives -ad -type "transform" ("RRM_" + $modName)`;
	string $prfx = "";
	int $childModCount = 0;
	for ($each in $hierarchy)
	{
		if (`objExists ($each + ".parent")` && !`objExists ($each + ".top")`)
		{//VERIFY IT IS A PARENT
			$attachNode = `getAttr ($each + ".attachNode")`;
			if (`objExists ("RRM_" + $attachNode + ".pair")`)
			{
				$prfx = `getAttr ("RRM_" + $attachNode + ".pair")`;
				if (`gmatch $prfx "left"`)
					{$prfx = "l_";}
				else if (`gmatch $prfx "right"`)
					{$prfx = "r_";}
			}
			if (`gmatch ($attachNode + "*") ($prfx + $modName + "*")`)
			{//MAKE SURE IT IS A PARENT NODE ATTACHED TO THE RENAMED MODULE
				$eachModName = `getAttr ($each + ".modName")`;
				if (!`gmatch $modName $eachModName`)
				{//MAKE SURE IT IS NOT A PARENT NODE OF THE RENAMED MODULE
					string $attachNode_Ext = `getAttr ("RRM_" + $attachNode + ".ext")`;
					if (`objExists ("RRM_" + $prfx + $name + $attachNode_Ext)`)
					{//ONLY ATTACH IF IT IS A DIRECT CHILD MODULE OF THE RENAMED MODULE
						select ("RRM_" + $prfx + $name + $attachNode_Ext);
						select $each;
						RRM_AttachToNewModule_V1(("RRM_" + $prfx + $name + $attachNode_Ext));
					}
					$childModCount++;
				}
			}
		}
	}
	//DELETE ORIGINAL MODULE
	select $selection;
	RRM_DeleteBranch_V1Prompts_V1();
}

global proc RRM_Rename_V1Prompts_V1(string $name)
{
	string $selection[] = `ls -sl`;
	string $coreCheck;
	if (`objExists ($selection[0] + ".core")`)
	{
		$coreCheck = `getAttr ($selection[0] + ".core")`;
	}
	
	if (`size $selection` == 0)
	{//CHECK THAT SOMETHING IS SELECTED
		string $returnVal_Generate = `confirmDialog
			-title "Nothing Selected"
			-message "You must select a node of the desired module to rename.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`size $selection` > 1)
	{//CHECK THAT ONLY ONE OBJECT IS SELECTED
		string $returnVal_Generate = `confirmDialog
			-title "Only One Module May Be Cloned At A Time"
			-message "You must select only one node of a desired module to rename.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (!`objExists ($selection[0] + ".core")`)
	{//CHECK TO MAKE SURE OBJECT IS A VALID MODULE
		string $returnVal_Generate = `confirmDialog
			-title "Not a Valid Node"
			-message "You must select one node of a desired module to rename.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
	}
	
	else if (`gmatch $coreCheck "MAIN"` || `gmatch $coreCheck "ROOT"`)
	{//CHECK TO MAKE SURE OBJECT IS NOT MAIN OR ROOT
		string $returnVal_Generate = `confirmDialog
			-title "Not a Valid Node"
			-message "You cannot rename the MAIN or ROOT modules.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
	}

	else if (`size $name` == "0")
	{//CHECK TO MAKE SURE THE USER HAS INPUT A NAME
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the rename.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	
	else if (! RRM_CheckName_V1($name))
	{//CHECK TO MAKE SURE A VALID NAME HAS BEEN USED
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid name must begin with a letter.\n    The rest of the name may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ("RRM_" + $name)`)
	{//CHECK TO MAKE SURE NAME DOES NOT CONFLICT WITH EXISTING OBJECT
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is not Unique"
			-message "A module already exists with that name.\nYou must create a unique name.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		print "renaming...\n";
		string $parentNullName = "";
		RRM_Rename_V1($name, $selection[0], 0);
	}
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////CLONE MODULE/////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
//CLONE SPLINE
global proc RRM_Clone_V1_Spline_V1(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	//GET NUMBER OF JOINTS AND TWIST AXIS
	int $splineNum = `getAttr ("RRM_" + $modName + ".jointsNum")`;
	int $twistAxis = 2;
	string $twistString = "Y-axis";
	if (`objExists ("RRM_" + $modName + ".twistAxis")`)
	{
		int $twistAxis = `getAttr ("RRM_" + $modName + ".twistAxis")`;
		if ($twistAxis == 1)
		{
			$twistString = "X-axis";
		}
	}
	int $i = 0;

	while ($i <= $mirrorMod)
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Top_Lctr");
		$topPos   = `getAttr ("RRM_" + $prfx + $modName + "_Top.translate")`;
		$topRot   = `getAttr ("RRM_" + $prfx + $modName + "_Top.rotate")`;
		$topScale = `getAttr ("RRM_" + $prfx + $modName + "_Top.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.translate"), $topPos[0], $topPos[1], $topPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.rotate"), $topRot[0], $topRot[1], $topRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.scale"), $topScale[0], $topScale[1], $topScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.clone") ($prfx + $name + "_Top");

		//WHILE LOOP
		int $i2 = 1;
		while ($i2 <= $splineNum)
		{
			string $nPd = "_0";
			if ($i2 >= 10)
			{
				string $nPd = "_";
			}
			//TRANSFORMS LOCATOR
			spaceLocator -n ("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr");
			$eachPos   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".translate")`;
			$eachRot   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".rotate")`;
			$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".scale")`;
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $i2 + ".clone") ($prfx + $name + $nPd + $i2);
			
			$i2++;
		}
		$prfx = "r_";
		$i++;
	}

	//GENERATE NEW SPLINE
	select ("RRM_" + $attachNode);
	RRM_CreateProxySpline_V1($name, $splineNum, $twistAxis, $mirrorMod);
	
	$clonedParentNodes = `ls -sl`;
	
	
	//RESET VARIABLES
	$i = 0;
	$prfx = $prfxReset;
	
		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS
	
		//MOVE NODES TO LOCATORS
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		
	
		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");
	
		$topPos   = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.translate")`;
		$topRot   = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.rotate")`;		
		$topScale = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.scale")`;		
	
		setAttr (("RRM_" + $prfx + $name + "_Top.translate"), $topPos[0], $topPos[1], $topPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Top.rotate"), $topRot[0], $topRot[1], $topRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Top.scale"), $topScale[0], $topScale[1], $topScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Top_Lctr");
	
		$i3 = 1;
		while ($i3 <= $splineNum)
		{
			string $nPd = "_0";
			if ($i3 >= 10)
			{
				string $nPd = "_";
			}
			//MOVE PROXY TO LOCATOR
			$eachPos   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.translate")`;
			$eachRot   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.rotate")`;		
			$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.scale")`;		
			
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
			delete ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr");
			$i3++;
		}
		$prfx = "r_";
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}

global proc RRM_Clone_V1_Arm_V1(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	print "Cloning arm...\n";
	//GET NUMBER OF JOINTS
	int $upperArmNum = `getAttr ("RRM_" + $modName + ".upperArmNum")`;
	int $lowerArmNum = `getAttr ("RRM_" + $modName + ".lowerArmNum")`;
	int $elbowNum    = `getAttr ("RRM_" + $modName + ".elbowNum")`;
	int $elbowJoints = `getAttr ("RRM_" + $modName + ".elbowJoints")`;
	int $toon = 0;
	if (`objExists ("RRM_" + $modName + ".toon")`)
	{
		$toon = `getAttr ("RRM_" + $modName + ".toon")`;
	}
	$mirrorMod       = 2;
	$prfx            = "l_";
	$prfxReset       = "l_";
	
	if (`objExists ("RRM_" + $modName + ".single")`)
	{
		$prfx = "";
		$prfxReset = "";
		$checkSide = `getAttr ("RRM_" + $modName + ".single")`;
		if ($checkSide == "left")
		{
			$mirrorMod = 1;
		}
		else if ($checkSide == "right")
		{
			$mirrorMod = 3;
		}
	}
	int $i = 1;

	string $clonedParentNodes[];	
	
	while ($prfx != "end")
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Clavicle_Lctr");
		$clavPos   = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle.translate")`;
		$clavRot   = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle.rotate")`;
		$clavScale = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Clavicle_Lctr.translate"), $clavPos[0], $clavPos[1], $clavPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Clavicle_Lctr.rotate"), $clavRot[0], $clavRot[1], $clavRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Clavicle_Lctr.scale"), $clavScale[0], $clavScale[1], $clavScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Clavicle.clone") ($prfx + $name + "_Clavicle");
		
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Shoulder_Lctr");
		$shldrPos   = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder.translate")`;
		$shldrRot   = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder.rotate")`;
		$shldrScale = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Shoulder_Lctr.translate"), $shldrPos[0], $shldrPos[1], $shldrPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Shoulder_Lctr.rotate"), $shldrRot[0], $shldrRot[1], $shldrRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Shoulder_Lctr.scale"), $shldrScale[0], $shldrScale[1], $shldrScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Shoulder.clone") ($prfx + $name + "_Shoulder");
		
		if ($elbowJoints == 1)
		{
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Elbow_Lctr");
			$elbowPos   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow.translate")`;
			$elbowRot   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow.rotate")`;
			$elbowScale = `getAttr ("RRM_" + $prfx + $modName + "_Elbow.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Elbow_Lctr.translate"), $elbowPos[0], $elbowPos[1], $elbowPos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow_Lctr.rotate"), $elbowRot[0], $elbowRot[1], $elbowRot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow_Lctr.scale"), $elbowScale[0], $elbowScale[1], $elbowScale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow.clone") ($prfx + $name + "_Elbow");
		}
		else
		{
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Elbow1_Lctr");
			$elbow1Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow1.translate")`;
			$elbow1Rot   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow1.rotate")`;
			$elbow1Scale = `getAttr ("RRM_" + $prfx + $modName + "_Elbow1.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Elbow1_Lctr.translate"), $elbow1Pos[0], $elbow1Pos[1], $elbow1Pos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow1_Lctr.rotate"), $elbow1Rot[0], $elbow1Rot[1], $elbow1Rot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow1_Lctr.scale"), $elbow1Scale[0], $elbow1Scale[1], $elbow1Scale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow1.clone") ($prfx + $name + "_Elbow1");
		
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Elbow2_Lctr");
			$elbow2Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2.translate")`;
			$elbow2Rot   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2.rotate")`;
			$elbow2Scale = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Elbow2_Lctr.translate"), $elbow2Pos[0], $elbow2Pos[1], $elbow2Pos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow2_Lctr.rotate"), $elbow2Rot[0], $elbow2Rot[1], $elbow2Rot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Elbow2_Lctr.scale"), $elbow2Scale[0], $elbow2Scale[1], $elbow2Scale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Elbow2.clone") ($prfx + $name + "_Elbow2");
		}
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Wrist_Lctr");
		$wristPos   = `getAttr ("RRM_" + $prfx + $modName + "_Wrist.translate")`;
		$wristRot   = `getAttr ("RRM_" + $prfx + $modName + "_Wrist.rotate")`;
		$wristScale = `getAttr ("RRM_" + $prfx + $modName + "_Wrist.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Wrist_Lctr.translate"), $wristPos[0], $wristPos[1], $wristPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Wrist_Lctr.rotate"), $wristRot[0], $wristRot[1], $wristRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Wrist_Lctr.scale"), $wristScale[0], $wristScale[1], $wristScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Wrist.clone") ($prfx + $name + "_Wrist");			

		if ($prfx == "l_")
		{//SWITCH TO RIGHT
			$prfx = "r_";
		}
		else if ($prfx == "r_"|| $prfx == "")
		{//SWITCH TO END
			$prfx = "end";
		}
	}
	
	//GENERATE NEW ARM(S)
	select ("RRM_" + $attachNode);
	//RRM_CreateProxySpline_V1($name, $splineNum, $mirrorMod);
	RRM_CreateProxyArm_V1($name, $upperArmNum, $lowerArmNum, $elbowNum, $elbowJoints, $toon, $mirrorMod);

	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$prfx = $prfxReset;
		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS

		//MOVE NODES TO LOCATORS
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");

		$clavPos   = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle_Lctr.translate")`;
		$clavRot   = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle_Lctr.rotate")`;		
		$clavScale = `getAttr ("RRM_" + $prfx + $modName + "_Clavicle_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Clavicle.translate"), $clavPos[0], $clavPos[1], $clavPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Clavicle.rotate"), $clavRot[0], $clavRot[1], $clavRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Clavicle.scale"), $clavScale[0], $clavScale[1], $clavScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Clavicle_Lctr");

		$shldrPos   = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder_Lctr.translate")`;
		$shldrRot   = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder_Lctr.rotate")`;		
		$shldrScale = `getAttr ("RRM_" + $prfx + $modName + "_Shoulder_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Shoulder.translate"), $shldrPos[0], $shldrPos[1], $shldrPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Shoulder.rotate"), $shldrRot[0], $shldrRot[1], $shldrRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Shoulder.scale"), $shldrScale[0], $shldrScale[1], $shldrScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Shoulder_Lctr");

			
		if ($elbowJoints == 1)
		{
			$elbowPos   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow_Lctr.translate")`;
			$elbowRot   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow_Lctr.rotate")`;		
			$elbowScale = `getAttr ("RRM_" + $prfx + $modName + "_Elbow_Lctr.scale")`;		

			setAttr (("RRM_" + $prfx + $name + "_Elbow.translate"), $elbowPos[0], $elbowPos[1], $elbowPos[2]);
			delete ("RRM_" + $prfx + $modName + "_Elbow_Lctr");
		}
		else
		{
			$elbow1Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow1_Lctr.translate")`;

			setAttr (("RRM_" + $prfx + $name + "_Elbow1.translate"), $elbow1Pos[0], $elbow1Pos[1], $elbow1Pos[2]);
			delete ("RRM_" + $prfx + $modName + "_Elbow1_Lctr");

			$elbow2Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2_Lctr.translate")`;
			$elbow2Rot   = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2_Lctr.rotate")`;		

			setAttr (("RRM_" + $prfx + $name + "_Elbow2.translate"), $elbow2Pos[0], $elbow2Pos[1], $elbow2Pos[2]);
			setAttr ("RRM_" + $prfx + $name + "_Elbow2.rotateX") $elbow2Rot[0];
			delete ("RRM_" + $prfx + $modName + "_Elbow2_Lctr");
		}

		$wristPos   = `getAttr ("RRM_" + $prfx + $modName + "_Wrist_Lctr.translate")`;
		$wristRot   = `getAttr ("RRM_" + $prfx + $modName + "_Wrist_Lctr.rotate")`;		
		$wristScale = `getAttr ("RRM_" + $prfx + $modName + "_Wrist_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Wrist.translate"), $wristPos[0], $wristPos[1], $wristPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Wrist.rotate"), $wristRot[0], $wristRot[1], $wristRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Wrist.scale"), $wristScale[0], $wristScale[1], $wristScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Wrist_Lctr");

		$prfx = "r_";
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}

global proc RRM_Clone_V1_Leg_V1(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	//GET NUMBER OF JOINTS
	int $upperLegNum = `getAttr ("RRM_" + $modName + ".upperLegNum")`;
	int $lowerLegNum = `getAttr ("RRM_" + $modName + ".lowerLegNum")`;
	int $kneeNum    = `getAttr ("RRM_" + $modName + ".kneeNum")`;
	int $kneeJoints = `getAttr ("RRM_" + $modName + ".kneeJoints")`;
	int $toon = 0;
	if (`objExists ("RRM_" + $modName + ".toon")`)
	{
		$toon = `getAttr ("RRM_" + $modName + ".toon")`;
	}
	$mirrorMod       = 2;
	$prfx            = "l_";
	$prfxReset       = "l_";
	
	if (`objExists ("RRM_" + $modName + ".single")`)
	{
		$prfx = "";
		$prfxReset = "";
		$checkSide = `getAttr ("RRM_" + $modName + ".single")`;
		if ($checkSide == "left")
		{
			$mirrorMod = 1;
		}
		else if ($checkSide == "right")
		{
			$mirrorMod = 3;
		}
	}
	int $i = 1;

	string $clonedParentNodes[];	
	
	while ($i <= $mirrorMod)
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Hip_Lctr");
		$hipPos   = `getAttr ("RRM_" + $prfx + $modName + "_Hip.translate")`;
		$hipRot   = `getAttr ("RRM_" + $prfx + $modName + "_Hip.rotate")`;
		$hipScale = `getAttr ("RRM_" + $prfx + $modName + "_Hip.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Hip_Lctr.translate"), $hipPos[0], $hipPos[1], $hipPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Hip_Lctr.rotate"), $hipRot[0], $hipRot[1], $hipRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Hip_Lctr.scale"), $hipScale[0], $hipScale[1], $hipScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Hip.clone") ($prfx + $name + "_Hip");
			
		if ($kneeJoints == 1)
		{
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Knee_Lctr");
			$kneePos   = `getAttr ("RRM_" + $prfx + $modName + "_Knee.translate")`;
			$kneeRot   = `getAttr ("RRM_" + $prfx + $modName + "_Knee.rotate")`;
			$kneeScale = `getAttr ("RRM_" + $prfx + $modName + "_Knee.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Knee_Lctr.translate"), $kneePos[0], $kneePos[1], $kneePos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee_Lctr.rotate"), $kneeRot[0], $kneeRot[1], $kneeRot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee_Lctr.scale"), $kneeScale[0], $kneeScale[1], $kneeScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee.clone") ($prfx + $name + "_Knee");
		}
		else
		{
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Knee1_Lctr");
			$knee1Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Knee1.translate")`;
			$knee1Rot   = `getAttr ("RRM_" + $prfx + $modName + "_Knee1.rotate")`;
			$knee1Scale = `getAttr ("RRM_" + $prfx + $modName + "_Knee1.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Knee1_Lctr.translate"), $knee1Pos[0], $knee1Pos[1], $knee1Pos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee1_Lctr.rotate"), $knee1Rot[0], $knee1Rot[1], $knee1Rot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee1_Lctr.scale"), $knee1Scale[0], $knee1Scale[1], $knee1Scale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee1.clone") ($prfx + $name + "_Knee1");
			
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Knee2_Lctr");
			$knee2Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Knee2.translate")`;
			$knee2Rot   = `getAttr ("RRM_" + $prfx + $modName + "_Knee2.rotate")`;
			$knee2Scale = `getAttr ("RRM_" + $prfx + $modName + "_Knee2.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Knee2_Lctr.translate"), $knee2Pos[0], $knee2Pos[1], $knee2Pos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee2_Lctr.rotate"), $knee2Rot[0], $knee2Rot[1], $knee2Rot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Knee2_Lctr.scale"), $knee2Scale[0], $knee2Scale[1], $knee2Scale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Knee2.clone") ($prfx + $name + "_Knee2");
		}
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Ankle_Lctr");
		$anklePos   = `getAttr ("RRM_" + $prfx + $modName + "_Ankle.translate")`;
		$ankleRot   = `getAttr ("RRM_" + $prfx + $modName + "_Ankle.rotate")`;
		$ankleScale = `getAttr ("RRM_" + $prfx + $modName + "_Ankle.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Ankle_Lctr.translate"), $anklePos[0], $anklePos[1], $anklePos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ankle_Lctr.rotate"), $ankleRot[0], $ankleRot[1], $ankleRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ankle_Lctr.scale"), $ankleScale[0], $ankleScale[1], $ankleScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ankle.clone") ($prfx + $name + "_Ankle");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Ball_Lctr");
		$ballPos   = `getAttr ("RRM_" + $prfx + $modName + "_Ball.translate")`;
		$ballRot   = `getAttr ("RRM_" + $prfx + $modName + "_Ball.rotate")`;
		$ballScale = `getAttr ("RRM_" + $prfx + $modName + "_Ball.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Ball_Lctr.translate"), $ballPos[0], $ballPos[1], $ballPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ball_Lctr.rotate"), $ballRot[0], $ballRot[1], $ballRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ball_Lctr.scale"), $ballScale[0], $ballScale[1], $ballScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ball.clone") ($prfx + $name + "_Ball");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Toe_Lctr");
		$toePos   = `getAttr ("RRM_" + $prfx + $modName + "_Toe.translate")`;
		$toeRot   = `getAttr ("RRM_" + $prfx + $modName + "_Toe.rotate")`;
		$toeScale = `getAttr ("RRM_" + $prfx + $modName + "_Toe.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Toe_Lctr.translate"), $toePos[0], $toePos[1], $toePos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Toe_Lctr.rotate"), $toeRot[0], $toeRot[1], $toeRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Toe_Lctr.scale"), $toeScale[0], $toeScale[1], $toeScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Toe.clone") ($prfx + $name + "_Toe");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_HeelPivot_Lctr");
		$heelPivPos   = `getAttr ("RRM_" + $prfx + $modName + "_HeelPivot.translate")`;
		setAttr ("RRM_" + $prfx + $modName + "_HeelPivot_Lctr.tx") $heelPivPos[0];
		setAttr ("RRM_" + $prfx + $modName + "_HeelPivot_Lctr.tz") $heelPivPos[2];
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_HeelPivot.clone") ($prfx + $name + "_HeelPivot");
		
		spaceLocator -n ("RRM_" + $prfx + $modName + "_FootLeftTilt_Lctr");
		$lTiltPos   = `getAttr ("RRM_" + $prfx + $modName + "_FootLeftTilt.translate")`;
		setAttr ("RRM_" + $prfx + $modName + "_FootLeftTilt_Lctr.tx") $lTiltPos[0];
		setAttr ("RRM_" + $prfx + $modName + "_FootLeftTilt_Lctr.tz") $lTiltPos[2];
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootLeftTilt.clone") ($prfx + $name + "_FootLeftTilt");
		
		spaceLocator -n ("RRM_" + $prfx + $modName + "_FootRightTilt_Lctr");
		$rTiltPos   = `getAttr ("RRM_" + $prfx + $modName + "_FootRightTilt.translate")`;
		setAttr ("RRM_" + $prfx + $modName + "_FootRightTilt_Lctr.tx") $rTiltPos[0];
		setAttr ("RRM_" + $prfx + $modName + "_FootRightTilt_Lctr.tz") $rTiltPos[2];
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_FootRightTilt.clone") ($prfx + $name + "_FootRightTilt");
			
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Ground_Lctr");
		$grndPos   = `getAttr ("RRM_" + $prfx + $modName + "_Ground.translate")`;
		$grndRot   = `getAttr ("RRM_" + $prfx + $modName + "_Ground.rotate")`;
		$grndScale = `getAttr ("RRM_" + $prfx + $modName + "_Ground.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Ground_Lctr.translate"), $grndPos[0], $grndPos[1], $grndPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ground_Lctr.rotate"), $grndRot[0], $grndRot[1], $grndRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Ground_Lctr.scale"), $grndScale[0], $grndScale[1], $grndScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Ground.clone") ($prfx + $name + "_Ground");
		
		
		if ($prfx == "l_")
		{//SWITCH TO RIGHT
			$prfx = "r_";
		}
		$i++;
	}
	
	//GENERATE NEW LEG(S)
	select ("RRM_" + $attachNode);
	RRM_CreateProxyLeg_V1($name, $upperLegNum, $lowerLegNum, $kneeNum, $kneeJoints, $toon, $mirrorMod);

	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$prfx = $prfxReset;
	$i = 1;
		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS

		//MOVE NODES TO LOCATORS
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");

		$hipPos   = `getAttr ("RRM_" + $prfx + $modName + "_Hip_Lctr.translate")`;
		$hipRot   = `getAttr ("RRM_" + $prfx + $modName + "_Hip_Lctr.rotate")`;		
		$hipScale = `getAttr ("RRM_" + $prfx + $modName + "_Hip_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Hip.translate"), $hipPos[0], $hipPos[1], $hipPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Hip.rotate"), $hipRot[0], $hipRot[1], $hipRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Hip.scale"), $hipScale[0], $hipScale[1], $hipScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Hip_Lctr");

			
		if ($kneeJoints == 1)
		{
			$kneePos   = `getAttr ("RRM_" + $prfx + $modName + "_Knee_Lctr.translate")`;
			$kneeRot   = `getAttr ("RRM_" + $prfx + $modName + "_Knee_Lctr.rotate")`;		

			setAttr (("RRM_" + $prfx + $name + "_Knee.translate"), $kneePos[0], $kneePos[1], $kneePos[2]);
			delete ("RRM_" + $prfx + $modName + "_Knee_Lctr");
		}
		else
		{
			$knee1Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Knee1_Lctr.translate")`;
			$knee1Rot   = `getAttr ("RRM_" + $prfx + $modName + "_Knee1_Lctr.rotate")`;		

			setAttr (("RRM_" + $prfx + $name + "_Knee1.translate"), $knee1Pos[0], $knee1Pos[1], $knee1Pos[2]);
			delete ("RRM_" + $prfx + $modName + "_Knee1_Lctr");

			$knee2Pos   = `getAttr ("RRM_" + $prfx + $modName + "_Knee2_Lctr.translate")`;
			$knee2Rot   = `getAttr ("RRM_" + $prfx + $modName + "_Knee2_Lctr.rotate")`;		
			$knee2Scale = `getAttr ("RRM_" + $prfx + $modName + "_Knee2_Lctr.scale")`;		

			setAttr (("RRM_" + $prfx + $name + "_Knee2.translate"), $knee2Pos[0], $knee2Pos[1], $knee2Pos[2]);
			setAttr ("RRM_" + $prfx + $name + "_Knee2.rotateY") $knee2Rot[1];
			delete ("RRM_" + $prfx + $modName + "_Knee2_Lctr");
		}

		$anklePos   = `getAttr ("RRM_" + $prfx + $modName + "_Ankle_Lctr.translate")`;
		$ankleRot   = `getAttr ("RRM_" + $prfx + $modName + "_Ankle_Lctr.rotate")`;		
		$ankleScale = `getAttr ("RRM_" + $prfx + $modName + "_Ankle_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Ankle.translate"), $anklePos[0], $anklePos[1], $anklePos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ankle.rotate"), $ankleRot[0], $ankleRot[1], $ankleRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ankle.scale"), $ankleScale[0], $ankleScale[1], $ankleScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Ankle_Lctr");


		$ballPos   = `getAttr ("RRM_" + $prfx + $modName + "_Ball_Lctr.translate")`;
		$ballRot   = `getAttr ("RRM_" + $prfx + $modName + "_Ball_Lctr.rotate")`;		
		$ballScale = `getAttr ("RRM_" + $prfx + $modName + "_Ball_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Ball.translate"), $ballPos[0], $ballPos[1], $ballPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ball.rotate"), $ballRot[0], $ballRot[1], $ballRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ball.scale"), $ballScale[0], $ballScale[1], $ballScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Ball_Lctr");

		$toePos   = `getAttr ("RRM_" + $prfx + $modName + "_Toe_Lctr.translate")`;
		$toeRot   = `getAttr ("RRM_" + $prfx + $modName + "_Toe_Lctr.rotate")`;		
		$toeScale = `getAttr ("RRM_" + $prfx + $modName + "_Toe_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Toe.translate"), $toePos[0], $toePos[1], $toePos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Toe.rotate"), $toeRot[0], $toeRot[1], $toeRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Toe.scale"), $toeScale[0], $toeScale[1], $toeScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Toe_Lctr");


		$heelPivPos   = `getAttr ("RRM_" + $prfx + $modName + "_HeelPivot_Lctr.translate")`;
		setAttr ("RRM_" + $prfx + $name + "_HeelPivot.tx") $heelPivPos[0];
		setAttr ("RRM_" + $prfx + $name + "_HeelPivot.tz") $heelPivPos[2];
		delete ("RRM_" + $prfx + $modName + "_HeelPivot_Lctr");


		$lTiltPos   = `getAttr ("RRM_" + $prfx + $modName + "_FootLeftTilt_Lctr.translate")`;
		setAttr ("RRM_" + $prfx + $name + "_FootLeftTilt.tx") $lTiltPos[0];
		setAttr ("RRM_" + $prfx + $name + "_FootLeftTilt.tz") $lTiltPos[2];
		delete ("RRM_" + $prfx + $modName + "_FootLeftTilt_Lctr");


		$rTiltPos   = `getAttr ("RRM_" + $prfx + $modName + "_FootRightTilt_Lctr.translate")`;
		setAttr ("RRM_" + $prfx + $name + "_FootRightTilt.tx") $rTiltPos[0];
		setAttr ("RRM_" + $prfx + $name + "_FootRightTilt.tz") $rTiltPos[2];
		delete ("RRM_" + $prfx + $modName + "_FootRightTilt_Lctr");


		$anklePos   = `getAttr ("RRM_" + $prfx + $modName + "_Ground_Lctr.translate")`;
		$ankleRot   = `getAttr ("RRM_" + $prfx + $modName + "_Ground_Lctr.rotate")`;		
		$ankleScale = `getAttr ("RRM_" + $prfx + $modName + "_Ground_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Ground.translate"), $anklePos[0], $anklePos[1], $anklePos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ground.rotate"), $ankleRot[0], $ankleRot[1], $ankleRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Ground.scale"), $ankleScale[0], $ankleScale[1], $ankleScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Ground_Lctr");

		$prfx = "r_";
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}
global proc RRM_Clone_V1_FkChain_V1(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	//GET NUMBER OF JOINTS
	int $chainsNum = `getAttr ("RRM_" + $modName + ".chainsNum")`;
	int $jointsNum = `getAttr ("RRM_" + $modName + ".jointsNum")`;
	int $direction = `getAttr ("RRM_" + $modName + ".direction")`;
	int $enableIK = `getAttr ("RRM_" + $modName + ".ikEnabled")`;
	int $i = 0;
	
	while ($i <= $mirrorMod)
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");
		
		//WHILE LOOP FOR CHAINS
		int $chainLoop = 1;
		while ($chainLoop <= $chainsNum)
		{
			string $nPd = "_0";
			if ($chainLoop >= 10)
			{
				string $nPd = "_";
			}
			$jointLoop = 1;
			//WHILE LOOP FOR JOINTS
			while ($jointLoop <= $jointsNum)
			{				
				string $jPad = "_0";
				if ($chainLoop >= 10)
				{
					string $jPad = "_";
				}
				//MOVE PROXY TO LOCATOR
				spaceLocator -n ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr");
				$eachPos   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + ".translate")`;
				$eachRot   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + ".rotate")`;
				$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + ".scale")`;
				setAttr (("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
				setAttr (("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
				setAttr (("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
				//CLONE ATT
				setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + ".clone") ($prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop);
				$jointLoop++;		
			}
			$chainLoop++;
		}
		$prfx = "r_";
		$i++;
	}
	
	//GENERATE NEW FK CHAIN
	select ("RRM_" + $attachNode);
	RRM_CreateProxyFKChain_V1($name, $chainsNum, $jointsNum, $direction, $direction, $mirrorMod, $enableIK);
	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$i = 0;
	$prfx = $prfxReset;
		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS

		//MOVE NODES TO LOCATORS
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		
		//WHILE LOOP FOR CHAINS
		int $chainLoop = 1;
		while ($chainLoop <= $chainsNum)
		{
			string $nPd = "_0";
			if ($chainLoop >= 10)
			{
				string $nPd = "_";
			}
			$jointLoop = 1;
			//WHILE LOOP FOR JOINTS
			while ($jointLoop <= $jointsNum)
			{			
				string $jPad = "_0";
				if ($chainLoop >= 10)
				{
					string $jPad = "_";
				}
				//MOVE PROXY TO LOCATOR
				$eachPos   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.translate")`;
				$eachRot   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.rotate")`;		
				$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr.scale")`;		
				
				setAttr (("RRM_" + $prfx + $name + $nPd + $chainLoop + $jPad + $jointLoop + ".translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
				setAttr (("RRM_" + $prfx + $name + $nPd + $chainLoop + $jPad + $jointLoop + ".rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
				setAttr (("RRM_" + $prfx + $name + $nPd + $chainLoop + $jPad + $jointLoop + ".scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
				delete ("RRM_" + $prfx + $modName + $nPd + $chainLoop + $jPad + $jointLoop + "_Lctr");
				$jointLoop++;
			}
			$chainLoop++;
		}
		$prfx = "r_";
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}
global proc RRM_Clone_V1_Head_V1(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	//GET NUMBER OF JOINTS
	int $jaw = `getAttr ("RRM_" + $modName + ".jaw")`;
	int $i = 0;

	while ($i <= $mirrorMod)
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");
		
		if ($jaw == 1)
		{
			spaceLocator -n ("RRM_" + $prfx + $modName + "_Jaw_Lctr");
			$jawPos   = `getAttr ("RRM_" + $prfx + $modName + "_Jaw.translate")`;
			$jawRot   = `getAttr ("RRM_" + $prfx + $modName + "_Jaw.rotate")`;
			$jawScale = `getAttr ("RRM_" + $prfx + $modName + "_Jaw.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_Jaw_Lctr.translate"), $jawPos[0], $jawPos[1], $jawPos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Jaw_Lctr.rotate"), $jawRot[0], $jawRot[1], $jawRot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_Jaw_Lctr.scale"), $jawScale[0], $jawScale[1], $jawScale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.clone") ($prfx + $name + "_Jaw");
			
			spaceLocator -n ("RRM_" + $prfx + $modName + "_JawEnd_Lctr");
			$jawEndPos   = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd.translate")`;
			$jawEndRot   = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd.rotate")`;
			$jawEndScale = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd.scale")`;
			setAttr (("RRM_" + $prfx + $modName + "_JawEnd_Lctr.translate"), $jawEndPos[0], $jawEndPos[1], $jawEndPos[2]);
			setAttr (("RRM_" + $prfx + $modName + "_JawEnd_Lctr.rotate"), $jawEndRot[0], $jawEndRot[1], $jawEndRot[2]);
			setAttr (("RRM_" + $prfx + $modName + "_JawEnd_Lctr.scale"), $jawEndScale[0], $jawEndScale[1], $jawEndScale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.clone") ($prfx + $name + "_JawEnd");
		}
		
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Top_Lctr");
		$topPos   = `getAttr ("RRM_" + $prfx + $modName + "_Top.translate")`;
		$topRot   = `getAttr ("RRM_" + $prfx + $modName + "_Top.rotate")`;
		$topScale = `getAttr ("RRM_" + $prfx + $modName + "_Top.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.translate"), $topPos[0], $topPos[1], $topPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.rotate"), $topRot[0], $topRot[1], $topRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Top_Lctr.scale"), $topScale[0], $topScale[1], $topScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Top.clone") ($prfx + $name + "_Top");

		$prfx = "r_";
		$i++;
	}
	
	//GENERATE NEW HEAD
	select ("RRM_" + $attachNode);
	RRM_CreateProxyHead_V1($name, $jaw, $mirrorMod);
	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$i = 0;
	$prfx = $prfxReset;

		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS

		//MOVE NODES TO LOCATORS
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");

		if ($jaw == 1)
		{
			$jawPos   = `getAttr ("RRM_" + $prfx + $modName + "_Jaw_Lctr.translate")`;
			$jawRot   = `getAttr ("RRM_" + $prfx + $modName + "_Jaw_Lctr.rotate")`;		
			$jawScale = `getAttr ("RRM_" + $prfx + $modName + "_Jaw_Lctr.scale")`;		
			
			setAttr (("RRM_" + $prfx + $name + "_Jaw.translate"), $jawPos[0], $jawPos[1], $jawPos[2]);
			setAttr (("RRM_" + $prfx + $name + "_Jaw.rotate"), $jawRot[0], $jawRot[1], $jawRot[2]);
			setAttr (("RRM_" + $prfx + $name + "_Jaw.scale"), $jawScale[0], $jawScale[1], $jawScale[2]);
			delete ("RRM_" + $prfx + $modName + "_Jaw_Lctr");
			
			$jawEndPos   = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd_Lctr.translate")`;
			$jawEndRot   = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd_Lctr.rotate")`;		
			$jawEndScale = `getAttr ("RRM_" + $prfx + $modName + "_JawEnd_Lctr.scale")`;		
			
			setAttr (("RRM_" + $prfx + $name + "_JawEnd.translate"), $jawEndPos[0], $jawEndPos[1], $jawEndPos[2]);
			setAttr (("RRM_" + $prfx + $name + "_JawEnd.rotate"), $jawEndRot[0], $jawEndRot[1], $jawEndRot[2]);
			setAttr (("RRM_" + $prfx + $name + "_JawEnd.scale"), $jawEndScale[0], $jawEndScale[1], $jawEndScale[2]);
			delete ("RRM_" + $prfx + $modName + "_JawEnd_Lctr");
		}

		$topPos   = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.translate")`;
		$topRot   = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.rotate")`;		
		$topScale = `getAttr ("RRM_" + $prfx + $modName + "_Top_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Top.translate"), $topPos[0], $topPos[1], $topPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Top.rotate"), $topRot[0], $topRot[1], $topRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Top.scale"), $topScale[0], $topScale[1], $topScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Top_Lctr");

		$prfx = "r_";
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}
global proc RRM_Clone_V1_LookAt_V1(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{//CHECK IF LOOKAT
	//GET NUMBER OF JOINTS
	int $eyeNum = `getAttr ("RRM_" + $modName + ".eyeNum")`;
	int $direction = `getAttr ("RRM_" + $modName + ".direction")`;
	int $i = 0;

	while ($i <= $mirrorMod)
	{
		//CREATE LOCATORS FOR LOCATIONS
		spaceLocator -n ("RRM_" + $prfx + $modName + "_Parent_Lctr");
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent.rotate")`;
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent.scale")`;
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $modName + "_Parent_Lctr.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Parent.clone") ($prfx + $name + "_Parent");

		//WHILE LOOP
		int $i2 = 1;
		while ($i2 <= $eyeNum)
		{
			string $nPd = "_0";
			if ($i2 >= 10)
			{
				string $nPd = "_";
			}
			//TRANSFORMS LOCATOR
			spaceLocator -n ("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr");
			$eachPos   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".translate")`;
			$eachRot   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".rotate")`;
			$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i2 + ".scale")`;
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
			setAttr (("RRM_" + $prfx + $modName + $nPd + $i2 + "_Lctr.scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
			//CLONE ATT
			setAttr -type "string" ("RRM_" + $prfx + $modName + $nPd + $i2 + ".clone") ("RRM_" + $prfx + $modName + $nPd + $i2);
			$i2++;
		}
		$prfx = "r_";
		$i++;
	}
	
	//GENERATE NEW LOOK AT
	select ("RRM_" + $attachNode);
	RRM_CreateProxyLookAt_V1($name, $eyeNum, $direction, $direction, $mirrorMod);
	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$i = 0;
	$prfx = $prfxReset;

		
	while ($i <= $mirrorMod)
	{
		//GET LOCATOR TRANSFORMS

		//MOVE NODES TO LOCATORS
		$parentPos   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.translate")`;
		$parentRot   = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.rotate")`;		
		$parentScale = `getAttr ("RRM_" + $prfx + $modName + "_Parent_Lctr.scale")`;		

		setAttr (("RRM_" + $prfx + $name + "_Parent.translate"), $parentPos[0], $parentPos[1], $parentPos[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.rotate"), $parentRot[0], $parentRot[1], $parentRot[2]);
		setAttr (("RRM_" + $prfx + $name + "_Parent.scale"), $parentScale[0], $parentScale[1], $parentScale[2]);
		delete ("RRM_" + $prfx + $modName + "_Parent_Lctr");

		$i3 = 1;
		while ($i3 <= $eyeNum)
		{
			string $nPd = "_0";
			if ($i3 >= 10)
			{
				string $nPd = "_";
			}
			//MOVE PROXY TO LOCATOR
			$eachPos   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.translate")`;
			$eachRot   = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.rotate")`;		
			$eachScale = `getAttr ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr.scale")`;		
			
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".translate"), $eachPos[0], $eachPos[1], $eachPos[2]);
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".rotate"), $eachRot[0], $eachRot[1], $eachRot[2]);
			setAttr (("RRM_" + $prfx + $name + $nPd + $i3 + ".scale"), $eachScale[0], $eachScale[1], $eachScale[2]);
			delete ("RRM_" + $prfx + $modName + $nPd + $i3 + "_Lctr");
			$i3++;
		}
		$prfx = "r_";
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}
global proc RRM_Clone_V1_Auxiliary_V1(string $name, string $modName, string $attachNode, int $mirrorMod, string $prfx, string $prfxReset)
{
	int $i = 0;
	
	while ($i <= $mirrorMod)
	{
		//CLONE ATT
		setAttr -type "string" ("RRM_" + $prfx + $modName + "_Aux.clone") ($prfx + $name + "_Aux");
		$prfx = "r_";
		$i++;
	}

	//GENERATE NEW AUXILIARY
	select ("RRM_" + $attachNode);
	RRM_CreateProxyAuxiliary_V1($name, $mirrorMod);
	$clonedParentNodes = `ls -sl`;
	//RESET VARIABLES
	$i = 0;
	$prfx = $prfxReset;
	
	while ($i <= $mirrorMod)
	{
		delete `parentConstraint ("RRM_" + $prfx + $modName + "_Aux") ("RRM_" + $prfx + $name + "_Aux")`;
		delete `scaleConstraint ("RRM_" + $prfx + $modName + "_Aux") ("RRM_" + $prfx + $name + "_Aux")`;
		$prfx = "r_";
		$i++;
	}
	//SELECT NEW MODULE NODES
	select $clonedParentNodes;
}

	
global proc RRM_Clone_V1(string $name, string $selection, string $attachNode, int $call)
{
	string $modName;
	string $modType;
	string $side;
	string $ext;
	
	if ($call == 0)
	{
		$modName = `getAttr ($selection + ".modName")`;
		$modType = `getAttr ("RRM_" + $modName + ".top")`;
		$attachNode = `getAttr ("RRM_" + $modName + ".parent")`;
	}
	else
	{
		$modName = `getAttr ("RRM_" + $selection + ".core")`;
		$modType = `getAttr ("RRM_" + $selection + ".top")`;
		//ORIGINAL MODULE'S ATTACH NODE
		$sourceAttachNode = `getAttr ("RRM_" + $modName + ".parent")`;

		//GET ATTACH NODE'S CLONED ATTRIBUTE
		string $cloneName = `getAttr ("RRM_" + $sourceAttachNode + ".clone")`;
		if (`gmatch $cloneName ""`)
		{//ATTACH NODE IS NOT A CLONE
			$attachNode = ($sourceAttachNode);
		}
		else
		{//ATTACH NODE IS A CLONE
			$attachNode = `getAttr ("RRM_" + $sourceAttachNode + ".clone")`;
		}
	}
	string $clonedParentNodes[];	

	int $mirrorMod = 1;
	string $prfx = "l_";
	string $prfxReset = "l_";
	if (!`objExists ("RRM_" + $modName + ".pair")`)
	{
		$mirrorMod = 0;
		$prfx = "";
		$prfxReset = "";
	}
	int $firstTimeThrough;

		
	//CHECK IF SPLINE
	if (`gmatch $modType "spline"`)
	{
		RRM_Clone_V1_Spline_V1($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "arm"`)
	{//CHECK IF ARM
		RRM_Clone_V1_Arm_V1($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "leg"`)
	{//CHECK IF LEG
		RRM_Clone_V1_Leg_V1($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "fkChain"`)
	{//CHECK IF FKCHAIN
		RRM_Clone_V1_FkChain_V1($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "head"`)
	{//CHECK IF HEAD
		RRM_Clone_V1_Head_V1($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "lookAt"`)
	{//CHECK IF LOOKAT
		RRM_Clone_V1_LookAt_V1($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
	else if (`gmatch $modType "auxiliary"`)
	{//CHECK IF AUXILIARY
		RRM_Clone_V1_Auxiliary_V1($name, $modName, $attachNode, $mirrorMod, $prfx, $prfxReset);
	}
		
	if ($call <= 1)
	{
		//CHECK TO SEE IF IT IS NOT AN AUXILIARY
		if (!`objExists ("RRM_" + $name + "_Aux")` && !`objExists ("RRM_l_" + $name + "_Aux")`)
		{
			spaceLocator -n ("RRM_Clone_V1_Lctr");
			addAttr -ln "topCloneNode"  -dt "string" "RRM_Clone_V1_Lctr";
			setAttr -e-keyable 1 "RRM_Clone_V1_Lctr.topCloneNode";
			setAttr -type "string" "RRM_Clone_V1_Lctr.topCloneNode" ("RRM_" + $name + "_Parent");
			if (!`objExists ("RRM_" + $name + "_Parent")`)
			{
				setAttr -type "string" "RRM_Clone_V1_Lctr.topCloneNode" ("RRM_l_" + $name + "_Parent");
			}
		}
		else
		{
			spaceLocator -n ("RRM_Clone_V1_Lctr");
			addAttr -ln "topCloneNode"  -dt "string" "RRM_Clone_V1_Lctr";
			setAttr -e-keyable 1 "RRM_Clone_V1_Lctr.topCloneNode";
			setAttr -type "string" "RRM_Clone_V1_Lctr.topCloneNode" ("RRM_" + $name + "_Aux");
			if (!`objExists ("RRM_" + $name + "_Aux")`)
			{
				setAttr -type "string" "RRM_Clone_V1_Lctr.topCloneNode" ("RRM_l_" + $name + "_Aux");
			}
		}			
	}
}

global proc RRM_CheckCloneFields_V1(int $cloneCheck[], string $textFields[], string $cloneSource[], string $cloneParent[])
{
	int $i;
	string $each;
	for ($each in $textFields)
	{
		$name = `textField -q -text $each`;
		if (`objExists ("RRM_" + $name)`)
		{
		string $returnVal_Generate = `confirmDialog
			-title "Module Already Exists"
			-message ("A module named \"" + $name + "\" already exists. You need to use a unique name.\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
			error "PLEASE PROVIDE UNIQUE NAMES FOR ALL CLONED MODULES.";
		}
		else if (`size $name` == 0)
		{
		string $returnVal_Generate = `confirmDialog
			-title "Missing Name"
			-message "You need to provide a name for each module.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
			error "PLEASE PROVIDE UNIQUE NAMES FOR ALL CLONED MODULES.";
		}
		$i++;
	}
	$i = 0;
	for ($each in $textFields)
	{
		$name = `textField -q -text $each`;
		RRM_Clone_V1($name, $cloneSource[$i], $cloneParent[$i], ($i + 1));
		$i++;
	}
}

global proc RRM_Clone_V1HierarchyUI_V1()
{
	$name = `textField -q -text textFieldCloneName`;
	string $selection[] = `ls -sl`;
	string $modName = `getAttr ($selection[0] + ".modName")`;
	$nodes = `listRelatives -ad  -type "transform" ("RRM_" + $modName)`;
	$topModules[0] = ("RRM_" + $modName);
	for ($each in $nodes)
	{
		if (`objExists ($each + ".top")` && `nodeType $each` != "constraint")
		{
			$topModules = `ls $topModules $each`;
		}
	}
	//GET DIALOG'S FORMLAYOUT
	string $form = `setParent -q`;
	
	formLayout -e -width 300 $form;
	string $instructions = `text -l "Rename Branches"`;
	string $original = `text -l "SOURCE NAME:"`;
	string $clone = `text -l "CLONE NAME:"`;
	formLayout -edit
		-attachForm				$instructions 	"top" 5
		-attachForm				$instructions 	"left" 90
		
		-attachForm				$original 	"top" 30
		-attachForm				$original 	"left" 4
		
		-attachForm				$clone 	"top" 30
		-attachForm				$clone 	"right" 75
	$form;
	int $i;
	string $checkBoxes[];
	global int $cloneCheck[];
	global string $cloneTextFields[];
	global string $cloneSource[];
	global string $cloneParent[];
	int $spacer = 10;
	int $top = 50;
	for ($eachBranch in $topModules)
	{
		//GET CORE NAME
		$coreName = `getAttr ($eachBranch + ".core")`;
		
		//GET PLACE IN HIERARCHY
		$left = 20;
		string $parentModule = $eachBranch;
		while (!`gmatch $parentModule ("RRM_" + $modName)`)
		{
			$parentNode = `getAttr ($parentModule + ".parent")`;
			$parentModule = `getAttr ("RRM_" + $parentNode + ".modName")`;
			$parentModule = ("RRM_" + $parentModule); 
			$left = ($left + 16);
		}
			
		string $checkBox = `checkBox -en 0 -vis 0 -v 0 -l "" ("checkBox_" + $eachBranch)`;
		string $label = `text -l ("-" + $coreName)`;
		string $textField = `textField -w 150 ("textField" + $eachBranch)`;
		
		formLayout -edit
			-attachForm			$checkBox		"top" $top
			-attachForm			$checkBox		"left" 4

			-attachForm			$label			"top" $top
			-attachForm			$label			"left" $left
			
			-attachForm			$textField		"top" $top
			-attachForm			$textField		"right" 5
		$form;
		
		$top = ($top + 20);
		$cloneCheck[$i] = `checkBox -q -v $checkBox`;
		$cloneTextFields[$i] =  $textField;
		$cloneSource[$i] = $coreName;
		string $cloneParent[];
		if (`objExists ("RRM_" + $coreName + ".parent")`)
		{
			$cloneParent[$i] = `getAttr ("RRM_" + $coreName + ".parent")`;
		}
		else
		{
			$cloneParent[$i] = `getAttr ("RRM_" + $coreName + ".attachNode")`;
		}
		$i++;
	}
	string $button_OK = `button -w 144 -label "OK" -c "RRM_CheckCloneFields_V1($cloneCheck, $cloneTextFields, $cloneSource, $cloneParent);layoutDialog -dismiss \"OK\";" Clone_Button`;
	string $button_Cancel = `button -w 144 -label "Cancel" -c "layoutDialog -dismiss \"Cancel\""`;
	formLayout -edit
		-attachForm			$button_OK		"top" ($top + 10)
		-attachForm			$button_OK		"left" 4
		
		-attachForm			$button_Cancel	"top" ($top + 10)
		-attachForm			$button_Cancel	"right" 4
	$form;
	
	textField -e -text $name $cloneTextFields[0]; 
}

global proc RRM_Clone_V1Prompts_V1(string $name, int $branchClone, int $clone)
{
	string $selection[] = `ls -sl`;
	string $coreCheck;
	if (`objExists ($selection[0] + ".core")`)
	{
		$coreCheck = `getAttr ($selection[0] + ".core")`;
	}
	
	string $dupeType = "clone";
	if ($clone == 0)
	{
		$dupeType = "rename";
	}
	
	if (`size $selection` == 0)
	{//CHECK THAT SOMETHING IS SELECTED
		string $returnVal_Generate = `confirmDialog
			-title "Nothing Selected"
			-message ("You must select a node of the desired module to " + $dupeType + ".\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`size $selection` > 1)
	{//CHECK THAT ONLY ONE OBJECT IS SELECTED
		string $returnVal_Generate = `confirmDialog
			-title "Only One Module May Be Cloned At A Time"
			-message ("You must select only one node of a desired module to " + $dupeType + ".\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (!`objExists ($selection[0] + ".core")`)
	{//CHECK TO MAKE SURE OBJECT IS A VALID MODULE
		string $returnVal_Generate = `confirmDialog
			-title "Not a Valid Node"
			-message ("You must select one node of a desired module to " + $dupeType + ".\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
	}
	else if (`gmatch $coreCheck "MAIN"` || `gmatch $coreCheck "ROOT"`)
	{//CHECK TO MAKE SURE OBJECT IS NOT MAIN OR ROOT
		string $returnVal_Generate = `confirmDialog
			-title "Not a Valid Node"
			-message ("You cannot " + $dupeType + " the MAIN or ROOT modules.\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;		
	}
	else if (`size $name` == "0")
	{//CHECK TO MAKE SURE THE USER HAS INPUT A NAME
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message ("You must enter a name for the " + $dupeType + ".\n")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (! RRM_CheckName_V1($name))
	{//CHECK TO MAKE SURE A VALID NAME HAS BEEN USED
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is Invalid"
			-message "A valid name must begin with a letter.\n    The rest of the name may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ("RRM_" + $name)`)
	{//CHECK TO MAKE SURE NAME DOES NOT CONFLICT WITH EXISTING OBJECT
		string $returnVal_Generate = `confirmDialog
			-title "The Module's Name is not Unique"
			-message "A module already exists with that name.\nYou must create a unique name.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		string $parentNullName = "";
		if ($branchClone == 0)
		{//ONLY CLONE LOADED MODULE
			if ($clone == 1)
			{
				print "Cloning...\n";
				RRM_Clone_V1($name, $selection[0], $parentNullName, 0);
			}
			else
			{
				print "Renaming...\n";
				RRM_Rename_V1($name, $selection[0], 0);
			}
		}
		else
		{//CLONE BRANCHES
			string $topModules[];
			$modName = `getAttr ($selection[0] + ".modName")`;
			
			$hierarchy = `listRelatives -ad  -type "nurbsCurve" ("RRM_" + $modName)`;
			//$nodeShapes = `ls -type "nurbsCurve" $hierarchy`;
			$nodes = `listRelatives -p $hierarchy`;
			for ($each in $nodes)
			{
				if (`objExists ($each + ".modName")` && `nodeType $each` != "constraint")
				{
					$modules = ("RRM_" + `getAttr ($each + ".modName")`);
					select $topModules $modules;
					$topModules = `ls -sl`;
				}
				
			}
			if (`size $topModules` == 1)
			{
				if ($clone = 1) 
				{
					RRM_Clone_V1($name, $selection[0], $parentNullName, 0);
				}
				else
				{
					RRM_Rename_V1($name, $selection[0], 0);
				}					
			}
			if ($branchClone == 1 && `size $topModules` > 1)
			{
				select $selection[0];
				layoutDialog -ui "RRM_Clone_V1HierarchyUI_V1()";
			}
		}
		//RESET CLONE ATTRIBUTES FOR FUTURE CLONES
		
		$hierarchy = `listRelatives -ad RRM_MAIN`;
		$shapeNodes = `ls -type "nurbsCurve" $hierarchy`;
		$nodes = `listRelatives -p $shapeNodes`;
		
		string $each;
		for ($each in $nodes)
		{
			if (`objExists ($each + ".clone")`)
			{
				setAttr -type "string" ($each + ".clone") "";
			}
		}
	}
	select -cl;
	int $selectionInt = 0;
	while ($selectionInt <= `size $selection`)
	{
		if (`objExists $selection[$selectionInt]`)
		{
			select -add $selection[$selectionInt];
		}
		$selectionInt++;
	}
	if (`objExists "RRM_Clone_V1_Lctr.topCloneNode"`)
	{
		$topNode[0] = `getAttr "RRM_Clone_V1_Lctr.topCloneNode"`;
		if (`objExists ($topNode[0] + ".opposite")`)
		{
			$opposite = `getAttr ($topNode[0] + ".opposite")`;
			$topNode[1] = ("RRM_" + $opposite);
		}
		delete "RRM_Clone_V1_Lctr";
		select $topNode;
	}
}


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////DELETE BRANCH/////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_DeleteBranch_V1(string $eachMod)
{
	//UNLOCK NODES	
	$rigHierarchy = `listRelatives -ad RRM_MAIN`;
	
	lockNode -lock off $rigHierarchy;

	string $crntNode;
	int $crntInt = 0;
	select $eachMod;
	$eachNode = `ls $eachMod`;
	
	while ((!`objExists ($eachNode[0] + ".top")`) && ($crntInt < 101))
	{
		pickWalk -d up;
		$eachNode = `ls -sl`;
		$crntInt++;
	}
	if (`objExists ($eachNode[0] + ".top")`)
	{
		delete $eachNode;
		$crntInt = 100;
	}
	
	//LOCK NODES
	$rigHierarchy2 = `listRelatives -ad RRM_MAIN`;
	lockNode $rigHierarchy2;
}
			
global proc RRM_DeleteBranch_V1Prompts_V1()
{
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;
	string $eachMod;
	if (`size $attachMod` == 0)
	{
		string $returnVal_Generate = `confirmDialog
				-title "No Module Selected"
				-message "Please select a module node of a branch to delete.\n"
				-button "OK"
				-defaultButton "OK"
				-cancelButton "OK"
				-icon "critical"`;
	}
	else
	{
		for ($eachMod in $attachMod)
		{
			if (`objExists $eachMod` && !`objExists ($eachMod + ".core")`)
			{
				string $returnVal_Generate = `confirmDialog
					-title "Invalid Branch Node"
					-message "You cannot delete the selected node.\n"
						-button "OK"
						-defaultButton "OK"
						-cancelButton "OK"
						-icon "critical"`;
			}
			else if ((`gmatch $eachMod "RRM_ROOT"`) || (`gmatch $eachMod "RRM_MAIN"`))
			{
				string $returnVal_Generate = `confirmDialog
					-title "Proxy Rig Deletion"
					-message "This will delete your entire proxy rig!\nAre you sure you wisth to proceed?\n"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "critical"`;
				if ($returnVal_Generate == "OK") 
				{
					//select -hi RRM_MAIN;
					//$rigHierarchy = `ls -sl`;
					$rigHierarchy = `listRelatives -ad RRM_MAIN`;
					lockNode -lock off $rigHierarchy RRM_MAIN RRM_ProxiesLayer;
					delete RRM_MAIN RRM_ProxiesLayer;
				}
			}
			else
			{
				if (`objExists $eachMod`)
				{
					RRM_DeleteBranch_V1($eachMod);
				}
			}
		}
	}
}

global proc modLocalAxesToggleAll_V1()
{
	$crnt = `ls -sl`;
	string $proxies[];
	$hierarchy = `listRelatives -ad RRM_MAIN`;
	string $crntProxy;
	for ($crntProxy in $hierarchy)
	{
	    if (`objExists ($crntProxy + ".core")`)
	    {
	    	$LocalAxisDisplay = `getAttr ($crntProxy + ".displayLocalAxis")`;
	    	if ($LocalAxisDisplay == 0)
	    	{
	    		setAttr ($crntProxy + ".displayLocalAxis") 1;
	    	}
	    	else
	    	{
	    		setAttr ($crntProxy + ".displayLocalAxis") 0;
	    	}
	    }
	}
	select $crnt;
}

global proc RRM_LocalAxesToggleSelected_V1()
{
	$crnt = `ls -sl`;
	string $crntProxy;
	for ($crntProxy in $crnt)
	{
	    if (`objExists ($crntProxy + ".core")`)
	    {
	    	$LocalAxisDisplay = `getAttr ($crntProxy + ".displayLocalAxis")`;
	    	if ($LocalAxisDisplay == 0)
	    	{
	    		setAttr ($crntProxy + ".displayLocalAxis") 1;
	    	}
	    	else
	    	{
	    		setAttr ($crntProxy + ".displayLocalAxis") 0;
	    	}
	    }
	}
}

global proc RRM_LoadNewModuleAttachNode_V1()
{
	$crnt = `ls -sl`;
	if (`size $crnt` == 1)
	{
		if (`objExists ($crnt[0] + ".core")`)
		{
			$checkMain = `getAttr ($crnt[0] + ".core")`;
			if (($checkMain != "MAIN") && (!`objExists ($crnt[0] + ".parent")`))
			{
				textFieldButtonGrp -e -text $crnt RRM_LoadNewModuleAttachNode_V1TextField;
			}
			else
			{
				warning "CANNOT ASSIGN THE MAIN CONTROL OR PARENT NODES AS THE NEW ATTACH NODE";
			}
		}
		else
		{
			warning "PLEASE SELECT A VALID PROXY NODE TO LOAD";
		}
	}
	else if (`size $crnt` == 0)
	{
		warning "PLEASE SELECT A PROXY NODE TO LOAD";
	}
	else
	{
		warning "PLEASE SELECT ONLY ONE NODE. MIRRORED PARENTS WILL AUTOMATICALLY BE CONNECTED PROPERLY";
	}
}

global proc RRM_AttachToNewModule_V1(string $modAttachName)
{
	$checkMain = `getAttr ($modAttachName + ".core")`;
	if ((!`objExists $checkMain`) && ($checkMain != "MAIN") && (!`objExists ($checkMain + ".parent")`))
	{
		$parentModules = `ls -sl`;
		$moduleGroups = `listRelatives -p $parentModules`;
		$parentModulesHierarchy = `listRelatives -ad $parentModules`;
		
		string $eachModule;
		for ($eachModule in $parentModulesHierarchy)
		{
			if ($modAttachName == $eachModule)
			{
				select $parentModules;
				error "YOU CANNOT ATTACH PARENT NODES TO ONE OF THEIR CHILDREN";
			}
		}
		
		string $eachModule;
		for ($eachModule in $parentModules)
		{
			string $modType;
			if (`objExists ($eachModule + ".parent")`)
			{
				$modType = 	`getAttr ($eachModule + ".parent")`;
			}
			else if (`objExists ($eachModule + ".modType")`)
			{
				$modType = `getAttr ($eachModule + ".modType")`;
			}
			
			string $modAbsoluteParent[];
			if (`objExists ($eachModule + ".parent")` || $modType == "auxiliary")
			{
				$modParent = `listRelatives -p $eachModule`;
				$modAbsoluteParent[0] = $modParent[0];
				if (`objExists ($eachModule + ".pair")`)
				{
					if (`objExists ($modAttachName + ".pair")`)
					{
						$moduleSideCheck = `getAttr ($eachModule + ".pair")`; 
						if ($moduleSideCheck == "right")
						{
							$eachModule = `getAttr ($eachModule + ".opposite")`;
							$eachModule = ("RRM_" + $eachModule);
						}
						$modAttachSideCheck = `getAttr ($modAttachName + ".pair")`;
						if ($modAttachSideCheck == "right")
						{
							$modAttachName = `getAttr ($modAttachName + ".opposite")`;
							$modAttachName = ("RRM_" + $modAttachName);
						}
					}
					$modAbsoluteParent = `listRelatives -p $modParent[0]`;
				}
				
				//DELETE CONSTRAINTS
				lockNode -lock off ($modParent[0] + "_parentConstraint1") ($modParent[0] + "_scaleConstraint1") $eachModule $modAbsoluteParent[0];
				delete ($modParent[0] + "_parentConstraint1") ($modParent[0] + "_scaleConstraint1");
    	
				//PARENT IF NOT ALREADY PARENTED
				string $parent[] = `listRelatives -parent $modAbsoluteParent[0]`;
				if (!`gmatch $parent[0] $modAttachName`)
				{
					parent $modAbsoluteParent[0] $modAttachName;
				}
				
				//DELETE OLD CONNECTOR AND CREATE NEW ONE
				$attachCore = `getAttr ($eachModule + ".attachNode")`;
				$connectorHi = `listRelatives -ad ("RRM_" + $attachCore + "_" + $eachModule + "Ctrl") ("RRM_" + $attachCore + "_" + $eachModule + "_AimLctr")`;
				lockNode -lock off $connectorHi ("RRM_" + $attachCore + "_" + $eachModule + "Ctrl") ("RRM_" + $attachCore + "_" + $eachModule + "_AimLctr");
				delete ("RRM_" + $attachCore + "_" + $eachModule + "Ctrl") ("RRM_" + $attachCore + "_" + $eachModule + "_AimLctr");
				
				$modName = `getAttr ($eachModule + ".modName")`;
				$prfx = "";
				if (`objExists ($eachModule + ".pair")`)
				{
					$sideCheck = `getAttr ($eachModule + ".pair")`;
					if ($sideCheck == "left")
					{
						$prfx = "l_";
					}
					else
					{
						$prfx = "r_";
					}
				}
				RRM_ProxyConnectors_V1($modName, $prfx, $modAttachName, $eachModule);

				//MAKE NEW CONSTRAINTS
				parentConstraint -mo $modAttachName "RRM_MAIN" $modParent[0];
				scaleConstraint  -mo $modAttachName "RRM_MAIN" $modParent[0];
				setAttr ($modParent[0] + "_parentConstraint1.RRM_MAINW1") 0;
				setAttr ($modParent[0] + "_scaleConstraint1.RRM_MAINW1") 0;
				
				//CHANGE ATTACH NODE ATTRIBUTE IN PARENT NODE
				$modAttachCore = `getAttr ($modAttachName + ".core")`;
				setAttr -l false ($eachModule + ".attachNode");
				setAttr -type "string" ($eachModule + ".attachNode") $modAttachCore;
				setAttr -l true ($eachModule + ".attachNode");
				
				//CHANGE PARENT ATTRIBUTE IN TOP NODE
				setAttr -l false ($modAbsoluteParent[0] + ".parent");
				setAttr -type "string" ($modAbsoluteParent[0] + ".parent") $modAttachCore;
				
				
				//CHECK TO SEE IF MIRRORED////////////////////////////////////////////////////////////
				if (`objExists ($eachModule + ".pair")`)
				{
					$mirrorModule = `getAttr ($eachModule + ".opposite")`;
					$mirrorModule = ("RRM_" + $mirrorModule); 
					//
					////CHECK FOR MIRROR NODE
					$mirrorModAttachName = $modAttachName;
					$mirrorModAttachName = $mirrorModAttachName;
					

					$mirrorModuleSideCheck = `getAttr ($eachModule + ".pair")`; 
					if ($mirrorModuleSideCheck == "left")
					{
						$mirrorModule = `getAttr ($eachModule + ".opposite")`;
						$mirrorModule = ("RRM_" + $mirrorModule);
					}
					
					if (`objExists ($modAttachName + ".pair")`)
					{						
						$mirrorModAttachSideCheck = `getAttr ($modAttachName + ".pair")`;
						if ($mirrorModAttachSideCheck == "left")
						{
							$mirrorModAttachName = `getAttr ($modAttachName + ".opposite")`;
							$mirrorModAttachName = ("RRM_" + $mirrorModAttachName);
						}
					}

					$mirrorModParent = `listRelatives -p $mirrorModule`;
					
					//DELETE CONSTRAINTS
					lockNode -lock off ($mirrorModParent[0] + "_parentConstraint1") ($mirrorModParent[0] + "_scaleConstraint1") $mirrorModule;
					delete ($mirrorModParent[0] + "_parentConstraint1") ($mirrorModParent[0] + "_scaleConstraint1");
    	
					//DELETE OLD CONNECTOR AND CREATE NEW ONE
					$attachCore = `getAttr ($mirrorModule + ".attachNode")`;
					$connectorHi = `listRelatives -ad ("RRM_" + $attachCore + "_" + $mirrorModule + "Ctrl") ("RRM_" + $attachCore + "_" + $mirrorModule + "_AimLctr")`;
					lockNode -lock off $connectorHi ("RRM_" + $attachCore + "_" + $mirrorModule + "Ctrl") ("RRM_" + $attachCore + "_" + $mirrorModule + "_AimLctr");
					delete ("RRM_" + $attachCore + "_" + $mirrorModule + "Ctrl") ("RRM_" + $attachCore + "_" + $mirrorModule + "_AimLctr");
					
					$modName = `getAttr ($mirrorModule + ".modName")`;
					$prfx = "";
					if (`objExists ($mirrorModule + ".pair")`)
					{
						$sideCheck = `getAttr ($mirrorModule + ".pair")`;
						if ($sideCheck == "left")
						{
							$prfx = "l_";
						}
						else
						{
							$prfx = "r_";
						}
					}
					RRM_ProxyConnectors_V1($modName, $prfx, $modAttachName, $mirrorModule);
					
					//MAKE NEW CONSTRAINTS
					if (`objExists $mirrorModAttachName`)
					{
						parentConstraint -mo ($mirrorModAttachName) "RRM_MAIN" $mirrorModParent[0];
						scaleConstraint  -mo ($mirrorModAttachName) "RRM_MAIN" $mirrorModParent[0];
						setAttr ($mirrorModParent[0] + "_parentConstraint1.RRM_MAINW1") 0;
						setAttr ($mirrorModParent[0] + "_scaleConstraint1.RRM_MAINW1") 0;

						//CHANGE ATTACH NODE ATTRIBUTE IN PARENT NODE
						$mirrorModAttachCore = `getAttr ($mirrorModAttachName + ".core")`;
						setAttr -l false ($mirrorModule + ".attachNode");
						setAttr -type "string" ($mirrorModule + ".attachNode") $mirrorModAttachCore;
						setAttr -l true ($mirrorModule + ".attachNode");
					}
					lockNode -lock on ($mirrorModParent[0] + "_parentConstraint1") ($mirrorModParent[0] + "_scaleConstraint1") $mirrorModule;
				}
				lockNode -lock on ($modParent[0] + "_parentConstraint1") ($modParent[0] + "_scaleConstraint1") $eachModule $modAbsoluteParent[0];
			}
			else
			{
				print ("\"" + $eachModule + "\" IS NOT A PARENT MODULE... SKIPPING\n");
			}
		}
		select $parentModules;
	}
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////RESET///////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_ResetProxies_V1(int $RRM_PoseSelection)
{
	$originalSelection = `ls -sl`;
	$proxies = `ls -sl`;
	string $crntProxy;
	string $topMods[];
	
	if ($RRM_PoseSelection == 2 || $RRM_PoseSelection == 3)
	{//MODULE OR BRANCH
		if (`size $proxies` > 0)
		{//CHECK THAT SOMETHING IS SELECTED
			for ($crntProxy in $proxies)
			{
				if (!`objExists ($crntProxy + ".parent")`)
				{
					if (`objExists ($crntProxy + ".modName")`)
					{
						$modName = `getAttr ($crntProxy + ".modName")`;
						$topMods = `ls $topMods ("RRM_*" + $modName + "_Parent")`;							
						$proxies = `ls -type "transform" ("RRM_*" + $modName + "_*")`;
					}
				}
				else
				{
					$topMods = `ls $crntProxy $topMods`;
				}
			}
			if ($RRM_PoseSelection == 3)
			{
				$hierarchy = `listRelatives -ad $topMods`;
				for ($crntProxy3 in $hierarchy)
				{
					if (`objExists ($crntProxy3 + ".core")`)
					{
						$proxies = `ls $proxies $crntProxy3`;
					}
				}
			}
		}
		else if ($RRM_PoseSelection != 4)
		{
			warning "Nothing Selected. No action taken.";
		}
	}
	if ($RRM_PoseSelection == 4)
	{
		$hierarchy = `listRelatives -ad RRM_MAIN`;
		string $crntProxy;
		for ($crntProxy in $hierarchy)
		{
			if (`objExists ($crntProxy + ".core")`)
			{
				$proxies = `ls $proxies $crntProxy`;
			}
		}
	}
	else if ($RRM_PoseSelection == 1 && `size $proxies` == 0)
	{
		warning "Nothing Selected. No action taken.";
	}
	
	for ($crntProxy in $proxies)
	{
		if (!`gmatch $crntProxy "RRM_ROOT"` && !`objExists ($crntProxy + ".parent")` && `objExists ($crntProxy + ".modName")`)
		{
			if (`getAttr -lock ($crntProxy + ".tx")` == 0)
			{
				setAttr ($crntProxy + ".tx") 0;
			}
			if (`getAttr -lock ($crntProxy + ".ty")` == 0)
			{
				setAttr ($crntProxy + ".ty") 0;
			}
			if (`getAttr -lock ($crntProxy + ".tz")` == 0)
			{
				setAttr ($crntProxy + ".tz") 0;
			}
			if (`getAttr -lock ($crntProxy + ".rx")` == 0)
			{
				setAttr ($crntProxy + ".rx") 0;
			}
			
			if (`getAttr -lock ($crntProxy + ".ry")` == 0)
			{
				setAttr ($crntProxy + ".ry") 0;
			}
			if (`getAttr -lock ($crntProxy + ".rz")` == 0)
			{
				setAttr ($crntProxy + ".rz") 0;
			}
			
			if (`getAttr -lock ($crntProxy + ".sx")` == 0)
			{
				setAttr ($crntProxy + ".sx") 1;
			}
			if (`getAttr -lock ($crntProxy + ".sy")` == 0)
			{
				setAttr ($crntProxy + ".sy") 1;
			}
			if (`getAttr -lock ($crntProxy + ".sz")` == 0)
			{
				setAttr ($crntProxy + ".sz") 1;
			}
			select $originalSelection;
		}
	}
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////   TRANSFER   ///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_TransferProxies_V1(string $side, int $RRM_PoseSelection)
{
	$originalSelection = `ls -sl`;
	$proxies = `ls -sl`;
	string $crntProxy;
	string $topMods[];
	
	if ($RRM_PoseSelection == 2 || $RRM_PoseSelection == 3)
	{//MODULE OR BRANCH
		if (`size $proxies` > 0)
		{//CHECK THAT SOMETHING IS SELECTED
			for ($crntProxy in $proxies)
			{
				if (!`objExists ($crntProxy + ".parent")`)
				{
					if (`objExists ($crntProxy + ".modName")`)
					{
						$modName = `getAttr ($crntProxy + ".modName")`;
						$topMods = `ls $topMods ("RRM_*" + $modName + "_Parent")`;							
						$proxies = `ls -type "transform" ("RRM_*" + $modName + "_*")`;
					}
				}
				else
				{
					$topMods = `ls $crntProxy $topMods`;
				}
			}
			if ($RRM_PoseSelection == 3)
			{
				$hierarchy = `listRelatives -ad $topMods`;
				for ($crntProxy3 in $hierarchy)
				{
					if (`objExists ($crntProxy3 + ".core")`)
					{
						$proxies = `ls $proxies $crntProxy3`;
					}
				}
			}
		}
		else if ($RRM_PoseSelection != 4)
		{
			warning "Nothing Selected. No action taken.";
		}
	}
	if ($RRM_PoseSelection == 4)
	{
		$hierarchy = `listRelatives -ad RRM_MAIN`;
		string $crntProxy;
		for ($crntProxy in $hierarchy)
		{
			if (`objExists ($crntProxy + ".core")`)
			{
				$proxies = `ls $proxies $crntProxy`;
			}
		}
	}
	else if ($RRM_PoseSelection == 1 && `size $proxies` == 0)
	{
		warning "Nothing Selected. No action taken.";
	}
	
	//TRANSFER
	for ($crntProxy in $proxies)
	{
		if (`objExists ($crntProxy + ".modName")`)
		{
			if (`objExists ($crntProxy + ".opposite")`)
			{
				if ($side == `getAttr ($crntProxy + ".pair")`)
				{
					string $opp = `getAttr ($crntProxy + ".opposite")`;
					
					if (`getAttr -lock ($crntProxy + ".tx")` == 0)
					{
						$tx = `getAttr ($crntProxy + ".tx")`;
						setAttr ("RRM_" + $opp + ".tx") ($tx * -1);
					}
					if (`getAttr -lock ($crntProxy + ".ty")` == 0)
					{
						$ty = `getAttr ($crntProxy + ".ty")`;
						setAttr ("RRM_" + $opp + ".ty") ($ty * 1);
					}
					if (`getAttr -lock ($crntProxy + ".tz")` == 0)
					{
						$tz = `getAttr ($crntProxy + ".tz")`;
						setAttr ("RRM_" + $opp + ".tz") ($tz * 1);
					}
					if (`getAttr -lock ($crntProxy + ".rx")` == 0)
					{
						$rx = `getAttr ($crntProxy + ".rx")`;
						setAttr ("RRM_" + $opp + ".rx") ($rx * 1);
					}
					if (`getAttr -lock ($crntProxy + ".ry")` == 0)
					{
						$ry = `getAttr ($crntProxy + ".ry")`;
						setAttr ("RRM_" + $opp + ".ry") ($ry * -1);
					}
					if (`getAttr -lock ($crntProxy + ".rz")` == 0)
					{
						$rz = `getAttr ($crntProxy + ".rz")`;
						setAttr ("RRM_" + $opp + ".rz") ($rz * -1);
					}
					if (`getAttr -lock ($crntProxy + ".sx")` == 0)
					{
						$sx = `getAttr ($crntProxy + ".sx")`;
						setAttr ("RRM_" + $opp + ".sx") ($sx * 1);
					}
					if (`getAttr -lock ($crntProxy + ".sy")` == 0)
					{
						$sy = `getAttr ($crntProxy + ".sy")`;
						setAttr ("RRM_" + $opp + ".sy") ($sy * 1);
					}
					if (`getAttr -lock ($crntProxy + ".sz")` == 0)
					{
						$sz = `getAttr ($crntProxy + ".sz")`;
						setAttr ("RRM_" + $opp + ".sz") ($sz * 1);
					}
				}
			}
		}
	}
	select $originalSelection;
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////PINNING///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_PinProxies_V1(int $on, int $off)
{
	$selected = `ls -sl`;
	string $parentModules[];
	string $prfx = "";
	string $rootCheck;
	//CHECK THAT SOMETHING IS SELECTED
	if (`size $selected` > 0)
	{
		//CHECK IF VALID MODULE
		string $each;
		for ($each in $selected)
		{
			if (`objExists ($each + ".modName")`)
			{
				//CHECK IF PAIR, GET PREFIX IF TRUE
				if (`objExists ($each + ".pair")`)
				{
					$sideCheck = `getAttr ($each + ".pair")`;
					if ($sideCheck == "left")
						{$prfx = "l_";}
					else if ($sideCheck == "right")
						{$prfx = "r_";}
				}
				else
				{
					$prfx = "";
				}
				$modName = `getAttr ($each + ".modName")`;
				//CHECK IF ROOT
				$rootCheck = `getAttr ($each + ".core")`;
				{
					if ($rootCheck == "ROOT")
					{
						warning "YOU CANNOT PIN THE ROOT PROXY.";
					}
					else if ($rootCheck == "MAIN")
					{
						warning "YOU CANNOT PIN THE MAIN PROXY.";
					}
					else
					{
						$parentModules = `ls ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "*_Aux") $parentModules`;
					}
				}
			}
		}
		if (`size $parentModules` > 0)
		{
			//GET WORLD SPACE AND SCALE
			string $each2;
			string $mirroredTopNode;
			$topNodeScale = <<1,1,1>>;
			for ($each2 in $parentModules)
			{
				$pinCheck = `getAttr ($each2 + ".pinned")`;
				if ($pinCheck != $on)
				{
					//CHECK IF PAIR, GET PREFIX IF TRUE
					if (`objExists ($each2 + ".pair")`)
					{
						$sideCheck = `getAttr ($each2 + ".pair")`;
						if ($sideCheck == "left")
							{$prfx = "l_";}
						else if ($sideCheck == "right")
							{$prfx = "r_";}
						//GET TOP NODE'S SCALE
						$mirroredTopNode = `getAttr ($each2 + ".modName")`;
						$topNodeScale = `getAttr ("RRM_" + $mirroredTopNode + ".scale")`;
					}
					else 
					{
						$prfx = "";
						$topNodeScale = <<1,1,1>>;
					}
	
					$modLoc = `xform -q -ws -rp $each2`;
					$modRot = `xform -q -ws -ro $each2`;
					
					//GET SCALE
					spaceLocator -n ($each + "_ScaleLctr");
					parent ($each + "_ScaleLctr") RRM_MAIN;
					scaleConstraint $each2 ($each + "_ScaleLctr");
					$modScale = `getAttr ($each + "_ScaleLctr.scale")`;
					delete ($each + "_ScaleLctr");
					
					$modName  = `getAttr ($each2 + ".modName")`;
					$topScale = `getAttr ("RRM_" + $prfx + $modName + ".scale")`;
					
					$scaleRatio[0] = ($modScale[0] * $topScale[0] * $topNodeScale.x);
					$scaleRatio[1] = ($modScale[1] * $topScale[1] * $topNodeScale.y);
					$scaleRatio[2] = ($modScale[2] * $topScale[2] * $topNodeScale.z);
					
					//ATTACH NODE
					string $attachNode;
					if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
					{
						$attachNode = `getAttr ("RRM_" + $prfx + $modName + "_Parent.attachNode")`;
					}
					else if (`objExists ("RRM_" + $prfx + $modName + "_Aux")`)
					{
						$attachNode = `getAttr ("RRM_" + $prfx + $modName + "_Aux.attachNode")`;
					}

					//SET CONSTRAINT WEIGHTS
					setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_" + $attachNode + "W0") $off;
					setAttr ("RRM_" + $prfx + $modName + "_parentConstraint1.RRM_MAINW1") $on;				
					setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_" + $attachNode + "W0") $off;
					setAttr ("RRM_" + $prfx + $modName + "_scaleConstraint1.RRM_MAINW1") $on;
					
					//SET SCALE VALUES
					setAttr (($each2 + ".scale"), $scaleRatio[0], $scaleRatio[1], $scaleRatio[2]);
					//SET ROTATE
					rotate -ws -a $modRot[0] $modRot[1] $modRot[2] $each2;
					//SET SCALE
					move -ws $modLoc[0] $modLoc[1] $modLoc[2] $each2;
					
					////CHANGE COLOUR OF CONNECTOR
					//setAttr ("RRM_" + $attachNode + "_RRM_" + $prfx + $modName + "_ParentCtrl.overrideColor") (6 + (7 * $on));

					
					if (`objExists ("RRM_" + $prfx + $modName + "_Parent")`)
					{
						//CHANGE COLOUR OF CONNECTOR
						setAttr ("RRM_" + $attachNode + "_RRM_" + $prfx + $modName + "_ParentCtrl.overrideColor") (6 + (7 * $on));

						//SET PIN CHANNEL
						lockNode -lock 0 ("RRM_" + $prfx + $modName + "_Parent");
						setAttr -lock 0 ("RRM_" + $prfx + $modName + "_Parent.pinned");
						setAttr ("RRM_" + $prfx + $modName + "_Parent.pinned") $on;
						setAttr -lock 1 ("RRM_" + $prfx + $modName + "_Parent.pinned");
						lockNode ("RRM_" + $prfx + $modName + "_Parent");
					}
					else if (`objExists ("RRM_" + $prfx + $modName + "_Aux")`)
					{
						//CHANGE COLOUR OF CONNECTOR
						setAttr ("RRM_" + $attachNode + "_RRM_" + $prfx + $modName + "_AuxCtrl.overrideColor") (6 + (7 * $on));

						//SET PIN CHANNEL
						lockNode -lock 0 ("RRM_" + $prfx + $modName + "_Aux");
						setAttr -lock 0 ("RRM_" + $prfx + $modName + "_Aux.pinned");
						setAttr ("RRM_" + $prfx + $modName + "_Aux.pinned") $on;
						setAttr -lock 1 ("RRM_" + $prfx + $modName + "_Aux.pinned");
						lockNode ("RRM_" + $prfx + $modName + "_Aux");
					}						
				}
			}
		}
		else
		{
			warning "NO VALID MODULES WERE SELECTED";
		}
	}
	else
	{
		warning "NOTHING SELECTED";
	}
	select $selected;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////TRANSFER TRANSFORMS///////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_TransferModTransforms_V12_V1(string $sourceParent, string $destinationParent)
{
	
	//CHECK WHETHER TO INCLUDE PARENT NODE
	$parentCheck = `checkBox -q -v RRM_TransferParent`;
	
	select -hi $sourceParent;
	select -d "*Shape" "*Constraint1";
	if ($parentCheck == 0)
	{
		select -d $sourceParent;
	}
	$sourceHierarchy = `ls -sl -type "transform"`;
	
	select -hi $destinationParent;
	select -d "*Shape" "*Constraint1";
	if ($parentCheck == 0)
	{
		select -d $destinationParent;
	}
	$destinationHierarchy = `ls -sl -type "transform"`;
		
	if ((`size $sourceHierarchy` > 0) && (`size $destinationHierarchy` > 0))
	{
		int $crntHierarchyMod = 0;
		while (($crntHierarchyMod < `size $sourceHierarchy`) && ($crntHierarchyMod < `size $destinationHierarchy`))
		{
			if (`objExists ($sourceHierarchy[$crntHierarchyMod] + ".modName")` && `objExists ($sourceHierarchy[$crntHierarchyMod] + ".modName")`)
			{
				$sourceT = `getAttr ($sourceHierarchy[$crntHierarchyMod] + ".translate")`;
				$sourceR = `getAttr ($sourceHierarchy[$crntHierarchyMod] + ".rotate")`;
				$sourceS = `getAttr ($sourceHierarchy[$crntHierarchyMod] + ".scale")`;
					
				if (`getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".tx")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".tx") $sourceT[0];}
				if (`getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".ty")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".ty") $sourceT[1];}
				if (`getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".tz")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".tz") $sourceT[2];}
				
				if (`getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".rx")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".rx") $sourceR[0];}
				if (`getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".ry")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".ry") $sourceR[1];}
				if (`getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".rz")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".rz") $sourceR[2];}
					
				if (`getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".sx")`== 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".sx") $sourceS[0];}
				if (`getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".sy")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".sy") $sourceS[1];}
				if (`getAttr -lock ($destinationHierarchy[$crntHierarchyMod] + ".sz")` == 0)
				{setAttr ($destinationHierarchy[$crntHierarchyMod] + ".sz") $sourceS[2];}
			}
			$crntHierarchyMod++;
		}
	}
}
global proc RRM_TransferModTransforms_V1()
{
	$originalSelection = `ls -sl`;
	$proxies = `ls -sl`;
	$sourceParent = `ls -sl`;
	$destinationParent = `ls -sl`;
	string $crntProxy;
	
	int $RRM_TransferSelectionButton = `radioButtonGrp -q -select RRM_TransferSelectionButton`;

	if (`size $proxies` == 2)
	{
		//SELECTED
		if ($RRM_TransferSelectionButton == 1)
		{
			$sourceT = `getAttr ($proxies[0] + ".translate")`;
			$sourceR = `getAttr ($proxies[0] + ".rotate")`;
			$sourceS = `getAttr ($proxies[0] + ".scale")`;


			if (`getAttr -lock ($proxies[1] + ".tx")` == 0)
			{setAttr ($proxies[1] + ".tx") $sourceT[0];}
			if (`getAttr -lock ($proxies[1] + ".ty")` == 0)
			{setAttr ($proxies[1] + ".ty") $sourceT[1];}
			if (`getAttr -lock ($proxies[1] + ".tz")` == 0)
			{setAttr ($proxies[1] + ".tz") $sourceT[2];}
			
			if (`getAttr -lock ($proxies[1] + ".rx")` == 0)
			{setAttr ($proxies[1] + ".rx") $sourceR[0];}
			if (`getAttr -lock ($proxies[1] + ".ry")` == 0)
			{setAttr ($proxies[1] + ".ry") $sourceR[1];}
			if (`getAttr -lock ($proxies[1] + ".rz")` == 0)
			{setAttr ($proxies[1] + ".rz") $sourceR[2];}

			if (`getAttr -lock ($proxies[1] + ".sx")` == 0)
			{setAttr ($proxies[1] + ".sx") $sourceS[0];}
			if (`getAttr -lock ($proxies[1] + ".sy")` == 0)
			{setAttr ($proxies[1] + ".sy") $sourceS[1];}
			if (`getAttr -lock ($proxies[1] + ".sz")` == 0)
			{setAttr ($proxies[1] + ".sz") $sourceS[2];}
		}
		
		//BRANCH
		else if ($RRM_TransferSelectionButton == 2)
		{
			$sourceProxy = $proxies[0];
			$destinationProxy = $proxies[1];
			
			//GET SOURCE PARENT
			if (!`objExists ($sourceProxy + ".parent")`)
			{
				if (`objExists ($sourceProxy + ".modName")`)
				{
					$modName = `getAttr ($sourceProxy + ".modName")`;
					if (`objExists ($sourceProxy + ".pair")`)
					{
						$side = `getAttr ($sourceProxy + ".pair")`;
						if ($side == "left")
						{
							$side = "l_";
						}
						else
						{
							$side = "r_";
						}
						$sourceParent = `ls ("RRM_" + $side + $modName + "_Parent")`;
					}
					else
					{
						$sourceParent = `ls ("RRM_" + $modName + "_Parent")`;							
					}
				}
			}
			else
			{
				$sourceParent = `ls $sourceProxy`;
			}
			
			//GET DESTINATION PARENT
			if (!`objExists ($destinationProxy + ".parent")`)
			{
				if (`objExists ($destinationProxy + ".modName")`)
				{
					$modName = `getAttr ($destinationProxy + ".modName")`;
					if (`objExists ($destinationProxy + ".pair")`)
					{
						$side = `getAttr ($destinationProxy + ".pair")`;
						if ($side == "left")
						{
							$side = "l_";
						}
						else
						{
							$side = "r_";
						}
						$destinationParent = `ls ("RRM_" + $side + $modName + "_Parent")`;
					}
					else
					{
						$destinationParent = `ls ("RRM_" + $modName + "_Parent")`;							
					}
				}
			}
			else
			{
				$destinationParent = `ls $destinationProxy`;
			}
			$sourceModType = `getAttr ($sourceParent[0] + ".parent")`;
			$destinationModType = `getAttr ($destinationParent[0] + ".parent")`;
			
			//CHECK TO SEE IF THEY ARE THE SAME TYPE OF MODULE
			if ($sourceModType == $destinationModType)
			{
				select -hi $sourceParent[0];
				select -d "*Shape" "*Constraint1" "*Grp";
				$sourceHierarchy = `ls -sl`;
				
				select -hi $destinationParent[0];
				select -d "*Shape" "*Constraint1" "*Grp";
				$destinationHierarchy = `ls -sl`;

				//CHECK TO SEE IF SOURCE AND DESTINATION HAVE SAME NUMBER OF NODES				
				if (`size $sourceHierarchy` == `size $destinationHierarchy`)
				{
					//select $sourceParent[0] $destinationParent[0];
					RRM_TransferModTransforms_V12_V1($sourceParent[0], $destinationParent[0]);
				}
				else
				{
					string $returnVal_Generate = `confirmDialog
						-title "The Source And Destination Branches Have A Different Number Of Nodes."
						-message "The results may not transfer properly.\nProceed?"
						-button "OK" -button "Cancel"
						-defaultButton "OK"
						-cancelButton "Cancel"
						-icon "question"`;
					if ($returnVal_Generate == "OK") 
					{
						//select $sourceParent[0] $destinationParent[0];
						RRM_TransferModTransforms_V12_V1($sourceParent[0], $destinationParent[0]);
					}
				}
			}
			else
			{
				string $returnVal_Generate = `confirmDialog
					-title "The Modules Are Not Of The Same Type."
					-message "The results may not transfer properly.\nProceed?"
					-button "OK" -button "Cancel"
					-defaultButton "OK"
					-cancelButton "Cancel"
					-icon "question"`;
				if ($returnVal_Generate == "OK") 
				{
					//select $sourceParent[0] $destinationParent[0];
					RRM_TransferModTransforms_V12_V1($sourceParent[0], $destinationParent[0]);
				}
			}
		}
	}
	else
	{
		string $returnVal_Generate = `confirmDialog
			-title "Wrong Number Of Objects Seleted"
			-message "Select ONE target node followed by ONE destination node that you want to match to.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	select $originalSelection;
}

//SAVE/LOAD PROXY TRANSFORMS//////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

global proc RRM_WritePathProxyTransforms_V1()
{
	int $mayaVer = `about -version`;
	string $mayaFolder;
	string $fileName[];	

	if (`objExists "RRM_MAIN"` && `objExists "RRM_ROOT"`)
	{
		if ($mayaVer > 2011)
		{
			$fileFilter = "RRM Proxy Transforms (.rrmprox) (*.rrmprox)";
			$fileName = `fileDialog2 -cap "Save Proxy Positions" -fileFilter $fileFilter -selectFileFilter $fileFilter`;
			if ($fileName[0] != "")
			{
				RRM_SaveProxyTransforms_V1("empty", $fileName[0], "empty");
			}
		}
		else
		{
			fileBrowserDialog -mode 1
			-fileCommand ( "RRM_SaveProxyTransforms_V1 \"" + $mayaFolder + "\"" )
			-actionName "Save";
		}
    }
    else
 	{
		string $returnVal_Generate = `confirmDialog
			-title "No Modular Proxy Rig Exists"
			-message "You must first create a modular proxy rig that you wish to save the transforms from.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}   	
}


global proc RRM_SaveProxyTransforms_V1(string $mayaFolder, string $result, string $type)
{
	print ("\nSAVING TO: "+ $result + "\n");
	$fileID = `fopen $result "w"`;
		
	$originalSelection = `ls -sl`;
	$proxies = `ls -sl`;
	
		select -hi RRM_MAIN;
		$hierarchy = `ls -sl`;
		string $crntProxy;
		for ($crntProxy in $hierarchy)
		{
		    if (`objExists ($crntProxy + ".core")`)
		    {
		        $proxies = `ls $proxies $crntProxy`;
		    }
		}
	
	for ($crntProxy in $proxies)
	{
		fprint $fileID ("if (`objExists " + $crntProxy + "`) {");
		
		if (`getAttr -lock ($crntProxy + ".tx")` == 0)
		{
			$crntTX = `getAttr ($crntProxy + ".tx")`;
			fprint $fileID ("setAttr " + $crntProxy + ".tx "+ $crntTX +"; ");
		}
		if (`getAttr -lock ($crntProxy + ".ty")` == 0)
		{
			$crntTY = `getAttr ($crntProxy + ".ty")`;
			fprint $fileID ("setAttr " + $crntProxy + ".ty "+ $crntTY +"; ");
		}
		if (`getAttr -lock ($crntProxy + ".tz")` == 0)
		{
			$crntTZ = `getAttr ($crntProxy + ".tz")`;
			fprint $fileID ("setAttr " + $crntProxy + ".tz "+ $crntTZ +"; ");
		}		

		if (`getAttr -lock ($crntProxy + ".rx")` == 0)
		{
			$crntRX = `getAttr ($crntProxy + ".rx")`;
			fprint $fileID ("setAttr " + $crntProxy + ".rx "+ $crntRX +"; ");
		}
		if (`getAttr -lock ($crntProxy + ".ry")` == 0)
		{
			$crntRY = `getAttr ($crntProxy + ".ry")`;
			fprint $fileID ("setAttr " + $crntProxy + ".ry "+ $crntRY +"; ");
		}
		if (`getAttr -lock ($crntProxy + ".rz")` == 0)
		{
			$crntRZ = `getAttr ($crntProxy + ".rz")`;
			fprint $fileID ("setAttr " + $crntProxy + ".rz "+ $crntRZ +"; ");
		}		

		if (`getAttr -lock ($crntProxy + ".sx")` == 0)
		{
			$crntSX = `getAttr ($crntProxy + ".sx")`;
			fprint $fileID ("setAttr " + $crntProxy + ".sx "+ $crntSX +"; ");
		}
		if (`getAttr -lock ($crntProxy + ".sy")` == 0)
		{
			$crntSY = `getAttr ($crntProxy + ".sy")`;
			fprint $fileID ("setAttr " + $crntProxy + ".sy "+ $crntSY +"; ");
		}
		if (`getAttr -lock ($crntProxy + ".sz")` == 0)
		{
			$crntSZ = `getAttr ($crntProxy + ".sz")`;
			fprint $fileID ("setAttr " + $crntProxy + ".sz "+ $crntSZ +"; ");
		}
		fprint $fileID "}\n";

	}
	fclose $fileID;
	select $originalSelection;		
}


global proc RRM_ReadPathProxyTransform_V1()
{
	int $mayaVer = `about -version`;
	
	string $mayaFolder2;
	string $fileName[];

	if (`objExists "RRM_MAIN"` && `objExists "RRM_ROOT"`)
	{
		if ($mayaVer > 2011)
		{
			$fileFilter = "RRM Proxy Transforms (.rrmprox) (*.rrmprox)";
			$fileName = `fileDialog2 -fileMode 1 -cap "Load Proxy Positions" -fileFilter $fileFilter -selectFileFilter $fileFilter`;
			if ($fileName[0] != "")
			{
				RRM_LoadModProxyTransforms_V1("empty", $fileName[0], "empty");
			}
		}
		else
		{
			fileBrowserDialog -mode 0
			-fileCommand ( "RRM_LoadModProxyTransforms_V1 \"" + $mayaFolder2 + "\"" )
			-actionName "Load";
		}
    }
    else
 	{
		string $returnVal_Generate = `confirmDialog
			-title "No Modular Proxy Rig Exists"
			-message "You must first create a modular proxy rig that you wish to load the transforms to.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
}

global proc RRM_LoadModProxyTransforms_V1(string $mayaFolder2, string $result2, string $type2)
{
	//FILE PATH
	print ("LOADING POSE FROM "+$result2+"...\n");
	//OPEN FILE FOR READING
	$fileID = `fopen $result2 "r"`;
	//GET FIRST LINE
	string $nextLine = `fgetline $fileID`;
	//LOOP
	while (size($nextLine) > 0)
	{
		eval ($nextLine);
		print ($nextLine);
		$nextLine = `fgetline $fileID`;
	}
	//RETURN ARRAY
	fclose $fileID;
}

//SAVE/LOAD PROXY SETUP///////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

global proc RRM_WritePathProxySetup_V1()
{
	int $mayaVer = `about -version`;
	
	string $mayaFolder;
	string $fileName[];

	if (`objExists "RRM_MAIN"` && `objExists "RRM_ROOT"`)
	{
		if ($mayaVer > 2011)
		{
			$fileFilter = "RRM Proxy Setup (.rrmsstp) (*.rrmsstp)";
			$fileName = `fileDialog2 -cap "Save Proxy Setup" -fileFilter $fileFilter -selectFileFilter $fileFilter`;
			if ($fileName[0] != "")
			{
				RRM_SaveProxySetup_V1("empty", $fileName[0], "empty");
			}
		}
		else
		{
			fileBrowserDialog -mode 1
			-fileCommand ( "RRM_SaveProxySetup_V1 \"" + $mayaFolder + "\"" )
			-actionName "Save";
		}
    }
    else
 	{
		string $returnVal_Generate = `confirmDialog
			-title "No Modular Proxy Rig Exists"
			-message "You must first create a modular proxy rig that you wish to save to a setup file.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}    
}


global proc RRM_SaveProxySetup_V1(string $mayaFolder, string $result, string $type)
{
	print ("\nSAVING TO: "+ $result + "\n");
	$fileID = `fopen $result "w"`;
		
	$originalSelection = `ls -sl`;
	string $proxies[];
	string $modules[];
	
	
		select -hi RRM_MAIN;
		$hierarchy = `ls -sl`;
		
		//FIND MODULE NODES
		for ($crntProxy in $hierarchy)
		{
		    if (`objExists ($crntProxy + ".core")`)
		    {
		        $proxies = `ls $proxies $crntProxy`;
		    }
		}
		
		//FIND PROXIES
		for ($crntProxy in $hierarchy)
		{
		    if (`objExists ($crntProxy + ".top")`)
		    {
		        $modules = `ls $modules $crntProxy`;
		    }
		}
		
		//CREATE MAIN AND ROOT PROXIES
		fprint $fileID "RRM_CreateProxyMainProxy_V1(0);\n";
		
		//CREATE MODULES
		for ($each in $modules)
		{
			//CHECK TYPE OF MODULE, MOD NAME, ATTACH NODE
			string $modType = `getAttr ($each + ".top")`;
			string $modName = `getAttr ($each + ".core")`;
			string $attachNode = `getAttr ($each + ".parent")`;
			$attachNode = ("RRM_" + $attachNode);
			int $mirror = 0;
			int $single;
			if (`objExists ($each + ".pair")`)
			{
				$mirror = 1;
				if ($modType == "arm"||$modType == "leg")
				{
					$mirror = 2;
				}
			}
			else if ($modType == "arm")
			{
				string $single = `getAttr ($each + ".single")`;
				if ($single == "left")
				{
					$mirror = 1;
				}
				if ($single == "right")
				{
					$mirror = 3;
				}
			}
			else if ($modType == "leg")
			{
				$mirror = 1;
			}
			
			
			//DEFINE CUSTOM ATTRIBUTES OF EACH MODULE
			//SPLINE
			int $splineNum;
			int $twistAxis;
			//ARM/LEG
			int $upperNum;
			int $lowerNum;
			int $elbowNum;
			int $elbowJoints;
			int $kneeNum;
			int $kneeJoints;
			int $toon;
			//FK CHAIN
			int $chainNum;
			int $jointNum;
			int $direction;
			int $enableIK;
			//HEAD
			int $jaw;
			//LOOKAT
			int $eyeNum;

			//SELECT
			fprint $fileID ("select " + $attachNode + ";\n");
			
			if ($modType == "spline")
			{
				$splineNum = `getAttr ($each + ".jointsNum")`;
				$twistAxis = 2;
				if (`objExists ($each + ".twistAxis")`)
				{
					$twistAxis = `getAttr ($each + ".twistAxis")`;
					$twistAxis++;
				}
				fprint $fileID ("RRM_CreateProxySpline_V1(\"" + $modName + "\"," + $splineNum + "," + $twistAxis + "," + $mirror + ");\n");
			}
			if ($modType == "arm")
			{
				$upperNum = `getAttr ($each + ".upperArmNum")`;
				$lowerNum = `getAttr ($each + ".lowerArmNum")`;
				$elbowNum = `getAttr ($each + ".elbowNum")`;
				$elbowJoints = `getAttr ($each + ".elbowJoints")`;
				fprint $fileID ("RRM_CreateProxyArm_V1(\"" + $modName + "\"," + $upperNum + "," + $lowerNum + "," + $elbowNum + "," + $elbowJoints + "," + $toon + "," + $mirror + ");\n");
			}
			if ($modType == "leg")
			{
				$upperNum = `getAttr ($each + ".upperLegNum")`;
				$lowerNum = `getAttr ($each + ".lowerLegNum")`;
				$kneeNum = `getAttr ($each + ".kneeNum")`;
				$kneeJoints = `getAttr ($each + ".kneeJoints")`;
				fprint $fileID ("RRM_CreateProxyLeg_V1(\"" + $modName + "\"," + $upperNum + "," + $lowerNum + "," + $kneeNum + "," + $kneeJoints + "," + $toon + "," + $mirror + ");\n");
			}
			if ($modType == "fkChain")
			{
				$chainNum = `getAttr ($each + ".chainsNum")`;
				$jointNum = `getAttr ($each + ".jointsNum")`;
				$direction = `getAttr ($each + ".direction")`;
				$direction2 = `getAttr ($each + ".direction")`;
				if ($direction > 3)
				{
					$direction2 = ($direction2 - 3);
					$direction = 0;
				}
				else
				{
					$direction2 = 0;
				}
				if (`objExists ($each + ".ikEnabled")`)
				{
					$enableIK = `getAttr ($each + ".ikEnabled")`;
					fprint $fileID ("RRM_CreateProxyFKChain_V1(\"" + $modName + "\"," + $chainNum + "," + $jointNum + "," + $direction + "," + $direction2 + "," + $mirror + "," + $enableIK + ");\n");
				}
			}
			if ($modType == "head")
			{
				$jaw = `getAttr ($each + ".jaw")`;
				fprint $fileID ("RRM_CreateProxyHead_V1(\"" + $modName + "\"," + $jaw + "," + $mirror + ");\n");
			}
			if ($modType == "lookAt")
			{
				$eyeNum = `getAttr ($each + ".eyeNum")`;
				$direction = `getAttr ($each + ".direction")`;
				$direction2 = `getAttr ($each + ".direction")`;
				if ($direction > 3)
				{
					$direction2 = ($direction2 - 3);
					$direction = 0;
				}
				else
				{
					$direction2 = 0;
				}
				fprint $fileID ("RRM_CreateProxyLookAt_V1(\"" + $modName + "\"," + $eyeNum + "," + $direction + "," + $direction2 + "," + $mirror + ");\n");
			}
			if ($modType == "auxiliary")
			{
				fprint $fileID ("RRM_CreateProxyAuxiliary_V1(\"" + $modName + "\"," + $mirror + ");\n");
			}
		}
			
				
	
	for ($crntProxy in $proxies)
	{
		fprint $fileID ("if (`objExists " + $crntProxy + "`) {");
		
		//SET PINNING
		if (`objExists ($crntProxy + ".pinned")`)
		{
			$pinned = `getAttr ($crntProxy + ".pinned")`;
			if ($pinned == 1)
			{
				fprint $fileID ("select " + $crntProxy + "; ");
				fprint $fileID ("RRM_PinProxies_V1(1, 0); ");
			}
		}
		
		if (`getAttr -lock ($crntProxy + ".tx")` == 0)
		{
			$crntTX = `getAttr ($crntProxy + ".tx")`;
			fprint $fileID ("setAttr " + $crntProxy + ".tx "+ $crntTX +"; ");
		}
		if (`getAttr -lock ($crntProxy + ".ty")` == 0)
		{
			$crntTY = `getAttr ($crntProxy + ".ty")`;
			fprint $fileID ("setAttr " + $crntProxy + ".ty "+ $crntTY +"; ");
		}
		if (`getAttr -lock ($crntProxy + ".tz")` == 0)
		{
			$crntTZ = `getAttr ($crntProxy + ".tz")`;
			fprint $fileID ("setAttr " + $crntProxy + ".tz "+ $crntTZ +"; ");
		}		

		if (`getAttr -lock ($crntProxy + ".rx")` == 0)
		{
			$crntRX = `getAttr ($crntProxy + ".rx")`;
			fprint $fileID ("setAttr " + $crntProxy + ".rx "+ $crntRX +"; ");
		}
		if (`getAttr -lock ($crntProxy + ".ry")` == 0)
		{
			$crntRY = `getAttr ($crntProxy + ".ry")`;
			fprint $fileID ("setAttr " + $crntProxy + ".ry "+ $crntRY +"; ");
		}
		if (`getAttr -lock ($crntProxy + ".rz")` == 0)
		{
			$crntRZ = `getAttr ($crntProxy + ".rz")`;
			fprint $fileID ("setAttr " + $crntProxy + ".rz "+ $crntRZ +"; ");
		}		

		if (`getAttr -lock ($crntProxy + ".sx")` == 0)
		{
			$crntSX = `getAttr ($crntProxy + ".sx")`;
			fprint $fileID ("setAttr " + $crntProxy + ".sx "+ $crntSX +"; ");
		}
		if (`getAttr -lock ($crntProxy + ".sy")` == 0)
		{
			$crntSY = `getAttr ($crntProxy + ".sy")`;
			fprint $fileID ("setAttr " + $crntProxy + ".sy "+ $crntSY +"; ");
		}
		if (`getAttr -lock ($crntProxy + ".sz")` == 0)
		{
			$crntSZ = `getAttr ($crntProxy + ".sz")`;
			fprint $fileID ("setAttr " + $crntProxy + ".sz "+ $crntSZ +"; ");
		}
		fprint $fileID "}\n";

	}
	fprint $fileID "select -cl;";
	fclose $fileID;
	select $originalSelection;		
}


global proc RRM_ReadPathProxySetup_V1()
{
	int $mayaVer = `about -version`;
	
	string $mayaFolder2;
	string $fileName[];

	if (!`objExists "RRM_MAIN"` || !`objExists "RRM_ROOT"`)
	{
		if ($mayaVer > 2011)
		{
			$fileFilter = "RRM Proxy Setup (.rrmsstp) (*.rrmsstp) ";
			$fileName = `fileDialog2 -fileMode 1 -cap "Load Proxy Setup" -fileFilter $fileFilter -selectFileFilter $fileFilter`;
			if ($fileName[0] != "")
			{
				RRM_LoadModProxySetup_V1("empty", $fileName[0], "empty");
			}
		}
		else
		{
			fileBrowserDialog -mode 0
			-fileCommand ( "RRM_LoadModProxySetup_V1 \"" + $mayaFolder2 + "\"" )
			-actionName "Load";
		}
    }
    else
 	{
		string $returnVal_Generate = `confirmDialog
			-title "Proxy Rig Already Exists"
			-message "You must first delete the existing proxy rig to load a new one. Do you wish to delete the proxy rig and then load a proxy?.\n"
			-button "Yes"
			-button "Cancel"
			-defaultButton "Cancel"
			-cancelButton "Cancel"
			-icon "critical"`;
			
			if ($returnVal_Generate == "Yes")
			{
				RRM_DeleteProxyRig_V1;
				fileBrowserDialog -mode 0
				-fileCommand ( "RRM_LoadModProxySetup_V1 \"" + $mayaFolder2 + "\"" )
				-actionName "Load";
			}
	}   
}

global proc RRM_LoadModProxySetup_V1(string $mayaFolder2, string $result2, string $type2)
{
	//FILE PATH
	print ("LOADING POSE FROM "+$result2+"...\n");
	//OPEN FILE FOR READING
	$fileID = `fopen $result2 "r"`;
	//GET FIRST LINE
	string $nextLine = `fgetline $fileID`;
	//LOOP
	while (size($nextLine) > 0)
	{
		eval ($nextLine);
		print ($nextLine);
		$nextLine = `fgetline $fileID`;
	}
	//RETURN ARRAY
	fclose $fileID;
}


///////////////////TUTORIAL LINKS
global proc RRM_GotToTutorial_V1(float $time)
{
	launch -web ("https://youtu.be/sX_iUaE70iQ?t=" + $time);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE FINAL RIG//////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

global proc RRM_ColorControls_V1(string $modName)
{
	//LEFT
	//MAIN BLUE IS 6
	//SECONDARY BLUE IS 18
	
	//RIGHT
	//MAIN RED IS 13
	//SECONDARY RED IS 21
	
	//CENTER
	//MAIN GREEN IS 14
	//SECONDARY GREEN IS 27
	
	select -hi ($modName + "_MAINCtrl");
	
	$controls= `ls -sl -type "nurbsCurve"`;
	string $crnt;
	for ($crnt in $controls)
	{
		$crntParent = `listRelatives -parent $crnt`;
		string $parentNode = $crntParent[0];
		
		if (`objExists ($parentNode + ".modRigName")`)
		{
			if (!`objExists ($parentNode + ".leftControl")` && !`objExists ($parentNode + ".rightControl")`)
			{
				if (!`gmatch $parentNode ($modName + "_*Curve*Ctrl")`)
				{//MAIN NON-MIRRORED CONTROLS
					setAttr ($crnt + ".overrideEnabled") 1;
					setAttr ($crnt + ".overrideColor") 14;
				}
				else
				{//MAIN NON-MIRRORED CURVE CONTROLS
					setAttr ($crnt + ".overrideEnabled") 1;
					setAttr ($crnt + ".overrideColor") 27;
				}
			}
			else
			{//MIRRORED CONTROLS
				if (`objExists ($parentNode + ".rightControl")`)
				{//RIGHT CONTROLS
					if (!`gmatch $parentNode ($modName + "_*Curve*Ctrl")` && !`gmatch $parentNode ($modName + "_*TwistCtrl")`)
					{//MAIN NON-MIRRORED CONTROLS
						setAttr ($crnt + ".overrideEnabled") 1;
						setAttr ($crnt + ".overrideColor") 6;
					}
					else
					{
						setAttr ($crnt + ".overrideEnabled") 1;
						setAttr ($crnt + ".overrideColor") 18;
					}					
				}
				else if (`objExists ($parentNode + ".leftControl")`)
				{//LEFT CONTROLS
					if (!`gmatch $parentNode ($modName + "_*Curve*Ctrl")` && !`gmatch $parentNode ($modName + "_*TwistCtrl")`)
					{//MAIN NON-MIRRORED CONTROLS
						setAttr ($crnt + ".overrideEnabled") 1;
						setAttr ($crnt + ".overrideColor") 13;
					}
					else
					{
						setAttr ($crnt + ".overrideEnabled") 1;
						setAttr ($crnt + ".overrideColor") 21;
					}					
				}
			}
		}
	}
}


//ADD CORE NAME
global proc RRM_CoreName_V1(string $modControls[])
{
	for ($crntModControl in $modControls)
	{
		addAttr -ln "modCoreName"  -dt "string" $crntModControl;
		setAttr -e-keyable 1 ($crntModControl + ".modCoreName");
	}
}

//ADD CONTROL NAME
global proc RRM_ControlName_V1(string $modName, string $modControls[])
{
	for ($crntModControl in $modControls)
	{
		string $controlName = endString($crntModControl, (`size($crntModControl)` - `size($modName)`));
		
		addAttr -ln "modControlName" -dt "string" $crntModControl;
		setAttr -e-keyable 1 ($crntModControl + ".modControlName");
		setAttr -type "string" ($crntModControl + ".modControlName") $controlName;
		setAttr -lock 1 -keyable 0 ($crntModControl + ".modControlName");
	}
}

//SET UP ORIENTATION TO PARENT NODE
global proc RRM_ParentOrient_V1(string $modCore, string $modName, string $modAttachNode, string $parentOrient)
{
	if ($modAttachNode != "ROOT")
	{
		addAttr -ln "parentOrient" -at double -min 0 -max 1 -dv 1 $parentOrient;
		setAttr -e-keyable 1 ($parentOrient + ".parentOrient");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_orientConstraint1." + $modName + "_" + $modAttachNode + "JntW1");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_ScaleGrp_orientConstraint1." + $modName + "_" + $modAttachNode + "JntW1");
	}
	else
	{
		addAttr -ln "ROOT_Parent"  -at "enum" -en "ROOT:ROOTSecondary:"  $parentOrient;
		setAttr -e-keyable 1 ($parentOrient + ".ROOT_Parent");
		addAttr -ln "parentOrient" -at double  -min 0 -max 1 -dv 1 $parentOrient;
		setAttr -e-keyable 1 ( $parentOrient + ".parentOrient");		
        
		//CREATE NODES FOR BLENDING BETWEEN THE TWO ROOT CHOICES AND MAIN CONTROL
		
		//MODULE GROUP
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ParentMD");
		shadingNode -asUtility reverse -n ($modCore + "_ParentReverse");
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ParentMD.input2X");
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ParentReverse.inputX");
		connectAttr -force ($modCore + "_ParentReverse.outputX") ($modCore + "_ParentMD.input2Y");
		setAttr ($modCore + "_ParentMD.input1X") 1;
		setAttr ($modCore + "_ParentMD.input1Y") 1;
		
		//SECOND MULTIPLY DIVIDE TO ZERO OUT BOTH ROOT CHOICES WHEN PARENT ORIENT SET TO ZERO
		shadingNode -asUtility multiplyDivide -n ($modCore + "_Parent2MD");
		connectAttr -force ($modCore + "_ParentMD.outputX") ($modCore + "_Parent2MD.input1X");
		connectAttr -force ($modCore + "_ParentMD.outputY") ($modCore + "_Parent2MD.input1Y");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_Parent2MD.input2X");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_Parent2MD.input2Y");
		
		//CONNECT MULTIPLY/DIVIDE TO ORIENT CONSTRAINT
		connectAttr -force ($modCore + "_Parent2MD.outputY") ($modCore + "_orientConstraint1." + $modName + "_ROOTCtrlW1");
		connectAttr -force ($modCore + "_Parent2MD.outputX") ($modCore + "_orientConstraint1." + $modName + "_ROOTJntW2");
		
		connectAttr -force ($modCore + "_Parent2MD.outputY") ($modCore + "_pointConstraint1." + $modName + "_ROOTCtrlW1");
		connectAttr -force ($modCore + "_Parent2MD.outputX") ($modCore + "_pointConstraint1." + $modName + "_ROOTJntW0");
				
		//MODULE SCALEG
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ScaleGrp_ParentMD");
		shadingNode -asUtility reverse -n ($modCore + "_ScaleGrp_ParentReverse");
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ScaleGrp_ParentMD.input2X");
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ScaleGrp_ParentReverse.inputX");
		connectAttr -force ($modCore + "_ScaleGrp_ParentReverse.outputX") ($modCore + "_ScaleGrp_ParentMD.input2Y");
		setAttr ($modCore + "_ScaleGrp_ParentMD.input1X") 1;
		setAttr ($modCore + "_ScaleGrp_ParentMD.input1Y") 1;
		
		//SECOND MULTIPLY DIVIDE TO ZERO OUT BOTH ROOT CHOICES WHEN PARENT ORIENT SET TO ZERO
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ScaleGrp_Parent2MD");
		connectAttr -force ($modCore + "_ScaleGrp_ParentMD.outputX") ($modCore + "_ScaleGrp_Parent2MD.input1X");
		connectAttr -force ($modCore + "_ScaleGrp_ParentMD.outputY") ($modCore + "_ScaleGrp_Parent2MD.input1Y");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_ScaleGrp_Parent2MD.input2X");
		connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_ScaleGrp_Parent2MD.input2Y");
		
		//CONNECT MULTIPLY/DIVIDE TO ORIENT CONSTRAINT
		connectAttr -force ($modCore + "_ScaleGrp_Parent2MD.outputY") ($modCore + "_ScaleGrp_orientConstraint1." + $modName + "_ROOTCtrlW1");
		connectAttr -force ($modCore + "_ScaleGrp_Parent2MD.outputX") ($modCore + "_ScaleGrp_orientConstraint1." + $modName + "_ROOTJntW2");
	    
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ScaleGrp_parentConstraint1." + $modName + "_ROOTJntW0");
		
		shadingNode -asUtility reverse -n ($modCore + "_ScaleGrp_Parent2Reverse");
		connectAttr -force ($parentOrient + ".ROOT_Parent") ($modCore + "_ScaleGrp_Parent2Reverse.inputX");

		connectAttr -force ($modCore + "_ScaleGrp_Parent2Reverse.outputX") ($modCore + "_ScaleGrp_parentConstraint1." + $modName + "_ROOTCtrlW1");
		
		//CHECK IF LEG, AND CHANGE TO ROOT Secondary
		if (`objExists ($modCore + "_FootIKCtrl")`)
		{
			setAttr ($parentOrient + ".ROOT_Parent") 1;
		}
	}
	//MODULE
	shadingNode -asUtility reverse -n ($modCore + "_ParentOrientReverse");
	connectAttr -force ($parentOrient + ".parentOrient") ($modCore + "_ParentOrientReverse.inputX");
	connectAttr -force ($modCore + "_ParentOrientReverse.outputX") ($modCore + "_orientConstraint1." + $modCore + "_OffsetLctrW0");
	connectAttr -force ($modCore + "_ParentOrientReverse.outputX") ($modCore + "_ScaleGrp_orientConstraint1." + $modCore + "_OffsetLctrW0");
	if (`objExists ($modCore + "_pointConstraint1." + $modName + "_ROOTLocLctrW2")`)
	{
		connectAttr -force ($modCore + "_ParentOrientReverse.outputX") ($modCore + "_pointConstraint1." + $modName + "_ROOTLocLctrW2");
	}	
}


////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE ROOT MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRig_V1Root_V1(string $modName)
{
	$twistAxis = 1;
	if (`objExists ("RRM_ROOT.twistAxis")`)
	{
		$twistAxis = `getAttr ("RRM_ROOT.twistAxis")`;
	}
	//CREATE TOP GROUP
	select -cl;
	group -em -n $modName;
	//CREATE MAIN CONTROLLER///////////////////////////////////////////////////////////////
	circle -n ($modName + "_MAINCtrl") -nr 0 1 0 -r 8 -ch 0;
	curve -n ($modName + "_Arrow1") -d 1 -p 3 0 8 -p 3 0 9 -p 5 0 9 -p 0 0 12 -p -5 0 9 -p -3 0 9 -p -3 0 8 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 ;
	rename `listRelatives -c ($modName + "_Arrow1")` ($modName + "_Arrow1Shape");
	circle -n ($modName + "_Outer1") -nr 0 1 0 -sw 48.9 -r 8.545 -ch 0;
	rotate -r 0 110.55 0 ($modName + "_Outer1");
	duplicate -rr ($modName + "_Arrow1") ($modName + "_Outer1");
	rotate -r 0 90 0 ($modName + "_Arrow2") ($modName + "_Outer2");
	duplicate -rr ($modName + "_Arrow1") ($modName + "_Outer1");
	rotate -r 0 180 0 ($modName + "_Arrow3") ($modName + "_Outer3");
	duplicate -rr ($modName + "_Arrow1") ($modName + "_Outer1");
	rotate -r 0 270 0 ($modName + "_Arrow4") ($modName + "_Outer4");
	makeIdentity -apply true -r 1 ($modName + "_MAINCtrl") ($modName + "_Arrow1") ($modName + "_Outer1") ($modName + "_Arrow2") ($modName + "_Outer2") ($modName + "_Arrow3") ($modName + "_Outer3") ($modName + "_Arrow4") ($modName + "_Outer4") ;
	parent -r -s ($modName + "_Arrow1Shape") ($modName + "_Outer1Shape") ($modName + "_Arrow2Shape") ($modName + "_Outer2Shape") ($modName + "_Arrow3Shape") ($modName + "_Outer3Shape") ($modName + "_Arrow4Shape") ($modName + "_Outer4Shape") ($modName + "_MAINCtrl");
	delete ($modName + "_Arrow1") ($modName + "_Outer1") ($modName + "_Arrow2") ($modName + "_Outer2") ($modName + "_Arrow3") ($modName + "_Outer3") ($modName + "_Arrow4") ($modName + "_Outer4") ;
	move -r 0 0 2 ($modName + "_Arrow1Shape.cv[3]") ;
	
	//ADD RRM TO THE MAIN CONTROL
	curve -n ($modName + "R1_OuterCurve") -p -0.407227 0 -0.429492 -p -0.263487 0 -0.429492 -p 0.0239912 0 -0.432182 -p 0.153059 0 -0.418734 -p 0.253227 0 -0.330969 -p 0.296535 0 -0.194139 -p 0.237588 0 -0.0195534 -p 0.0868775 0 0.0315034 -p 0.040764 0 0.0378381 -p 0.0375 0 0.0386719 -p 0.0382526 0 0.0396925 -p 0.0951021 0 0.0649485 -p 0.176419 0 0.152211 -p 0.284981 0 0.330214 -p 0.348426 0 0.427287 -p 0.349805 0 0.429492 -p 0.345946 0 0.429492 -p 0.276161 0 0.429492 -p 0.209868 0 0.429492 -p 0.206836 0 0.429492 -p 0.205116 0 0.426765 -p 0.154922 0 0.348158 -p 0.10053 0 0.260202 -p 0.0030441 0 0.11572 -p -0.0459097 0 0.0714475 -p -0.0972157 0 0.0491625 -p -0.149125 0 0.0478205 -p -0.274914 0 0.0480469 -p -0.288614 0 0.0480469 -p -0.293555 0 0.0480469 -p -0.293555 0 0.0510741 -p -0.293555 0 0.125268 -p -0.293493 0 0.202405 -p -0.293493 0 0.398616 -p -0.293555 0 0.428465 -p -0.293555 0 0.429492 -p -0.294535 0 0.429492 -p -0.328353 0 0.429492 -p -0.378561 0 0.429492 -p -0.405499 0 0.429492 -p -0.407227 0 0.429492 -p -0.407227 0 0.428253 -p -0.407227 0 0.405684 -p -0.407227 0 0.328387 -p -0.407227 0 -0.0915302 -p -0.407227 0 -0.429492 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 28 -k 29 -k 30 -k 31 -k 32 -k 33 -k 34 -k 35 -k 36 -k 37 -k 38 -k 39 -k 40 -k 41 -k 42 -k 43 -k 43 -k 43 ;
	rename `listRelatives -c ($modName + "R1_OuterCurve")` ($modName + "R1_OuterCurveShape");
	curve -n ($modName + "R1_InnerCurve") -p -0.293555 0 -0.33457 -p -0.257406 0 -0.33457 -p -0.0889505 0 -0.333847 -p 0.0486942 0 -0.336975 -p 0.14017 0 -0.292901 -p 0.171323 0 -0.194613 -p 0.146198 0 -0.11598 -p 0.0827139 0 -0.0601229 -p -0.0184461 0 -0.0494054 -p -0.159798 0 -0.0503906 -p -0.290636 0 -0.0503906 -p -0.293555 0 -0.0503906 -p -0.293555 0 -0.0540591 -p -0.293555 0 -0.119074 -p -0.293555 0 -0.33457 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 12 -k 12 ;
	rename `listRelatives -c ($modName + "R1_InnerCurve")` ($modName + "R1_InnerCurveShape");
	curve -n ($modName + "M_Curve") -d 1 -p 0.454102 0 0.429492 -p 0.454102 0 -0.429492 -p 0.625195 0 -0.429492 -p 0.869531 0 0.305859 -p 1.120898 0 -0.429492 -p 1.273828 0 -0.429492 -p 1.273828 0 0.429492 -p 1.164258 0 0.429492 -p 1.164258 0 -0.289453 -p 0.914648 0 0.429492 -p 0.812109 0 0.429492 -p 0.563672 0 -0.301758 -p 0.563672 0 0.429492 -p 0.454102 0 0.429492 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 ;
	rename `listRelatives -c ($modName + "M_Curve")` ($modName + "M_CurveShape");
	duplicate -n ($modName + "R2_OuterCurve") ($modName + "R1_OuterCurve");
	duplicate -n ($modName + "R2_InnerCurve") ($modName + "R1_InnerCurve");
	move -r -os -wd -1.5 0 0 ($modName + "R2_InnerCurve") ($modName + "R2_OuterCurve");
	
	scale -r 1.75 1.75 1.75 ($modName + "R1_OuterCurve") ($modName + "R1_InnerCurve") ($modName + "R2_OuterCurve") ($modName + "R2_InnerCurve") ($modName + "M_Curve");
	move -r -ws 0 0 10.4 ($modName + "R1_OuterCurve") ($modName + "R1_InnerCurve") ($modName + "R2_OuterCurve") ($modName + "R2_InnerCurve") ($modName + "M_Curve");
	makeIdentity -apply true -t 1 -r 1 -s 1 ($modName + "R1_OuterCurve") ($modName + "R1_InnerCurve") ($modName + "R2_OuterCurve") ($modName + "R2_InnerCurve") ($modName + "M_Curve");

	select ($modName + "R1_OuterCurveShape") ($modName + "R1_InnerCurveShape") ($modName + "R2_OuterCurveShape") ($modName + "R2_InnerCurveShape") ($modName + "M_CurveShape");
	$RRM_Curves = `ls -sl -type "nurbsCurve"`;
	for ($each in $RRM_Curves)
	{
		parent -r -s $each ($modName + "_MAINCtrl");
		setAttr ($each + ".overrideEnabled") 1;
		setAttr ($each + ".overrideColor") 14;
	}
	delete ($modName + "R1_OuterCurve") ($modName + "R1_InnerCurve") ($modName + "R2_OuterCurve") ($modName + "R2_InnerCurve") ($modName + "M_Curve");

	$mainScale = `getAttr RRM_MAIN.scale`;
	setAttr (($modName + "_MAINCtrl.scale"), $mainScale[0], $mainScale[1], $mainScale[2]);
	makeIdentity -apply true -s 1 ($modName + "_MAINCtrl");
	
	addAttr -ln "masterScale"  -at double  ($modName + "_MAINCtrl");
	setAttr -e-keyable 1 ($modName + "_MAINCtrl.masterScale");
	setAttr ($modName + "_MAINCtrl.masterScale") $mainScale[1];
	setAttr -lock 1 -keyable 0 ($modName + "_MAINCtrl.masterScale");
	
	addAttr -ln "COG_Ctrl_visibility"  -at bool ($modName + "_MAINCtrl");
	setAttr -e-keyable 1 ($modName + "_MAINCtrl.COG_Ctrl_visibility");
	
	//////////////////////////////////LOCK & HIDE//////////////////////////////////
	setAttr -l 1 -k 0 ($modName + "_MAINCtrl.v");
	connectAttr -f ($modName + "_MAINCtrl.scaleY") ($modName + "_MAINCtrl.scaleX");
	connectAttr -f ($modName + "_MAINCtrl.scaleY") ($modName + "_MAINCtrl.scaleZ"); 
	setAttr -l 1 -k 0 ($modName + "_MAINCtrl.scaleX");
	setAttr -l 1 -k 0 ($modName + "_MAINCtrl.scaleZ");
	
	//GET ROOT POSITION
	$rootPos = `xform -q -ws -rp RRM_ROOT`;
	select -cl;
	joint -n ($modName + "_ROOTJnt");
	move -a $rootPos[0] $rootPos[1] $rootPos[2] ($modName + "_ROOTJnt");

	//PARENT CONTROL
	if ($twistAxis == 1)
	{
		circle -n ($modName + "_ROOTParentCtrl") -nr 0 1 0 -sw 315 -r 1.2 -ch 0;
		rotate -r 0 -157.5 0 ($modName + "_ROOTParentCtrl");
		makeIdentity -apply true -r 1 ($modName + "_ROOTParentCtrl");
		curve -n ($modName + "_ROOTParentCtrl1") -d 1 -p 0.459248 0 1.108679 -p 0.459248 0 1.232295 -p 0 0 1.454964 -p -0.459248 0 1.232295 -p -0.459248 0 1.108679 -k 0 -k 1 -k 2 -k 3 -k 4 ;
		rename `listRelatives -c ($modName + "_ROOTParentCtrl1")` ($modName + "_ROOTParentCtrl1Shape");	
		parent -r -s ($modName + "_ROOTParentCtrl1Shape") ($modName + "_ROOTParentCtrl1Shape") ($modName + "_ROOTParentCtrl");
		delete ($modName + "_ROOTParentCtrl1");
		scale -r 1.25 1.25 1.25 ($modName + "_ROOTParentCtrl");
		makeIdentity -apply true -s 1 ($modName + "_ROOTParentCtrl");
	}
	else
	{
		circle -n ($modName + "_ROOTParentCtrl") -nr 1 0 0 -sw 315 -r 6 -ch 0;
		rotate -r -157.5 0 0 ($modName + "_ROOTParentCtrl");
		makeIdentity -apply true -r 1 ($modName + "_ROOTParentCtrl");
		
		curve -n ($modName + "_ROOTParentCtrl1") -d 1 -p 0 -5.543277 -2.296101 -p 0 -6.161475 -2.29624 -p 0 -7.27482 0 -p 0 -6.161475 2.29624 -p 0 -5.543277 2.296101 -k 0 -k 1 -k 2 -k 3 -k 4 ;
		rename `listRelatives -c ($modName + "_ROOTParentCtrl1")` ($modName + "_ROOTParentCtrl1Shape");	
		parent -r -s ($modName + "_ROOTParentCtrl1Shape") ($modName + "_ROOTParentCtrl1Shape") ($modName + "_ROOTParentCtrl");
		delete ($modName + "_ROOTParentCtrl1");
		makeIdentity -apply true -s 1 ($modName + "_ROOTParentCtrl");
	}

	//CREATE COG_Ctrl//////////////////////////////////////////////////////
	if ($twistAxis == 1)
	{
		circle -n ($modName + "_OuterCOG_Ctrl1") -r 12 -nr 0 1 0 -sw 18 -ch 0;
		circle -n ($modName + "_InnerCOG_Ctrl1") -r 11 -nr 0 1 0 -sw 18 -ch 0;
		rotate -r -os 0 -18 0 ($modName + "_InnerCOG_Ctrl1");
		curve -n ($modName + "_LeftConnectorCOG_Ctrl1") -d 1 -p 0 0 -12 -p 0 0 -11 -k 0 -k 1 ;
		rename `listRelatives -c ($modName + "_LeftConnectorCOG_Ctrl1")` ($modName + "_LeftConnectorCOG_Ctrl1Shape");
		duplicate -n ($modName + "_RightConnectorCOG_Ctrl1") ($modName + "_LeftConnectorCOG_Ctrl1");
		rotate  -r -os 0 -18 0 ($modName + "_LeftConnectorCOG_Ctrl1");
		
		select ($modName + "_OuterCOG_Ctrl1") ($modName + "_InnerCOG_Ctrl1") ($modName + "_LeftConnectorCOG_Ctrl1") ($modName + "_RightConnectorCOG_Ctrl1");
		
		duplicate -rr; rotate -r 0 36 0; for ($i=1; $i<9; ++$i) duplicate -rr -st;
		select ($modName + "_*COG_Ctrl?") ($modName + "_*COG_Ctrl??");
		makeIdentity -apply true -t 1 -r 1 -s 1;
		select -d ($modName + "_OuterCOG_Ctrl1");
		$transforms = `ls -sl`;
		pickWalk -d down;
		$shapes = `ls -sl`;
		parent -r -s $shapes ($modName + "_OuterCOG_Ctrl1");
		delete $transforms;
		rename ($modName + "_OuterCOG_Ctrl1") ($modName + "_COG_Ctrl");
		
		scale -r .7 .7 .7 ($modName + "_COG_Ctrl");
		rotate -r 0 -9 0 ($modName + "_COG_Ctrl");
		makeIdentity -apply true -r 1 -s 1 ($modName + "_COG_Ctrl");
		delete `scaleConstraint RRM_COG ($modName + "_COG_Ctrl")`;
		makeIdentity -apply true -s 1 ($modName + "_COG_Ctrl");
	
		group -n ($modName + "_COG_CtrlGrp") ($modName + "_COG_Ctrl");
		delete `parentConstraint RRM_COG ($modName + "_COG_CtrlGrp")`;		
	}
	else
	{
		circle -n ($modName + "_OuterCOG_Ctrl1") -r 12 -nr 1 0 0 -sw 18 -ch 0;
		circle -n ($modName + "_InnerCOG_Ctrl1") -r 11 -nr 1 0 0 -sw 18 -ch 0;
		rotate -r -os -18 0 0 ($modName + "_InnerCOG_Ctrl1");
		curve -n ($modName + "_LeftConnectorCOG_Ctrl1") -d 1 -p 0 12 0 -p 0 11 0 -k 0 -k 1 ;
		rename `listRelatives -c ($modName + "_LeftConnectorCOG_Ctrl1")` ($modName + "_LeftConnectorCOG_Ctrl1Shape");
		duplicate -n ($modName + "_RightConnectorCOG_Ctrl1") ($modName + "_LeftConnectorCOG_Ctrl1");
		rotate  -r -os -18 0 0 ($modName + "_LeftConnectorCOG_Ctrl1");
		
		select ($modName + "_OuterCOG_Ctrl1") ($modName + "_InnerCOG_Ctrl1") ($modName + "_LeftConnectorCOG_Ctrl1") ($modName + "_RightConnectorCOG_Ctrl1");
		
		duplicate -rr; rotate -r 36 0 0; for ($i=1; $i<9; ++$i) duplicate -rr -st;
		select ($modName + "_*COG_Ctrl?") ($modName + "_*COG_Ctrl??");
		makeIdentity -apply true -t 1 -r 1 -s 1;
		select -d ($modName + "_OuterCOG_Ctrl1");
		$transforms = `ls -sl`;
		$shapes = `listRelatives -c $transforms`;
		parent -r -s $shapes ($modName + "_OuterCOG_Ctrl1");
		delete $transforms;
		rename ($modName + "_OuterCOG_Ctrl1") ($modName + "_COG_Ctrl");
		
		scale -r .7 .7 .7 ($modName + "_COG_Ctrl");
		rotate -r -9 0 0 ($modName + "_COG_Ctrl");
		makeIdentity -apply true -r 1 -s 1 ($modName + "_COG_Ctrl");
		delete `scaleConstraint RRM_COG ($modName + "_COG_Ctrl")`;
		makeIdentity -apply true -s 1 ($modName + "_COG_Ctrl");
	
		group -n ($modName + "_COG_CtrlGrp") ($modName + "_COG_Ctrl");
		delete `parentConstraint RRM_COG ($modName + "_COG_CtrlGrp")`;
		rotate -r -os -90 0 90 ($modName + "_COG_CtrlGrp");
	}

	parent ($modName + "_COG_CtrlGrp") ($modName + "_MAINCtrl");
	
	connectAttr -f ($modName + "_MAINCtrl.COG_Ctrl_visibility") ($modName + "_COG_CtrlGrp.v");
	
	
	//ADD CORE NAME
	addAttr -ln "isCOG_Ctrl"  -dt "string" ($modName + "_COG_Ctrl");
	setAttr -e-keyable 1 ($modName + "_COG_Ctrl.isCOG_Ctrl");
	setAttr -e-lock 1 ($modName + "_COG_Ctrl.isCOG_Ctrl");
	
	setAttr ($modName + "_COG_Ctrl.overrideEnabled") 1;
	setAttr ($modName + "_COG_Ctrl.overrideColor") 19;
	


	setAttr -lock 1 -keyable 0 ($modName + "_COG_Ctrl.sx");
	setAttr -lock 1 -keyable 0 ($modName + "_COG_Ctrl.sy");
	setAttr -lock 1 -keyable 0 ($modName + "_COG_Ctrl.sz");
	setAttr -lock 1 -keyable 0 ($modName + "_COG_Ctrl.v");
	
	setAttr -lock 1 -keyable 0 ($modName + "_COG_CtrlGrp.tx");
	setAttr -lock 1 -keyable 0 ($modName + "_COG_CtrlGrp.ty");
	setAttr -lock 1 -keyable 0 ($modName + "_COG_CtrlGrp.tz");
	setAttr -lock 1 -keyable 0 ($modName + "_COG_CtrlGrp.rx");
	setAttr -lock 1 -keyable 0 ($modName + "_COG_CtrlGrp.ry");
	setAttr -lock 1 -keyable 0 ($modName + "_COG_CtrlGrp.rz");
	setAttr -lock 1 -keyable 0 ($modName + "_COG_CtrlGrp.sx");
	setAttr -lock 1 -keyable 0 ($modName + "_COG_CtrlGrp.sy");
	setAttr -lock 1 -keyable 0 ($modName + "_COG_CtrlGrp.sz");
	setAttr -lock 1 -keyable 0 ($modName + "_COG_CtrlGrp.v");
	
	//CREATE MOVEABLE PIVOT CONTROL
	circle -n ($modName + "_PivotCtrl_Outer1") -nr 0 1 0 -sw 10 -r .25 -ch 0;
	
	circle -n ($modName + "_PivotCtrl_Inner1") -nr 0 1 0 -sw 10 -r 2 -ch 0;
	
	curve -n ($modName + "_PivotCtrl_leftLine1") -d 1 -p 0 0 -0.25 -p 0 0 -2 -k 0 -k 1 ;
	rename `listRelatives -c ($modName + "_PivotCtrl_leftLine1")` ($modName + "_PivotCtrl_leftLine1Shape");
	curve -n ($modName + "_PivotCtrl_rightLine1") -d 1 -p -0.043412 0 -0.246202 -p -0.347296 0 -1.969616 -k 0 -k 1 ;
	rename `listRelatives -c ($modName + "_PivotCtrl_rightLine1")` ($modName + "_PivotCtrl_RightLine1Shape");
	
	parent -r -s ($modName + "_PivotCtrl_Inner1Shape") ($modName + "_PivotCtrl_leftLine1Shape") ($modName + "_PivotCtrl_RightLine1Shape") ($modName + "_PivotCtrl_Outer1");
	delete ($modName + "_PivotCtrl_Inner1") ($modName + "_PivotCtrl_leftLine1") ($modName + "_PivotCtrl_rightLine1");
	
	rotate -r 0 -5 0 ($modName + "_PivotCtrl_Outer1");
	
	
	duplicate -rr -n ($modName + "_PivotCtrl_Outer2") ($modName + "_PivotCtrl_Outer1");
	rotate -r 0 -90 0 ($modName + "_PivotCtrl_Outer2");
	
	duplicate -rr -n ($modName + "_PivotCtrl_Outer3") ($modName + "_PivotCtrl_Outer1");
	rotate -r 0 -180 0 ($modName + "_PivotCtrl_Outer3");
	
	duplicate -rr -n ($modName + "_PivotCtrl_Outer4") ($modName + "_PivotCtrl_Outer1");
	rotate -r 0 -270 0 ($modName + "_PivotCtrl_Outer4");
	
	duplicate ($modName + "_PivotCtrl_Outer1") ($modName + "_PivotCtrl_Outer2") ($modName + "_PivotCtrl_Outer3") ($modName + "_PivotCtrl_Outer4");
	rotate -r 0 0 90 ($modName + "_PivotCtrl_Outer5") ($modName + "_PivotCtrl_Outer6") ($modName + "_PivotCtrl_Outer7") ($modName + "_PivotCtrl_Outer8");
	
	duplicate ($modName + "_PivotCtrl_Outer1") ($modName + "_PivotCtrl_Outer2") ($modName + "_PivotCtrl_Outer3") ($modName + "_PivotCtrl_Outer4");
	rotate -r 90 0 0 ($modName + "_PivotCtrl_Outer9") ($modName + "_PivotCtrl_Outer10") ($modName + "_PivotCtrl_Outer11") ($modName + "_PivotCtrl_Outer12");
	
	curve -n ($modName + "_PivotCtrl") -d 1 -p 0.25 0 0 -p -0.25 0 0 -k 0 -k 1 ;
	rename `listRelatives -c ($modName + "_PivotCtrl")` ($modName + "_PivotCtrlShape");
	curve -n ($modName + "_PivotCtrl_Line1") -d 1 -p 0 0.25 0 -p 0 -0.25 0 -k 0 -k 1 ;
	rename `listRelatives -c ($modName + "_PivotCtrl_Line1")` ($modName + "_PivotCtrl_Line1Shape");
	curve -n ($modName + "_PivotCtrl_Line2") -d 1 -p 0 0 0.25 -p 0 0 -0.25 -k 0 -k 1 ;
	rename `listRelatives -c ($modName + "_PivotCtrl_Line2")` ($modName + "_PivotCtrl_Line2Shape");
	
	makeIdentity -apply true -r 1 ($modName + "_PivotCtrl_Outer1") ($modName + "_PivotCtrl_Outer2") ($modName + "_PivotCtrl_Outer3") ($modName + "_PivotCtrl_Outer4") ($modName + "_PivotCtrl_Outer5") ($modName + "_PivotCtrl_Outer6") ($modName + "_PivotCtrl_Outer7") ($modName + "_PivotCtrl_Outer8") ($modName + "_PivotCtrl_Outer9") ($modName + "_PivotCtrl_Outer10") ($modName + "_PivotCtrl_Outer11") ($modName + "_PivotCtrl_Outer12");
	$shapes = `listRelatives -f -c -type "nurbsCurve" ($modName + "_PivotCtrl_Outer1") ($modName + "_PivotCtrl_Outer2") ($modName + "_PivotCtrl_Outer3") ($modName + "_PivotCtrl_Outer4") ($modName + "_PivotCtrl_Outer5") ($modName + "_PivotCtrl_Outer6") ($modName + "_PivotCtrl_Outer7") ($modName + "_PivotCtrl_Outer8") ($modName + "_PivotCtrl_Outer9") ($modName + "_PivotCtrl_Outer10") ($modName + "_PivotCtrl_Outer11") ($modName + "_PivotCtrl_Outer12") ($modName + "_PivotCtrl_Line1") ($modName + "_PivotCtrl_Line2") `;
	for ($each in $shapes)
	{
		parent -r -s $each ($modName + "_PivotCtrl");
	}
	delete ($modName + "_PivotCtrl_Outer1") ($modName + "_PivotCtrl_Outer2") ($modName + "_PivotCtrl_Outer3") ($modName + "_PivotCtrl_Outer4") ($modName + "_PivotCtrl_Outer5") ($modName + "_PivotCtrl_Outer6") ($modName + "_PivotCtrl_Outer7") ($modName + "_PivotCtrl_Outer8") ($modName + "_PivotCtrl_Outer9") ($modName + "_PivotCtrl_Outer10") ($modName + "_PivotCtrl_Outer11") ($modName + "_PivotCtrl_Outer12") ($modName + "_PivotCtrl_Line1") ($modName + "_PivotCtrl_Line2");
	group -n ($modName + "_PivotCtrlGrp");
	delete `parentConstraint RRM_ROOT ($modName + "_PivotCtrlGrp")`;
	if ($twistAxis != 1)
	{
		rotate -r -os -90 0 90 ($modName + "_PivotCtrlGrp");
	}
	
	setAttr (($modName + "_PivotCtrl.scale"), $mainScale[0], $mainScale[1], $mainScale[2]);
	makeIdentity -apply true -s 1 ($modName + "_PivotCtrl");
	
	parentConstraint -mo ($modName + "_COG_Ctrl") ($modName + "_PivotCtrlGrp");
	parent ($modName + "_PivotCtrlGrp") ($modName + "_MAINCtrl");
	
	//CREATE ROOT CONTROL//////////////////////////////////////////////////////
	if ($twistAxis == 1)
	{
		circle -n ($modName + "_ROOTCtrl") -nr 0 1 0 -r 1.15  -ch 0;
		circle -n ($modName + "_ROOTCtrl1") -nr 0 1 0 -sw 315 -r 1.2  -ch 0;
		rotate -r 0 -157.5 0 ($modName + "_ROOTCtrl1");
		makeIdentity -apply true -r 1 ($modName + "_ROOTCtrl1");
		curve -n ($modName + "_ROOTCtrl2") -d 1 -p 0.459248 0 1.108679 -p 0.459248 0 1.232295 -p 0 0 1.454964 -p -0.459248 0 1.232295 -p -0.459248 0 1.108679 -k 0 -k 1 -k 2 -k 3 -k 4 ;
		rename `listRelatives -c ($modName + "_ROOTCtrl2")` ($modName + "_ROOTCtrl2Shape");
	}
	else
	{
		circle -n ($modName + "_ROOTCtrl") -nr 1 0 0 -r 4.6  -ch 0;
		circle -n ($modName + "_ROOTCtrl1") -nr 1 0 0 -sw 315 -r 4.8  -ch 0;
		rotate -r -157.5 0 0 ($modName + "_ROOTCtrl1");
		makeIdentity -apply true -r 1 ($modName + "_ROOTCtrl1");
		curve -n ($modName + "_ROOTCtrl2") -d 1 -p 0 -4.434622 -1.83688 -p 0 -4.92918 -1.836992 -p 0 -5.819856 0 -p 0 -4.92918 1.836992 -p 0 -4.434622 1.83688 -k 0 -k 1 -k 2 -k 3 -k 4 ;
		rename `listRelatives -c ($modName + "_ROOTCtrl2")` ($modName + "_ROOTCtrl2Shape");
	}
	parent -r -s ($modName + "_ROOTCtrl1Shape") ($modName + "_ROOTCtrl2Shape") ($modName + "_ROOTCtrl");
	delete ($modName + "_ROOTCtrl1") ($modName + "_ROOTCtrl2");
	
	
	//SECONDARY CONTROL
	if ($twistAxis == 1)
	{
		circle -n ($modName + "_ROOTSecondaryCtrl") -nr 0 1 0 -r 0.8 -ch 0;
		curve -n ($modName + "_ROOTSecondaryCtrl2") -d 1 -p 0.448913 0 0.659205 -p 0.457839 0 0.707653 -p 0.43562 0 0.726309 -p 0.389727 0 0.761461 -p 0.317127 0 0.807243 -p 0.242199 0 0.852344 -p 0.165051 0 0.890957 -p 0.0916126 0 0.922558 -p 0.0354615 0 0.944185 -p 0 0 0.956437 -p 0 0 0.800148 -p 0 0 0.956437 -p -0.0354615 0 0.944185 -p -0.0916126 0 0.922558 -p -0.165051 0 0.890957 -p -0.242199 0 0.852344 -p -0.317127 0 0.807243 -p -0.389727 0 0.761461 -p -0.43562 0 0.726309 -p -0.457839 0 0.707653 -p -0.448913 0 0.659205 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 ;
		rename `listRelatives -c ($modName + "_ROOTSecondaryCtrl2")` ($modName + "_ROOTSecondaryCtrl2Shape");
		curve -n ($modName + "_ROOTSecondaryCtrl3") -d 1 -p 0.793238 0 -0.0839132 -p 0.715647 0 0 -p 0.793238 0 0.0839132 -k 0 -k 1 -k 2 ;
		rename `listRelatives -c ($modName + "_ROOTSecondaryCtrl3")` ($modName + "_ROOTSecondaryCtrl3Shape");
		duplicate -rr; rotate -r 0 90 0; for ($i=1; $i<2; ++$i) duplicate -rr -st;
		makeIdentity -apply true -r 1 ($modName + "_ROOTSecondaryCtrl4") ($modName + "_ROOTSecondaryCtrl5");
		parent -r -s ($modName + "_ROOTSecondaryCtrl2Shape")  ($modName + "_ROOTSecondaryCtrl3Shape") ($modName + "_ROOTSecondaryCtrl4Shape") ($modName + "_ROOTSecondaryCtrl5Shape") ($modName + "_ROOTSecondaryCtrl");
		delete ($modName + "_ROOTSecondaryCtrl2") ($modName + "_ROOTSecondaryCtrl3") ($modName + "_ROOTSecondaryCtrl4") ($modName + "_ROOTSecondaryCtrl5");	
		
		move -r 0 0.03 0 ($modName + "_ROOTSecondaryCtrl.scalePivot") ($modName + "_ROOTSecondaryCtrl.rotatePivot");
		parent ($modName + "_ROOTSecondaryCtrl") ($modName + "_ROOTCtrl");
		delete `pointConstraint ($modName + "_ROOTCtrl") ($modName + "_ROOTSecondaryCtrl")`;
		makeIdentity -apply true ($modName + "_ROOTSecondaryCtrl");
		
		group -n ($modName + "_ROOTCtrlGrp") ($modName + "_ROOTCtrl"); xform -os -piv 0 0 0;
		parentConstraint ($modName + "_ROOTParentCtrl") ($modName + "_ROOTCtrlGrp");
		parent ($modName + "_ROOTParentCtrl") ($modName + "_ROOTCtrlGrp") RRM_ROOT;
		setAttr (($modName + "_ROOTParentCtrl.scale"), 4, 4, 4);
		setAttr (($modName + "_ROOTCtrlGrp.scale"), 4, 4, 4);
		parent -w ($modName + "_ROOTParentCtrl") ($modName + "_ROOTCtrlGrp");
		makeIdentity -apply true -s 1 ($modName + "_ROOTParentCtrl") ($modName + "_ROOTCtrlGrp");
		scaleConstraint ($modName + "_ROOTParentCtrl") ($modName + "_ROOTCtrlGrp");
	
		group -n ($modName + "_ROOTParentCtrlGrp") ($modName + "_ROOTParentCtrl"); xform -os -piv 0 0 0;
		group -n ($modName + "_ROOTParentCtrlGrp2")  ($modName + "_ROOTParentCtrlGrp"); xform -os -piv 0 0 0;
		delete `parentConstraint RRM_ROOT ($modName + "_ROOTParentCtrlGrp2")`;
		makeIdentity -apply true -t 1 ($modName + "_ROOTParentCtrlGrp2");
	}
	else
	{
		circle -n ($modName + "_ROOTSecondaryCtrl") -nr 1 0 0 -r 3.2 -ch 0;
		curve -n ($modName + "_ROOTSecondaryCtrl2") -d 1 -p 0 -2.63682 -1.795652 -p 0 -2.830612 -1.831356 -p 0 -2.905236 -1.74248 -p 0 -3.045844 -1.558908 -p 0 -3.228972 -1.268508 -p 0 -3.409376 -0.968796 -p 0 -3.563828 -0.660204 -p 0 -3.690232 -0.36645 -p 0 -3.77674 -0.141846 -p 0 -3.825748 0 -p 0 -3.200592 0 -p 0 -3.825748 0 -p 0 -3.77674 0.141846 -p 0 -3.690232 0.36645 -p 0 -3.563828 0.660204 -p 0 -3.409376 0.968796 -p 0 -3.228972 1.268508 -p 0 -3.045844 1.558908 -p 0 -2.905236 1.74248 -p 0 -2.830612 1.831356 -p 0 -2.63682 1.795652 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 ;
		rename `listRelatives -c ($modName + "_ROOTSecondaryCtrl2")` ($modName + "_ROOTSecondaryCtrl2Shape");
		curve -n ($modName + "_ROOTSecondaryCtrl3") -d 1 -p 0 0.335653 -3.172952 -p 0 0 -2.862588 -p 0 -0.335653 -3.172952 -k 0 -k 1 -k 2 ;
		rename `listRelatives -c ($modName + "_ROOTSecondaryCtrl3")` ($modName + "_ROOTSecondaryCtrl3Shape");
		duplicate -rr; rotate -r 90 0 0; for ($i=1; $i<2; ++$i) duplicate -rr -st;
		makeIdentity -apply true -r 1 ($modName + "_ROOTSecondaryCtrl4") ($modName + "_ROOTSecondaryCtrl5");
		parent -r -s ($modName + "_ROOTSecondaryCtrl2Shape")  ($modName + "_ROOTSecondaryCtrl3Shape") ($modName + "_ROOTSecondaryCtrl4Shape") ($modName + "_ROOTSecondaryCtrl5Shape") ($modName + "_ROOTSecondaryCtrl");
		delete ($modName + "_ROOTSecondaryCtrl2") ($modName + "_ROOTSecondaryCtrl3") ($modName + "_ROOTSecondaryCtrl4") ($modName + "_ROOTSecondaryCtrl5");	
		
		move -r 0 0.03 0 ($modName + "_ROOTSecondaryCtrl.scalePivot") ($modName + "_ROOTSecondaryCtrl.rotatePivot");
		parent ($modName + "_ROOTSecondaryCtrl") ($modName + "_ROOTCtrl");
		delete `pointConstraint ($modName + "_ROOTCtrl") ($modName + "_ROOTSecondaryCtrl")`;
		makeIdentity -apply true ($modName + "_ROOTSecondaryCtrl");
		
		group -n ($modName + "_ROOTCtrlGrp") ($modName + "_ROOTCtrl"); xform -os -piv 0 0 0;
		parentConstraint ($modName + "_ROOTParentCtrl") ($modName + "_ROOTCtrlGrp");
		parent ($modName + "_ROOTParentCtrl") ($modName + "_ROOTCtrlGrp") RRM_ROOT;
		parent -w ($modName + "_ROOTParentCtrl") ($modName + "_ROOTCtrlGrp");
		makeIdentity -apply true -s 1 ($modName + "_ROOTParentCtrl") ($modName + "_ROOTCtrlGrp");
		scaleConstraint ($modName + "_ROOTParentCtrl") ($modName + "_ROOTCtrlGrp");
	
		group -n ($modName + "_ROOTParentCtrlGrp") ($modName + "_ROOTParentCtrl"); xform -os -piv 0 0 0;
		group -n ($modName + "_ROOTParentCtrlGrp2")  ($modName + "_ROOTParentCtrlGrp"); xform -os -piv 0 0 0;
		delete `parentConstraint RRM_ROOT ($modName + "_ROOTParentCtrlGrp2")`;
		rotate -r -90 0 90;
		makeIdentity -apply true -t 1 ($modName + "_ROOTParentCtrlGrp2");
	}
	parentConstraint -mo ($modName + "_PivotCtrl") ($modName + "_ROOTParentCtrlGrp2");
	
	//CREATE OFFSETTING VALUES ON PARENT CTRL GRP
	shadingNode -asUtility multiplyDivide -n ($modName + "_ROOTParentCtrlGrp_MD");
	connectAttr -f ($modName + "_PivotCtrl.translate") ($modName + "_ROOTParentCtrlGrp_MD.input1");
	setAttr (($modName + "_ROOTParentCtrlGrp_MD.input2"), -1, -1, -1);
	connectAttr -f ($modName + "_ROOTParentCtrlGrp_MD.output") ($modName + "_ROOTParentCtrlGrp.translate");
	
	
	parentConstraint ($modName + "_ROOTSecondaryCtrl") ($modName + "_ROOTJnt");
	connectAttr -f ($modName + "_ROOTSecondaryCtrl.scale") ($modName + "_ROOTJnt.scale");
	
	
	//ADD VISIBILITY CONTROL FOR PARENT CONTROL
	addAttr -ln "parentControl"  -at bool ($modName + "_ROOTCtrl");
	setAttr -e-keyable 1 ($modName + "_ROOTCtrl.parentControl");
	connectAttr -f ($modName + "_ROOTCtrl.parentControl") ($modName + "_ROOTParentCtrl.v");
	setAttr -lock 1 -keyable 0 ($modName + "_ROOTParentCtrl.v");
	setAttr ($modName + "_ROOTCtrl.parentControl") 0;
	
	//ADD VISIBILITY CONTROL FOR PIVOT CONTROL
	addAttr -ln "pivotCtrlVisibility"  -at bool ($modName + "_MAINCtrl");
	setAttr -e-keyable 1 ($modName + "_MAINCtrl.pivotCtrlVisibility");
	connectAttr -f ($modName + "_MAINCtrl.pivotCtrlVisibility") ($modName + "_PivotCtrl.v");
	setAttr -lock 1 -keyable 0 ($modName + "_PivotCtrl.v");
	setAttr ($modName + "_MAINCtrl.pivotCtrlVisibility") 0;
	
	setAttr -lock 1 -keyable 0 ($modName + "_PivotCtrl.sx");
	setAttr -lock 1 -keyable 0 ($modName + "_PivotCtrl.sy");
	setAttr -lock 1 -keyable 0 ($modName + "_PivotCtrl.sz");


	group -n ($modName + "_ROOTGrp") ($modName + "_ROOTParentCtrlGrp2");
	parent ($modName + "_ROOTCtrlGrp") ($modName + "_ROOTParentCtrlGrp2");
	parent ($modName + "_ROOTGrp") ($modName + "_MAINCtrl");
	parent ($modName + "_ROOTJnt") ($modName + "_ROOTCtrlGrp");

	parent ($modName + "_MAINCtrl") $modName;

	//ADD CORE NAME
	$modControls = `ls ($modName + "_ROOTSecondaryCtrl") ($modName + "_ROOTCtrl") ($modName + "_ROOTParentCtrl")`;
	RRM_CoreName_V1($modControls);
	for ($crntModControl in $modControls)
	{
		addAttr -ln "isROOT"  -dt "string" $crntModControl;
		setAttr -e-keyable 1 ($crntModControl + ".isROOT");
		setAttr -type "string" ($crntModControl + ".isROOT") $crntModControl;
		setAttr -e-lock 1 ($crntModControl + ".isROOT");
		
		setAttr -type "string" ($crntModControl + ".modCoreName") ("_ROOTCtrl");
		setAttr -e-lock 1 ($crntModControl + ".modCoreName");
	}

	addAttr -ln "isMain"  -dt "string" ($modName + "_MAINCtrl");
	setAttr -e-keyable 1 ($modName + "_MAINCtrl.isMain");
	setAttr -type "string" ($modName + "_MAINCtrl.isMain") "isMain";
	setAttr -e-lock 1 ($modName + "_MAINCtrl.isMain");

	//ADD VERSION NUMBER
	addAttr -ln "versionNumber"  -dt "string" ($modName + "_MAINCtrl");
	setAttr -e-keyable 1 ($modName + "_MAINCtrl.versionNumber");
	setAttr -type "string" ($modName + "_MAINCtrl.versionNumber") "1.8.3";
	setAttr -e-lock 1 ($modName + "_MAINCtrl.versionNumber");

	addAttr -ln "isROOTCtrl"  -dt "string" ($modName + "_ROOTCtrl");
	setAttr -e-keyable 1 ($modName + "_ROOTCtrl.isROOTCtrl");
	setAttr -e-lock 1 ($modName + "_ROOTCtrl.isROOTCtrl");

	addAttr -ln "isROOTGrp"  -dt "string" ($modName + "_ROOTGrp");
	setAttr -e-keyable 1 ($modName + "_ROOTGrp.isROOTGrp");
	setAttr -e-lock 1 ($modName + "_ROOTGrp.isROOTGrp");
	
	//CREATE LOCATOR FOR TURNING OFF CONSTRAINTS
	spaceLocator -n ($modName + "_ROOTLocLctr");
	delete `pointConstraint ($modName + "_ROOTJnt") ($modName + "_ROOTLocLctr")`;
	parentConstraint -mo ($modName + "_MAINCtrl") ($modName + "_ROOTLocLctr");
	parent ($modName + "_ROOTLocLctr") ($modName + "_ROOTGrp");
	setAttr ($modName + "_ROOTLocLctr.v") 0;
	
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}
	

////////////////////////////////////////////////////////////////////////////////
//////////////////////////GENERATE SPLINE MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_SplineFKControl_V1(int $twistAxis)
{
	if ($twistAxis == 1)
	{
		circle -n "splineFKCtrl" -nr 0 1 0 -r 1 -ch 0;	
		scale -r  -0.333 1 1 splineFKCtrl.cv[3] splineFKCtrl.cv[7];
		move -r 0 0 -0.35 splineFKCtrl.cv[0] splineFKCtrl.cv[2];
	}
	else
	{
		circle -n "splineFKCtrl" -nr 1 0 0 -r 1 -ch 0;	
		scale -r  1 1 -0.3 splineFKCtrl.cv[3] splineFKCtrl.cv[7];
		move -r 0 0.35 0 splineFKCtrl.cv[0] splineFKCtrl.cv[2];
	}
}

global proc RRM_GenerateRig_V1Spline_V1(string $modName, string $moduleName, string $topNode)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;  

	//INTEGER FOR LOOP
	$mirrorInt = 2;
	$multiplier = 1;
		
	$core = `getAttr ($topNode + ".core")`;
	$twistAxis = 1;
	if (`objExists ($topNode + ".twistAxis")`)
	{
		$twistAxis = `getAttr ($topNode + ".twistAxis")`;
	}
	string $prfx = "";
	string $oppPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = "l_";
		$oppPrfx = "r_";
		$mirrorInt = 1;
	}
	$crntSide = "left";
	$oppSide = "right";
	
	while ($mirrorInt <= 2)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modName + "_" + $prfx + $core);
		
		$modOppCore = ($modName + "_" + $oppPrfx + $core);
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		delete `orientConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_OffsetLctr");
		
		group -em -n ($modCore);
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modName + "_ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_ROOTJnt") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modName + "_MAINCtrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "spline";
		setAttr -l true ($modCore + "Grp.topNode");		
		
		//CORE NAME
		addAttr -ln "coreName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ("_" + $prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable 1 ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ("_" + $oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable 1 ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");
		}
		
		//NODE-SPECIFIC ATTRIBUTES
		$splineProxies = `ls ("RRM_" + $prfx + $core + "_??")`;
		$splineSize = (`size $splineProxies` + 1);
		
		addAttr -ln "splineJoints"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.splineJoints") ;
		setAttr -type "string" ($modCore + "Grp.splineJoints") $splineSize;
		setAttr -l true ($modCore + "Grp.splineJoints");	
	
		
		//SCALE GROUP
		group -em -n ($modCore + "_ScaleGrp");
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			delete `orientConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore + "_ScaleGrp")`;
			//rotate -r -90 0 90 ($modCore + "_ScaleGrp");
			makeIdentity -apply true -t 1 -s 1 ($modCore + "_ScaleGrp");
			
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint -mo ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp")`;
			delete `orientConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore + "_ScaleGrp")`;
			//rotate -r -90 0 90 ($modCore + "_ScaleGrp");
			makeIdentity -apply true -t 1 -s 1 ($modCore + "_ScaleGrp");
			
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp");
			orientConstraint -mo ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + "_ScaleGrp.scale");
		
		//ORIENTATION AND LENGTH LOCATORS
		spaceLocator -n ($modCore + "_OrientLctr");
		parent ($modCore + "_OrientLctr") ($modCore + "Grp");	
		spaceLocator -n  ($modCore + "_OrientLengthLctr");
		parent ($modCore + "_OrientLengthLctr") ($modCore + "_OrientLctr");
		pointConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore + "_OrientLctr");
		if ($twistAxis == 1)
		{
			aimConstraint -offset 0 0 0 -aimVector 0 1 0 -upVector 0 0 1
			-worldUpType "objectrotation"  -worldUpVector 0 0 1 -worldUpObject ("RRM_" + $prfx + $core + "_Parent")
			("RRM_" + $prfx + $core + "_Top") ($modCore + "_OrientLctr");			
		}
		else
		{
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 0 1
			-worldUpType "objectrotation"  -worldUpVector 0 0 1 -worldUpObject ("RRM_" + $prfx + $core + "_Parent")
			("RRM_" + $prfx + $core + "_Top") ($modCore + "_OrientLctr");
		}
		pointConstraint ("RRM_" + $prfx + $core + "_Top") ($modCore + "_OrientLengthLctr");
		$getSplineLength = `getAttr ($modCore + "_OrientLengthLctr.ty")`;
		if ($twistAxis == 0)
		{
			$getSplineLength = `getAttr ($modCore + "_OrientLengthLctr.tx")`;
		}
	
		//FK CONTROLS
		$splineProxies = `ls ("RRM_" + $prfx + $core + "_??")`;
		$splineSize = `size $splineProxies`;
		int $crntNum = 1;
		while ($crntNum <= $splineSize)
		{
			$nPd = "_0";
			if ($crntNum >= 10)
			{$nPd = "_";}
			$prvNPad = "_0";
			if ($crntNum > 10)
			{$prvNPad = "_";}		
			int $testNum = $crntNum;
		
			RRM_SplineFKControl_V1($twistAxis);
			rename "splineFKCtrl" ($modCore + $nPd + $crntNum + "FKCtrl");
			group -n ($modCore + $nPd + $crntNum + "FKCtrlGrp") ($modCore + $nPd + $crntNum + "FKCtrl"); xform -os -piv 0 0 0;
			delete `parentConstraint ("RRM_" + $prfx + $core + $nPd + $crntNum) ($modCore + $nPd + $crntNum + "FKCtrlGrp")`;
			if ($twistAxis == 0)
			{
				rotate -r -os -90 0 90 ($modCore + $nPd + $crntNum + "FKCtrlGrp");
			}
			//select "break";
			$parentNodeLoc = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Parent")`;
			$topNodeLoc = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Top")`; 
			$scale = ((($getSplineLength + $getSplineLength / $splineSize))/3);
			scale -r $scale $scale $scale ($modCore + $nPd + $crntNum + "FKCtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + $nPd + $crntNum + "FKCtrlGrp");
			
			parent ($modCore + $nPd + $crntNum + "FKCtrlGrp") ($modCore + "_ScaleGrp");
			if ($crntNum == 1)
			{
				spaceLocator -n ($modCore + $nPd + $crntNum + "FKCFlipLctr");
				setAttr ($modCore + $nPd + $crntNum + "FKCFlipLctr.v") 0;
				parent ($modCore + $nPd + $crntNum + "FKCFlipLctr") ($modCore + "_ScaleGrp");
	
				delete `orientConstraint ($modCore + "_OffsetLctr") ($modCore + $nPd + $crntNum + "FKCFlipLctr")`;
				delete `pointConstraint  ($modCore) ($modCore + $nPd + $crntNum + "FKCFlipLctr")`;
				parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore) ($modCore + $nPd + $testNum + "FKCtrlGrp");
				orientConstraint -mo ($modCore + $nPd + $crntNum + "FKCFlipLctr") ($modCore + "_OffsetLctr") ($modCore + $nPd + $testNum + "FKCtrlGrp");
				parentConstraint -mo ($modCore) ($modCore + $nPd + $crntNum + "FKCFlipLctr");
				
				//PARENT ORIENT
				addAttr -ln "orient"  -at double  -min 0 -max 1 -dv 1 ($modCore + $nPd + $testNum + "FKCtrl");
				setAttr -e-keyable 1 ($modCore + $nPd + $testNum + "FKCtrl.orient");
				connectAttr -force ($modCore + $nPd + $testNum + "FKCtrl.orient") ($modCore + $nPd + $testNum + "FKCtrlGrp_orientConstraint1." + $modCore + $nPd + $crntNum + "FKCFlipLctrW0");
				
				shadingNode -asUtility reverse -n ($modCore + $nPd + $testNum + "FKParentOrientReverse");
				connectAttr -force ($modCore + $nPd + $testNum + "FKCtrl.orient") ($modCore + $nPd + $testNum + "FKParentOrientReverse.inputX");
				connectAttr -force ($modCore + $nPd + $testNum + "FKParentOrientReverse.outputX") ($modCore + $nPd + $testNum + "FKCtrlGrp_orientConstraint1." + $modCore + "_OffsetLctrW1");
			}
			else
			{
				spaceLocator -n ($modCore + $nPd + $crntNum + "FKCFlipLctr");
				setAttr ($modCore + $nPd + $crntNum + "FKCFlipLctr.v") 0;
				parent ($modCore + $nPd + $crntNum + "FKCFlipLctr") ($modCore + "_ScaleGrp");
				
				delete `orientConstraint ($modCore + "_OffsetLctr") ($modCore + $nPd + $crntNum + "FKCFlipLctr")`;
				delete `pointConstraint  ($modCore + $prvNPad + ($crntNum - 1) + "FKCtrl") ($modCore + $nPd + $crntNum + "FKCFlipLctr")`;
				parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore + $prvNPad + ($crntNum - 1) + "FKCtrl") ($modCore + $nPd + $testNum + "FKCtrlGrp");
				orientConstraint -mo ($modCore + $nPd + $crntNum + "FKCFlipLctr") ($modCore + "_OffsetLctr") ($modCore + $nPd + $testNum + "FKCtrlGrp");
				parentConstraint -mo ($modCore + $prvNPad + ($crntNum - 1) + "FKCtrl") ($modCore + $nPd + $crntNum + "FKCFlipLctr");
				
				//PARENT ORIENT
				addAttr -ln "orient"  -at double  -min 0 -max 1 -dv 1 ($modCore + $nPd + $testNum + "FKCtrl");
				setAttr -e-keyable 1 ($modCore + $nPd + $testNum + "FKCtrl.orient");
				connectAttr -force ($modCore + $nPd + $testNum + "FKCtrl.orient") ($modCore + $nPd + $testNum + "FKCtrlGrp_orientConstraint1." + $modCore + $nPd + $crntNum + "FKCFlipLctrW0");
				
				shadingNode -asUtility reverse -n ($modCore + $nPd + $testNum + "FKParentOrientReverse");
				connectAttr -force ($modCore + $nPd + $testNum + "FKCtrl.orient") ($modCore + $nPd + $testNum + "FKParentOrientReverse.inputX");
				connectAttr -force ($modCore + $nPd + $testNum + "FKParentOrientReverse.outputX") ($modCore + $nPd + $testNum + "FKCtrlGrp_orientConstraint1." + $modCore + "_OffsetLctrW1");	
			}
			$crntNum++;
		}
		
		//IK SPLINE CONTROLS
		if ($twistAxis == 1)
		{
			curve -n ($modCore + "_TopIKCtrl") -d 1 -p 0 -5 0 -p -2 -3 0 -p -1 -3 0 -p -1 -1 0 -p -3 -1 0 -p -3 -2 0
			-p -5 0 0 -p -3 2 0 -p -3 1 0 -p -1 1 0 -p -1 3 0 -p -2 3 0 -p 0 5 0 -p 2 3 0
			-p 1 3 0 -p 1 1 0 -p 3 1 0 -p 3 2 0 -p 5 0 0 -p 3 -2 0 -p 3 -1 0 -p 1 -1 0	
			-p 1 -3 0 -p 2 -3 0 -p 0 -5 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9
			-k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22
			-k 23 -k 24 ;
			rotate 90 0 0 ($modCore + "_TopIKCtrl");			
		}
		else
		{
			curve -n ($modCore + "_TopIKCtrl") -d 1 -p 0 1 1 -p 0 3 1 -p 0 3 2-p 0 5 0
			-p 0 3 -2 -p 0 3 -1 -p 0 1 -1 -p 0 1 -3 -p 0 2 -3 -p 0 0 -5 -p 0 -2 -3
			-p 0 -1 -3 -p 0 -1 -1 -p 0 -3 -1 -p 0 -3 -2 -p 0 -5 0 -p 0 -3 2 -p 0 -3 1
			-p 0 -1 1 -p 0 -1 3 -p 0 -2 3 -p 0 0 5 -p 0 2 3 -p 0 1 3 -p 0 1 1 -k 0
			-k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13
			-k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 ;
		}

		rename `listRelatives -c ($modCore + "_TopIKCtrl")` ($modCore + "_TopIKCtrlShape");
		$splineScaleRatio = ($getSplineLength + $getSplineLength / $splineSize);
		setAttr (($modCore + "_TopIKCtrl.scale"), ($splineScaleRatio/14), ($splineScaleRatio/14), ($splineScaleRatio/14));
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_TopIKCtrl");
		group -n ($modCore + "_TopIKCtrlGrp") ($modCore + "_TopIKCtrl"); xform -os -piv 0 0 0;
		
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Top") ($modCore + "_TopIKCtrlGrp")`;
		if ($twistAxis == 1)
		{
			curve -n ($modCore + "_MidIKCtrl") -d 1 -p 0 0 2.5 -p -1.5 0 1 -p -3 0 1
			-p -3 0 -1 -p 3 0 -1 -p 3 0 1 -p 1.5 0 1 -p 0 0 2.5
			-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 ;
		}
		else
		{
			rotate -r -os -90 0 90 ($modCore + "_TopIKCtrlGrp");
			//select "break";
			curve -n ($modCore + "_MidIKCtrl") -d 1 -p 0 -2.5 0 -p 0 -1 1.5 -p 0 -1 3
			-p 0 1 3 -p 0 1 -3 -p 0 -1 -3 -p 0 -1 -1.5 -p 0 -2.5 0
			-k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 ;
		}

		rename `listRelatives -c ($modCore + "_MidIKCtrl")` ($modCore + "_MidIKCtrlShape");
		setAttr (($modCore + "_MidIKCtrl.scale"), ($splineScaleRatio/8), ($splineScaleRatio/8), ($splineScaleRatio/8));
		
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_MidIKCtrl");
		group -n ($modCore + "_MidIKCtrlGrp") ($modCore + "_MidIKCtrl"); xform -os -piv 0 0 0;
		spaceLocator -n ($modCore + "_MidIKCtrlLctr");
		spaceLocator -n ($modCore + "_MidIKCtrlWSLctr");
		group -n ($modCore + "_MidIKCtrlLctrGrp") ($modCore + "_MidIKCtrlLctr"); xform -os -piv 0 0 0;
		group -n ($modCore + "_MidIKCtrlLctrGrp2") ($modCore + "_MidIKCtrlLctrGrp");
		//select "break";
		if ($twistAxis == 0)
		{
			rotate -r -90 0 90 ($modCore + "_MidIKCtrlLctrGrp2");
		}
		//select "break";
		parent ($modCore + "_TopIKCtrlGrp") ($modCore + "_MidIKCtrlGrp") ($modCore + "_MidIKCtrlLctrGrp2") ($modCore + "_MidIKCtrlWSLctr") ($modCore);
		
		//HIDE LOCATORS
		setAttr ($modCore + "_MidIKCtrlLctr.v") 0;
		setAttr ($modCore + "_MidIKCtrlWSLctr.v") 0;
		
		
		//LOCATOR TO PREVENT FLIPPING OF IK CONTROL
		spaceLocator -n ($modCore + "_TopIKCtrl_FlipLctr1");
		delete `orientConstraint ($modCore + "_TopIKCtrl") ($modCore + "_TopIKCtrl_FlipLctr1")`;
		parentConstraint -mo ($modCore + "_OffsetLctr") ($modCore + "_TopIKCtrl_FlipLctr1");
		
		spaceLocator -n ($modCore + "_TopIKCtrl_FlipLctr2");
		delete `orientConstraint ($modCore + "_TopIKCtrl") ($modCore + "_TopIKCtrl_FlipLctr2")`;
		setAttr ($modCore + "_TopIKCtrl_FlipLctr1.v") 0;
		setAttr ($modCore + "_TopIKCtrl_FlipLctr2.v") 0;
		parent ($modCore + "_TopIKCtrl_FlipLctr1") ($modCore + "_TopIKCtrl_FlipLctr2") ($modCore + "_ScaleGrp");
		//CONSTRAIN TO FK CONTROLS
		//NUMBER OF SPLINE JOINTS
		$spineDums = `ls ("RRM" + "_" + $oppPrfx + $core + "_??") ("RRM" + "_" + $oppPrfx + $core + "_Top")`;
		$spineNum = `size $spineDums`;
		
		//GET SECOND FROM TOP
		int $splineNumTop = ($spineNum - 1);
		$nPd = "_0";
		if ($splineNumTop >=10)
			{$nPd = "_";}
			
		//GET HALF WAY POINT FOR MID IKCtrlGrp TO ATTACH TO. IF UNEVEN NUMBER, NEED TWO TARGETS
		int $midSpline = ($spineNum/2);
		int $midSpline2 = ($midSpline + 1);
		$nPdMid = "_0";
		$nPdMid2 = "_0";
		if ($midSpline >=10)
		{$nPdMid = "_";}
		if ($midSpline2 >=10)
		{$nPdMid2 = "_";}
		
		//CONSTRAIN MID IKC ASSETS TO THE CENTER
		if ($spineNum % 2 == 0)
		{
			parentConstraint ($modCore + $nPdMid + $midSpline + "FKCtrl") ($modCore + "_MidIKCtrlLctrGrp");
			delete `parentConstraint ($modCore + $nPdMid + $midSpline + "FKCtrl") ($modCore + "_MidIKCtrlWSLctr")`;
		}
		else
		{
			parentConstraint ($modCore + $nPdMid + $midSpline + "FKCtrl") ($modCore + $nPdMid2 + $midSpline2 + "FKCtrl") ($modCore + "_MidIKCtrlLctrGrp");
			setAttr ($modCore + "_MidIKCtrlLctrGrp_parentConstraint1.interpType") 2;
			delete `parentConstraint ($modCore + $nPdMid + $midSpline + "FKCtrl") ($modCore + $nPdMid2 + $midSpline2 + "FKCtrl") ($modCore + "_MidIKCtrlWSLctr")`;
		}
		
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_MidIKCtrlWSLctr");
		parentConstraint -skipRotate x -skipRotate y -skipRotate z ($modCore + "_MidIKCtrlLctr") ($modCore + "_MidIKCtrlWSLctr")($modCore + "_MidIKCtrlGrp");
		orientConstraint ($modCore + "_MidIKCtrlLctr") ($modCore + "_MidIKCtrlWSLctr")($modCore + "_MidIKCtrlGrp");
		setAttr ($modCore + "_MidIKCtrlGrp_orientConstraint1.interpType") 2;

		
		//PARENT ORIENT/TRANSLATE MID IKCG
		addAttr -ln "midTranslate" -at double -min 0 -max 1 -dv 1 ($modCore + "_MidIKCtrl");
		setAttr -e-keyable 1 ($modCore + "_MidIKCtrl.midTranslate");
		connectAttr -force ($modCore + "_MidIKCtrl.midTranslate") ($modCore + "_MidIKCtrlGrp_parentConstraint1." + $modCore + "_MidIKCtrlLctrW0");

		shadingNode -asUtility reverse -n ($modCore + "_MidIKCParentTranslateReverse");
		connectAttr -force ($modCore + "_MidIKCtrl.midTranslate") ($modCore + "_MidIKCParentTranslateReverse.inputX");
		connectAttr -force ($modCore + "_MidIKCParentTranslateReverse.outputX") ($modCore + "_MidIKCtrlGrp_parentConstraint1." + $modCore + "_MidIKCtrlWSLctrW1");


		addAttr -ln "midOrient"  -at double  -min 0 -max 1 -dv 1 ($modCore + "_MidIKCtrl");
		setAttr -e-keyable 1 ($modCore + "_MidIKCtrl.midOrient");
		connectAttr -force ($modCore + "_MidIKCtrl.midOrient") ($modCore + "_MidIKCtrlGrp_orientConstraint1." + $modCore + "_MidIKCtrlLctrW0");
		
		shadingNode -asUtility reverse -n ($modCore + "_MidIKCParentOrientReverse");
		connectAttr -force ($modCore + "_MidIKCtrl.midOrient") ($modCore + "_MidIKCParentOrientReverse.inputX");
		connectAttr -force ($modCore + "_MidIKCParentOrientReverse.outputX") ($modCore + "_MidIKCtrlGrp_orientConstraint1." + $modCore + "_MidIKCtrlWSLctrW1");

		
		//TOP IKC
		parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_MAINCtrl") ($modCore + $nPd + $splineNumTop + "FKCtrl") ($modCore + "_TopIKCtrlGrp");
		parentConstraint -mo ($modCore + $nPd + $splineNumTop + "FKCtrl") ($modCore + "_TopIKCtrl_FlipLctr2");
		orientConstraint -mo ($modCore + "_TopIKCtrl_FlipLctr1") ($modCore + "_TopIKCtrl_FlipLctr2") ($modCore + "_TopIKCtrlGrp");
			
		//PARENT ORIENT/TRANSLATE TOP IKCG
		addAttr -ln "topTranslate" -at double -min 0 -max 1 -dv 1 ($modCore + "_TopIKCtrl");
		setAttr -e-keyable 1 ($modCore + "_TopIKCtrl.topTranslate");
		connectAttr -force ($modCore + "_TopIKCtrl.topTranslate") ($modCore + "_TopIKCtrlGrp_parentConstraint1." + $modCore + $nPd + $splineNumTop + "FKCtrlW1");

		shadingNode -asUtility reverse -n ($modCore + "_TopIKCParentTranslateReverse");
		connectAttr -force ($modCore + "_TopIKCtrl.topTranslate") ($modCore + "_TopIKCParentTranslateReverse.inputX");
		connectAttr -force ($modCore + "_TopIKCParentTranslateReverse.outputX") ($modCore + "_TopIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");


		addAttr -ln "topOrient"  -at double  -min 0 -max 1 -dv 1 ($modCore + "_TopIKCtrl");
		setAttr -e-keyable 1 ($modCore + "_TopIKCtrl.topOrient");
		connectAttr -force ($modCore + "_TopIKCtrl.topOrient") ($modCore + "_TopIKCtrlGrp_orientConstraint1." + $modCore + "_TopIKCtrl_FlipLctr2W1");
		
		shadingNode -asUtility reverse -n ($modCore + "_TopIKCParentOrientReverse");
		connectAttr -force ($modCore + "_TopIKCtrl.topOrient") ($modCore + "_TopIKCParentOrientReverse.inputX");
		connectAttr -force ($modCore + "_TopIKCParentOrientReverse.outputX") ($modCore + "_TopIKCtrlGrp_orientConstraint1." + $modCore + "_TopIKCtrl_FlipLctr1W0");

		//////////////////////////////////////////////////////////////////////////////////////////////
		//////////////////////////////////////////RIBBON SPLINE////////////////////////////////////////
		//////////////////////////////////////////////////////////////////////////////////////////////
		
		//GET SPLINE LENGTH
		spaceLocator -n ($modCore + "_StartLctr");
		parent ($modCore + "_StartLctr") ($modCore + "Grp");
		spaceLocator -n  ($modCore + "_EndLctr");
		parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
		pointConstraint ($modCore) ($modCore + "_StartLctr");
		if ($twistAxis == 1)
		{
			aimConstraint -offset 0 0 0 -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_TopIKCtrl") ($modCore + "_StartLctr");			
		}
		else
		{
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_TopIKCtrl") ($modCore + "_StartLctr");
		}
		pointConstraint ($modCore + "_TopIKCtrl") ($modCore + "_EndLctr");
		
		//SPLINE START POSITION
		nurbsPlane -n ($modCore + "_ribbon") -p 0 0 0 -ax 0 0 1 -w 1 -lr 3 -u 1 -v ($splineSize) -ch 1;
		rebuildSurface -ch 1 -rpo 1 -rt 0 -end 1 -kr 2 -kcp 0 -kc 0 -su 1 -du 1 -sv 2 -dv 3 -fr 0  -dir 0 ($modCore + "_ribbon");
		delete -ch ($modCore + "_ribbon");
		parent ($modCore + "_ribbon") ($modCore + "Grp");
		
		//RIBBON BLENDSHAPE
		duplicate -rr -n ($modCore + "_ribbonBlend") ($modCore + "_ribbon");
		select ($modCore + "_ribbonBlend.cv[1][*]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_ribbonBlend_lCluster");
		move  0 0 0 ($modCore + "_ribbonBlend_lCluster.scalePivot") ($modCore + "_ribbonBlend_lCluster.rotatePivot") ;
		select ($modCore + "_ribbonBlend.cv[0][*]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_ribbonBlend_rCluster");
		move 0 0 0 ($modCore + "_ribbonBlend_rCluster.scalePivot") ($modCore + "_ribbonBlend_rCluster.rotatePivot") ;
		
		select ($modCore + "_ribbonBlend") ($modCore + "_ribbon") ;
		blendShape -n ($modCore + "_ribbonBlendShape") -tc 0;
		setAttr ($modCore + "_ribbonBlendShape1." + $modName + "_" + $prfx + $core + "_ribbonBlend") 1;
		
		group -n ($modCore + "_ribbonBlend_lClusterGrp") ($modCore + "_ribbonBlend_lCluster");xform -os -piv 0 0 0;
		group -n ($modCore + "_ribbonBlend_rClusterGrp") ($modCore + "_ribbonBlend_rCluster");xform -os -piv 0 0 0;
		parent ($modCore + "_ribbonBlend_lClusterGrp") ($modCore + "_ribbonBlend_rClusterGrp") ($modCore + "Grp");
		
		//CHECK FOR NUCLEUS
		int $nucleusCheck;
		if (`objExists "nucleus1"`)
		{
			$nucleusCheck = 1;
		}

		//ORIENT RIBBON
		//HAIR
		select ($modCore + "_ribbon");
		createHair 1 ($splineSize) 10 0 0 0 0 5 0 2 1 1;

		
		//DELETE NUCLEUS IF IT WAS JUST CREATED
		$hairSystemShape = `ls -sl`;
		$nucleus = `listConnections -type "nucleus"`;
		if ($nucleusCheck == 0 && `size $nucleus` > 0)
		{
			delete $nucleus;
		}
		
		string $hairSystem[] = `listRelatives -parent $hairSystemShape`;
		
		delete $hairSystem[0] ($hairSystem[0] + "OutputCurves");
		select ($hairSystem[0] + "Follicles");
		rename ($hairSystem[0] + "Follicles") ($modCore + "_hairSystemFollicles");
		parent ($modCore + "_hairSystemFollicles") ($modCore + "Grp");
	
		select -hi ($modCore + "_hairSystemFollicles");
		select -d  ($modCore + "_hairSystemFollicles");
		$follicles = `ls -sl`;
		float $folliclesNum = `size $follicles`;
		$folliclesNum = $folliclesNum/3;		
		int $hierarchySize = 2;
		select ($modCore + "_hairSystemFollicles");
		pickWalk -d down;
		rename ($modCore + "_01F");
		while ($hierarchySize <= $folliclesNum)
		{
			pickWalk -d right;
			$previous = `ls -sl`;
			if ($hierarchySize < 10)
			{
				rename ($modCore + "_0" + $hierarchySize + "F");
			}
			else
			{
				rename ($modCore + "_" + $hierarchySize + "F");
			}
			$hierarchySize++;
		}
		
		select ($modCore + "_??F");
		pickWalk -d down;
		pickWalk -d right;
		delete;
		
		select -cl;
		
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//LOCATORS FOR POSITIONS
	
		//JOINT LOCATIONS
		$ParentPos = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Parent")`;
		$spineTopPos = `xform -q -ws -rp ($modCore + "_TopIKCtrl")`;
		
		$splineProxies = `ls -type "transform" ("RRM_" + $prfx + $core + "_??")`;
		$splineSize = `size $splineProxies`;
		
		$vertebrae = ($splineSize + 1);
	
		//PATHS
		curve -n ($modCore + "_SplineBtm") -d 1 -p $ParentPos[0] $ParentPos[1] $ParentPos[2] -p $spineTopPos[0] $spineTopPos[1] $spineTopPos[2];
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s ($vertebrae - 2) ($modCore + "_SplineBtm");
	
		int $i = 1;
		for ($each in $splineProxies)
		{
			$splinePos = `xform -q -ws -rp $each`;
			move -ws $splinePos[0] $splinePos[1] $splinePos[2] ($modCore + "_SplineBtm.cv[" + $i + "]");
			$i++;
		}
		rename `listRelatives -c ($modCore + "_SplineBtm")` ($modCore + "_SplineBtmShape");
		
		float $vertebraeFloat = $vertebrae;
		
		//CUT CURVE IN HALF
		detachCurve -ch 0 -cos on -rpo 1 -n ($modCore + "_SplineTop") ($modCore + "_SplineBtm.u[0.5]");
		rename ($modCore + "_SplineTop1") ($modCore + "_SplineTop");
		
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 1 -kcp 0 -kep 0 -kt 0 -s 1 ($modCore + "_SplineBtm");
		rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 1 -kcp 0 -kep 0 -kt 0 -s 1 ($modCore + "_SplineTop");
		
		parent ($modCore + "_SplineTop") ($modCore + "_SplineBtm") ($modCore + "Grp");

		addAttr -ln "nonControl"  -dt "string" ($modCore + "_SplineTop");
		setAttr -e-keyable 1 ($modCore + "_SplineTop.nonControl");
		setAttr -lock 1 ($modCore + "_SplineTop.nonControl");

		addAttr -ln "nonControl"  -dt "string" ($modCore + "_SplineBtm");
		setAttr -e-keyable 1 ($modCore + "_SplineBtm.nonControl");
		setAttr -lock 1 ($modCore + "_SplineBtm.nonControl");
		
		//LOCK AND HIDE CHANNELS
		setAttr ($modCore + "_SplineTop.v") 0;
		setAttr ($modCore + "_SplineBtm.v") 0;
		
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.tx");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.ty");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.tz");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.rx");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.ry");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.rz");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.sx");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.sy");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.sz");
		setAttr -l 1 -k 0 ($modCore + "_SplineBtm.v");

		setAttr -l 1 -k 0 ($modCore + "_SplineTop.tx");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.ty");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.tz");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.rx");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.ry");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.rz");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.sx");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.sy");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.sz");
		setAttr -l 1 -k 0 ($modCore + "_SplineTop.v");

		
		//ATTACH LOCATORS TO PATHS
		int $i = 1;
		float $uValueComp = 1;
		string $crntUnit = `currentUnit -query -linear`;
		if ($crntUnit == "m")
		{
			$uValueComp = 0.01;
		}
		else if ($crntUnit == "mm")
		{
			$uValueComp = 10.0;
		}
		else if ($crntUnit == "in")
		{
			$uValueComp = 0.393701;
		}
		else if ($crntUnit == "ft")
		{
			$uValueComp = 0.0328084;
		}
		else if ($crntUnit == "yd")
		{
			$uValueComp = 0.0109361;
		}

		string $nPd = "_0"; 
		for ($each in $splineProxies)
		{
			if ($i >= 10)
			{
				$nPd = "_";
			}
			spaceLocator -n ($modCore + $nPd + $i + "CurveLctr");
			group -n ($modCore + $nPd + $i + "CurveLctrGrp");
			if ($i <= (($splineSize + 1)/2))
			{
				pathAnimation -n ($modCore + $nPd + $i + "Lctr_MP") -fractionMode true -follow true -followAxis x -upAxis z
				-worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + $nPd + $i + "F") -inverseUp false -inverseFront false -bank false
				($modCore + $nPd + $i + "CurveLctrGrp") ($modCore + "_SplineBtm");
				cutKey -cl -t ":" -f ":" -at "u" ($modCore + $nPd + $i + "Lctr_MP");
				float $uValue = ((float)$i/(((float)$splineSize + 1.0)/2.0));
				if ($uValue > 0.99999)
				{
					$uValue = (0.99999 * $uValueComp);
				}
				else
				{
					$uValue = ($uValue * $uValueComp);
				}
				setAttr ($modCore + $nPd + $i + "Lctr_MP.uValue") $uValue;
			}
			else
			{
				pathAnimation -n ($modCore + $nPd + $i + "Lctr_MP") -fractionMode true -follow true -followAxis x -upAxis z
				-worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + $nPd + $i + "F") -inverseUp false -inverseFront false -bank false
				($modCore + $nPd + $i + "CurveLctrGrp") ($modCore + "_SplineTop");
				cutKey -cl -t ":" -f ":" -at "u" ($modCore + $nPd + $i + "Lctr_MP");
				float $uValue = (((float)$i - (((float)$splineSize + 1.0)/2.0))/(((float)$splineSize + 1.0)/2.0));
				if ($uValue > 0.99999)
				{
					$uValue = (0.99999 * $uValueComp);
				}
				else
				{
					$uValue = ($uValue * $uValueComp);
				}
				setAttr ($modCore + $nPd + $i + "Lctr_MP.uValue") $uValue;
			}
			delete `parentConstraint  ($modCore + $nPd + $i + "FKCtrl") ($modCore + $nPd + $i + "CurveLctr")`;
			$i++;
		}

		$curveLctrGrp = `ls ($modCore + "_??CurveLctrGrp")`;
		parent $curveLctrGrp ($modCore + "Grp");
		//CONNECT TO MAINCtrl SCALE
		for ($each in $curveLctrGrp)
		{
			connectAttr -f ($modName + "_MAINCtrl.scale") ($each + ".scale");
		}
		
		//GET POSITIONS
		$modAttachNodePos = `xform -q -ws -rp ($modCore)`;
		$spineTopJPos = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Top")`;
		$SpineCenter = `xform -q -ws -t ($modCore + "_SplineTop.cv[0]")`;
		
		//CREATE CLUSTERS SPLINE SPLINE
		select ($modCore + "_SplineBtm.cv[0:1]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_SplineBtm_BtmClstr");
		group -n ($modCore + "_SplineBtm_ClusterGrp") ($modCore + "_SplineBtm_BtmClstr");
		xform -os -piv $modAttachNodePos[0] $modAttachNodePos[1] $modAttachNodePos[2];
		parentConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_SplineBtm_ClusterGrp");
		
		select ($modCore + "_SplineBtm.cv[2:3]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_SplineBtm_TopClstr");
	
		select ($modCore + "_SplineTop.cv[0:1]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_SplineTop_BtmClstr");
		
		group -n ($modCore + "_SplineMid_ClusterGrp") ($modCore + "_SplineBtm_TopClstr")($modCore + "_SplineTop_BtmClstr");
		xform -os -piv $SpineCenter[0] $SpineCenter[1] $SpineCenter[2];
		parentConstraint -mo ($modCore + "_MidIKCtrl") ($modCore + "_SplineMid_ClusterGrp");
		
		select ($modCore + "_SplineTop.cv[2:3]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_SplineTop_TopClstr");
		group -n ($modCore + "_SplineTop_ClusterGrp") ($modCore + "_SplineTop_TopClstr");
		xform -os -piv $spineTopJPos[0] $spineTopJPos[1] $spineTopJPos[2];
		parentConstraint -mo ($modCore + "_TopIKCtrl") ($modCore + "_SplineTop_ClusterGrp");
											 
		parent ($modCore + "_SplineTop_ClusterGrp") ($modCore + "_SplineMid_ClusterGrp") ($modCore + "_SplineBtm_ClusterGrp") ($modCore + "_ScaleGrp");
		
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		//TOP AND BOTTOM JOINTS
		select -cl;
		joint -n ($modCore + "_TopJnt");
		delete `parentConstraint ($modCore + "_TopIKCtrl") ($modCore + "_TopJnt")`;
		if ($twistAxis == 1)
		{
			rotate -r -os 0 0 90 ($modCore + "_TopJnt");
		}
		makeIdentity -apply true -r 1 ($modCore + "_TopJnt");
		parentConstraint -mo ($modCore + "_TopIKCtrl") ($modCore + "_TopJnt");
		//CONNECT SCALE
		connectAttr -f ($modCore + "_TopIKCtrl.scaleX") ($modCore + "_TopJnt.scaleY");
		connectAttr -f ($modCore + "_TopIKCtrl.scaleY") ($modCore + "_TopJnt.scaleX");
		connectAttr -f ($modCore + "_TopIKCtrl.scaleZ") ($modCore + "_TopJnt.scaleZ");
			
		parent ($modCore + "_TopJnt") ($modCore + "_ScaleGrp");
			
		select -cl;
		joint -n ($modCore + "_TopJntIK") -p 0 2 0 ;
		
		select -cl;
		joint -n ($modCore + "_BtmJntIK") -p 0 -2 0 ;
		
		select -cl;
		joint -n ($modCore + "_MidJntIK") -p 0 0 0 ;
		
		string $selectedList[] = `ls ($modCore + "_TopJntIK") ($modCore + "_BtmJntIK") ($modCore + "_MidJntIK")`;
				
		for ($crntObject in $selectedList)		
		{
			if ($twistAxis == 0)
			{
				setAttr (($crntObject + ".jointOrient"), -90, 0, 90);
			}
			setAttr ($crntObject + ".radius") .5;
		}

		//GROUP AND SCALE
		group -n ($modCore + "_ribbonSplineGrp") ($modCore + "_ribbon");
		parent ($modCore + "_BtmJntIK") ($modCore + "_MidJntIK") ($modCore + "_TopJntIK") ($modCore + "_ScaleGrp");
		
		$splineLength = `xform -q -t ($modCore + "_EndLctr")`;
		if ($twistAxis == 1)
		{
			setAttr (($modCore + "_ribbonSplineGrp.scale"), ($splineLength[1] / 4), ($splineLength[1] / 4), ($splineLength[1] / 4));
		}
		else
		{
			setAttr (($modCore + "_ribbonSplineGrp.scale"), ($splineLength[0] / 4), ($splineLength[0] / 4), ($splineLength[0] / 4));
		}
		//CONNECT TO RIG
		delete `parentConstraint ($modCore + "_OrientLctr") ($modCore + "_ribbonSplineGrp")`;
		if ($twistAxis == 0)
		{
			rotate -r -os 0 0 -90 ($modCore + "_ribbonSplineGrp");
		}
		delete `pointConstraint ($modCore + "_OrientLctr") ($modCore + "_OrientLengthLctr") ($modCore + "_ribbonSplineGrp")`;
		
		parentConstraint ($modCore + "_TopIKCtrl") ($modCore + "_TopJntIK") ;
		
		parentConstraint ($modCore + "_MidIKCtrl") ($modCore + "_MidJntIK") ;
		
		parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_BtmJntIK") ;
		
		select ($modCore + "_ribbon") ($modCore + "_TopJntIK") ($modCore + "_BtmJntIK") ($modCore + "_MidJntIK");

		//DETERMINE VERSION NUMBER
		//$versionNum = `getApplicationVersionAsFloat`;
		if (`getApplicationVersionAsFloat` >= 2013)
		{
			skinCluster -n ($modCore + "_ribbonSkinClstr")  -bindMethod 1 -toSelectedBones -nw 1 -mi 3 -dr 4 -rui 0;
		}
		else
		{
			skinCluster -n ($modCore + "_ribbonSkinClstr") -toSelectedBones -ignoreHierarchy -mi 3 -dr 1 -rui 0;
		}
		//GENERATE JOINTS
		string $splineJoints[];
		int $crntNum = 0;
		float $splineLoc[];
		for ($crntProxy in $splineProxies)
		{
			$crntNum++;
			$numPadding = "_0";
			if ($crntNum >= 10)
			{$numPadding = "_";}
			if ($twistAxis == 0)
			{
				curve -d 1 -p -4 0 0 -p 4 0 0 -k 0 -k 1 -n ($modCore + $numPadding + $crntNum + "CurveCtrl");
			}
			else
			{
				curve -d 1 -p 0 0 -4 -p 0 0 4 -k 0 -k 1 -n ($modCore + $numPadding + $crntNum + "CurveCtrl");
				
			}
			pickWalk -d down;
			rename ($modCore + $numPadding + $crntNum + "CurveCtrlShape");
			
			if ($twistAxis == 0)
			{
				circle -c 5 0 0 -nr 0 1 0 -n ($modCore + $numPadding + $crntNum + "CurveCtrl2") -ch 0;
				circle -c -5 0 0 -nr 0 1 0 -n ($modCore + $numPadding + $crntNum + "CurveCtrl3") -ch 0;				
			}
			else
			{
				circle -c 0 0 5 -nr 1 0 0 -n ($modCore + $numPadding + $crntNum + "CurveCtrl2") -ch 0;
				circle -c 0 0 -5 -nr 1 0 0 -n ($modCore + $numPadding + $crntNum + "CurveCtrl3") -ch 0;
			}
			select ($modCore + $numPadding + $crntNum + "CurveCtrl2") ($modCore + $numPadding + $crntNum + "CurveCtrl3");
			pickWalk -d down;
			select -add ($modCore + $numPadding + $crntNum + "CurveCtrl");
			parent -r -s;
			delete ($modCore + $numPadding + $crntNum + "CurveCtrl2") ($modCore + $numPadding + $crntNum + "CurveCtrl3");
			setAttr (($modCore + $numPadding + $crntNum + "CurveCtrl.scale"), ($getSplineLength*.06),($getSplineLength*.06),($getSplineLength*.06));
			makeIdentity -apply true -s 1 ($modCore + $numPadding + $crntNum + "CurveCtrl");
				
			group -n ($modCore + $numPadding + $crntNum + "CurveCtrlGrp") ($modCore + $numPadding + $crntNum + "CurveCtrl");

			delete `parentConstraint ("RRM_" + $prfx + $core + $numPadding + $crntNum)  ($modCore + $numPadding + $crntNum + "CurveCtrlGrp")`;
			pointConstraint -mo ($modCore + $numPadding + $crntNum + "CurveLctr") ($modCore + $numPadding + $crntNum + "FKCtrl") ($modCore + $numPadding + $crntNum + "CurveCtrlGrp");
			orientConstraint -mo ($modCore + $numPadding + $crntNum + "F") ($modCore + $numPadding + $crntNum + "CurveLctr");
			orientConstraint ($modCore + $numPadding + $crntNum + "CurveLctr") ($modCore + $numPadding + $crntNum + "FKCtrl") ($modCore + $numPadding + $crntNum + "CurveCtrlGrp");
			setAttr ($modCore + $numPadding + $crntNum + "CurveLctr_orientConstraint1.interpType") 2;
			setAttr ($modCore + $numPadding + $crntNum + "CurveCtrlGrp_orientConstraint1.interpType") 2;
			
			select -cl;
			joint -n ($modCore + $numPadding + $crntNum + "Jnt");

			parent ($modCore + $numPadding + $crntNum + "CurveCtrlGrp") ($modCore + $numPadding + $crntNum + "Jnt") ($modCore + "_ScaleGrp");

			delete `parentConstraint ($modCore + $numPadding + $crntNum + "CurveCtrl") ($modCore + $numPadding + $crntNum + "Jnt")`;
			//if ($twistAxis == 0)
			//{
			//	rotate -r -os 0 0 90 ($modCore + $numPadding + $crntNum + "Jnt");
			//}
			makeIdentity -apply true -r 1 ($modCore + $numPadding + $crntNum + "Jnt");
			parentConstraint -mo ($modCore + $numPadding + $crntNum + "CurveCtrl") ($modCore + $numPadding + $crntNum + "Jnt");
			$splineJoints = `ls ($modCore + $numPadding + $crntNum + "Jnt")`;
		}	

		//SPLINE FOLLOW FK
		addAttr -ln "followFKCtrl"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_TopIKCtrl");
		setAttr -e-keyable 1 ($modCore + "_TopIKCtrl.followFKCtrl");
		
		//SELECT FKC
		$spineGrp = `ls ($modCore + "_??CurveCtrlGrp")`;
		string $nPd = "0";
		$i = 1;
		for ($each in $spineGrp)
		{
			if ($i >= 10)
			{
				$nPd = "";
			}
			setAttr ($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1") 0;
			setAttr ($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1") 0;
	    
			setDrivenKeyframe -currentDriver ($modCore + "_TopIKCtrl.followFKCtrl")
			($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0")
			($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1")
			($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0")
			($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1");
			
			setAttr ($modCore + "_TopIKCtrl.followFKCtrl") 1;
			setAttr ($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0") 0;
			setAttr ($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1") 1;
			setAttr ($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0") 0;
			setAttr ($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1") 1;
	    
			setDrivenKeyframe -currentDriver ($modCore + "_TopIKCtrl.followFKCtrl")
			($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0")
			($each + "_pointConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1")
			($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "CurveLctrW0")
			($each + "_orientConstraint1." + $modCore + "_" + $nPd + $i + "FKCtrlW1");
			
			//selectKey -k ($modCore + "_ribbonBlend_lClusterGrp_scaleY") ($modCore + "_ribbonBlend_rClusterGrp_scaleY") ;
			keyTangent -itt spline -ott spline ($each + "_pointConstraint1_" + $modCore + "_" + $nPd + $i + "CurveLctrW0") ($each + "_pointConstraint1_" + $modCore + "_" + $nPd + $i + "FKCtrlW1");
			
			setAttr ($modCore + "_TopIKCtrl.followFKCtrl") 0;
			
			$i++;
		}
		
		//CREATE CURVE FOR SPLINE LENGTH
		$Parent_Pos = `xform -q -ws -t ("RRM_" + $prfx + $core + "_Parent")`;
		$spineMidJntIK_Pos = `xform -q -ws -t ($modCore + "_MidJntIK")`;
		$spineTop_Pos = `xform -q -ws -t ($modCore + "_TopJntIK")`;
		
		curve -n ($modCore + "_LengthCurve")
		-p $Parent_Pos[0] $Parent_Pos[1] $Parent_Pos[2]
		-p (( $spineMidJntIK_Pos[0] - $Parent_Pos[0]) /3.4 + $Parent_Pos[0])
		(( $spineMidJntIK_Pos[1] - $Parent_Pos[1]) /3.4 + $Parent_Pos[1])
		(( $spineMidJntIK_Pos[2] - $Parent_Pos[2]) /3.4 + $Parent_Pos[2])
		
		-p (( $spineMidJntIK_Pos[0] - $Parent_Pos[0]) /1.35 + $Parent_Pos[0])
		(( $spineMidJntIK_Pos[1] - $Parent_Pos[1]) /1.35 + $Parent_Pos[1])
		(( $spineMidJntIK_Pos[2] - $Parent_Pos[2]) /1.35 + $Parent_Pos[2])
		
		-p (($spineTop_Pos[0] - $spineMidJntIK_Pos[0]) /3.7 + $spineMidJntIK_Pos[0])
		(($spineTop_Pos[1] - $spineMidJntIK_Pos[1]) /3.7 + $spineMidJntIK_Pos[1])
		(($spineTop_Pos[2] - $spineMidJntIK_Pos[2]) /3.7 + $spineMidJntIK_Pos[2])
		
		-p (($spineTop_Pos[0] - $spineMidJntIK_Pos[0]) /1.4 + $spineMidJntIK_Pos[0])
		(($spineTop_Pos[1] - $spineMidJntIK_Pos[1]) /1.4 + $spineMidJntIK_Pos[1])
		(($spineTop_Pos[2] - $spineMidJntIK_Pos[2]) /1.4 + $spineMidJntIK_Pos[2])
		-p $spineTop_Pos[0] $spineTop_Pos[1] $spineTop_Pos[2]
		-k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 3 -k 3;
		rename `listRelatives -c ($modCore + "_LengthCurve")` ($modCore + "_LengthCtrlShape");
		select ($modCore + "_LengthCurve");
		arclen -ch 1;
		string $curveInfoNode[] = `listConnections -t curveInfo -d 1 -s 0 ($modCore + "_LengthCtrlShape")`;
		rename $curveInfoNode[0] ($modCore + "_LengthInfo");	
		
		parent ($modCore + "_LengthCurve") ($modCore + "Grp");
		
		//ATTACH CURVE TO RIG
		select ($modCore + "_LengthCurve.cv[0:1]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_LengthClstr01");
		
		select ($modCore + "_LengthCurve.cv[2:3]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_LengthClstr02");
		
		select ($modCore + "_LengthCurve.cv[4:5]") ;
		newCluster " -envelope 1";
		rename ($modCore + "_LengthClstr03");
		
		connectAttr -f ($modName + "_" + $modAttachNode + "Jnt.matrix") ($modCore + "_LengthClstr01Shape.weightedNode");
		setAttr ($modCore + "_LengthClstr01Cluster.relative") 0;
		parent ($modCore + "_LengthClstr01") ($modCore + "_ScaleGrp");
		parentConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_LengthClstr01");
		
		connectAttr -f ($modCore + "_MidIKCtrl.matrix") ($modCore + "_LengthClstr02Shape.weightedNode");
		setAttr ($modCore + "_LengthClstr02Cluster.relative") 0;
		parent ($modCore + "_LengthClstr02") ($modCore + "_MidIKCtrl");
		
		connectAttr -f ($modCore + "_TopIKCtrl.matrix") ($modCore + "_LengthClstr03Shape.weightedNode");
		setAttr ($modCore + "_LengthClstr03Cluster.relative") 0;
		parent ($modCore + "_LengthClstr03") ($modCore + "_TopIKCtrl");
		
		//SCALE
		shadingNode -asUtility multiplyDivide -n ($modCore + "_HierarchyCompensate_MD");
		setAttr ($modCore + "_HierarchyCompensate_MD.operation") 2;
		connectAttr -f ($modCore + "_LengthInfo.arcLength") ($modCore + "_HierarchyCompensate_MD.input1X");
		connectAttr -f ($modName + "_MAINCtrl.scaleY") ($modCore + "_HierarchyCompensate_MD.input2X");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_LengthRatio_MD");
		connectAttr -f ($modCore + "_HierarchyCompensate_MD.outputX") ($modCore + "_LengthRatio_MD.input1X");
		setAttr ($modCore + "_LengthRatio_MD.operation") 2;
		
		float $SpineLengthValue = `getAttr ($modCore + "_LengthInfo.arcLength")`;
		setAttr ($modCore + "_LengthRatio_MD.input2X") $SpineLengthValue;
		
		connectAttr -f ($modCore + "_LengthRatio_MD.outputX") ($modCore + "_TopJntIK.scaleY");
		connectAttr -f ($modCore + "_LengthRatio_MD.outputX") ($modCore + "_MidJntIK.scaleY");
		connectAttr -f ($modCore + "_LengthRatio_MD.outputX") ($modCore + "_BtmJntIK.scaleY");
		
		//INVERSE SCALE
		shadingNode -asUtility multiplyDivide -n ($modCore + "_LengthRatioInverse_MD");
		connectAttr -f ($modCore + "_HierarchyCompensate_MD.outputX") ($modCore + "_LengthRatioInverse_MD.input2X");
		setAttr ($modCore + "_LengthRatioInverse_MD.operation") 2;
		
		setAttr ($modCore + "_LengthRatioInverse_MD.input1X") $SpineLengthValue;
		
		shadingNode -asUtility blendColors -n ($modCore + "_LengthRatioInverse_Blnd");
		setAttr ($modCore + "_LengthRatioInverse_Blnd.color2") -type double3 1 1 1 ;
		connectAttr -f ($modCore + "_LengthRatioInverse_MD.outputX") ($modCore + "_LengthRatioInverse_Blnd.color1R");
	
		$spineJnt = `ls ($modCore + "_??Jnt")`;
		int $i= 0;
		for ($crntJnt in $spineJnt)
		{
			$i++;
			string $numPad = "_0";
			if ($i >= 10)
			{
				$numPad = "_";
			}
			//CONNECT MICRO CONTROL TO SCALE
			shadingNode -asUtility multiplyDivide -n ($modCore + $numPad + $i + "CurveCtrl_Scale_MD");
			connectAttr -f ($modCore + $numPad + $i + "CurveCtrl.scaleX") ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.input2X");
			connectAttr -f ($modCore + $numPad + $i + "CurveCtrl.scaleY") ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.input2Y");
			connectAttr -f ($modCore + $numPad + $i + "CurveCtrl.scaleZ") ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.input2Z");
		
			if ($twistAxis == 1)
			{
				connectAttr -f ($modCore + "_LengthRatio_MD.outputX") ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.input1Y");
				connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.input1X");
				connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.input1Z");
			}
			else
			{
				connectAttr -f ($modCore + "_LengthRatio_MD.outputX") ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.input1X");
				connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.input1Y");
				connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.input1Z");
			}
			
			connectAttr -f ($modCore + $numPad + $i + "CurveCtrl_Scale_MD.output") ($crntJnt + ".scale");
		}
		
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_TopJntIK.scaleX");
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_TopJntIK.scaleZ");
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_MidJntIK.scaleX");
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_MidJntIK.scaleZ");
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_BtmJntIK.scaleX");
		connectAttr -f ($modCore + "_LengthRatioInverse_Blnd.outputR") ($modCore + "_BtmJntIK.scaleZ");
		
		//ADD ATTRIBUTES TO TOPIKC
		//PARENT ORIENT
		$parentOrient = ($modCore + "_TopIKCtrl");
		RRM_ParentOrient_V1($modCore, $modName, $modAttachNode, $parentOrient); 
			
		//AUTO VOLUME
		addAttr -ln "autoVolume"  -at double  -min 0 -max 1 -dv 1 ($modCore + "_TopIKCtrl");
		setAttr -e-keyable 1 ($modCore + "_TopIKCtrl.autoVolume");
		connectAttr -force ($modCore + "_TopIKCtrl.autoVolume") ($modCore + "_LengthRatioInverse_Blnd.blender");
		setAttr ($modCore + "_TopIKCtrl.autoVolume") 1;
	
		//SPLINE CURVE
		addAttr -ln "splineCurve"  -at double  -min 0.001 -max 5 -dv 1 ($modCore + "_TopIKCtrl");
		setAttr -e-keyable 1 ($modCore + "_TopIKCtrl.splineCurve");
		
		
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////CONNECT CONTROLS///////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		//RIBBON SPLINE
		
		//CREATE LOCATORS FOR TX
		spaceLocator -n ($modCore + "_BtmTX_Lctr") -p 0 0 0;
		parent ($modCore + "_BtmTX_Lctr") ($modCore + "_ScaleGrp");
		pointConstraint ($modCore + "_MidIKCtrl") ($modCore + "_BtmTX_Lctr");
		
		spaceLocator -n ($modCore + "_TopTX_Lctr") -p 0 0 0;
		parent ($modCore + "_TopTX_Lctr") ($modCore + "_TopIKCtrl");
		pointConstraint ($modCore + "_MidIKCtrl") ($modCore + "_TopTX_Lctr");
		
		//SET DRIVEN KEY
		setDrivenKeyframe -currentDriver ($modCore + "_MidIKCtrl.translateX") ($modCore + "_ribbonBlend_lClusterGrp.scaleY");
		setDrivenKeyframe -currentDriver ($modCore + "_MidIKCtrl.translateX") ($modCore + "_ribbonBlend_rClusterGrp.scaleY");
		setAttr ($modCore + "_MidIKCtrl.translateX") -4;
		setAttr ($modCore + "_ribbonBlend_lClusterGrp.scaleY") .8;
		setAttr ($modCore + "_ribbonBlend_rClusterGrp.scaleY") 1.2;
		setDrivenKeyframe -currentDriver ($modCore + "_MidIKCtrl.translateX") ($modCore + "_ribbonBlend_lClusterGrp.scaleY");
		setDrivenKeyframe -currentDriver ($modCore + "_MidIKCtrl.translateX") ($modCore + "_ribbonBlend_rClusterGrp.scaleY");
		setAttr ($modCore + "_MidIKCtrl.translateX") 4;
		setAttr ($modCore + "_ribbonBlend_lClusterGrp.scaleY") 1.2;
		setAttr ($modCore + "_ribbonBlend_rClusterGrp.scaleY") .8;
		setDrivenKeyframe -currentDriver ($modCore + "_MidIKCtrl.translateX") ($modCore + "_ribbonBlend_lClusterGrp.scaleY");
		setDrivenKeyframe -currentDriver ($modCore + "_MidIKCtrl.translateX") ($modCore + "_ribbonBlend_rClusterGrp.scaleY");
		setAttr ($modCore + "_MidIKCtrl.translateX") 0;
		setAttr ($modCore + "_ribbonBlend_lClusterGrp.scaleY") 1;
		setAttr ($modCore + "_ribbonBlend_rClusterGrp.scaleY") 1;
		
		//selectKey -k ($modCore + "_ribbonBlend_lClusterGrp_scaleY") ($modCore + "_ribbonBlend_rClusterGrp_scaleY") ;
		keyTangent -itt spline -ott spline ($modCore + "_ribbonBlend_lClusterGrp_scaleY") ($modCore + "_ribbonBlend_rClusterGrp_scaleY");
		
		//ATTACH NODE LOCATOR WITH ZEROED VALUES
		spaceLocator -n ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_Lctr");
		group -n ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_LctrGrp");
		delete `pointConstraint ($modCore) ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_LctrGrp")`;
		delete `aimConstraint -aimVector 0 1 0 -upVector 0 0 1 -worldUpType "objectRotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + "_MidIKCtrl")
		($modCore + "_TopIKCtrl") ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_LctrGrp")`;
		parent ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_LctrGrp") ($modCore + "_ScaleGrp");
		makeIdentity -apply true -t 1 -r 0 -s 1 ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_LctrGrp");
		parentConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_Lctr");
		
	
		//CONNECT SPLINE IK MIDDLE TO TOP AND BOTTOM SPLINE IK
		shadingNode -n ($modCore + "_SplineMid_Blnd") -asUtility blendColors;
		connectAttr -f ($modCore + "_TopIKCtrl.translate") ($modCore + "_SplineMid_Blnd.color1");
		connectAttr -f ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_Lctr.translate") ($modCore + "_SplineMid_Blnd.color2");

		
		spaceLocator -n ($modCore + "_MidSplineAimLctr");
		spaceLocator -n ($modCore + "_MidSplineTargetLctr");
		group -n ($modCore + "_MidSplineLctrGrp") ($modCore + "_MidSplineAimLctr") ($modCore + "_MidSplineTargetLctr");
		parent ($modCore + "_MidSplineLctrGrp") ($modCore + "_ScaleGrp");
		delete `pointConstraint ($modCore) ($modCore + "_MidSplineLctrGrp")`;
		if ($twistAxis == 1)
		{
			delete `aimConstraint -aimVector 0 1 0 -upVector 0 0 1 -worldUpType "objectRotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + "_MidIKCtrl")
			($modCore + "_TopIKCtrl") ($modCore + "_MidSplineLctrGrp")`;
		}
		else
		{
			delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectRotation" -worldUpVector 0 1 0 -worldUpObject ($modCore + "_MidIKCtrl")
			($modCore + "_TopIKCtrl") ($modCore + "_MidSplineLctrGrp")`;
		}			
		delete `pointConstraint ($modCore + "_TopIKCtrl") ($modCore + "_MidSplineTargetLctr")`;
		
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_MidSplineAimLctr") ($modCore + "_MidSplineTargetLctr");

		connectAttr -f ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_Lctr.translate") ($modCore + "_MidSplineAimLctr.translate");
		connectAttr -f ($modCore + "_TopIKCtrl.translate") ($modCore + "_MidSplineTargetLctr.translate");
		
		if ($twistAxis == 1)
		{
			aimConstraint -aimVector 0 1 0 -upVector 0 1 0 -worldUpType "none" -skip y ($modCore + "_MidSplineTargetLctr") ($modCore + "_MidSplineAimLctr");
		}
		else
		{		
			aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" -skip x ($modCore + "_MidSplineTargetLctr") ($modCore + "_MidSplineAimLctr");
		}
		//connectAttr -f ($modCore + "_MidSplineAimLctr.rotateY") ($modCore + "_MidIKCtrlLctr.rotateY");
		//connectAttr -f ($modCore + "_MidSplineAimLctr.rotateZ") ($modCore + "_MidIKCtrlLctr.rotateZ");
		//CREATE ATTRIBUTES FOR IK/FK MIDIKCtrlGrp INFLUENCE
		addAttr -ln "topIKInfPos"  -at double  -min 0 -max 1 -dv 0.5 ($modCore + "_MidIKCtrl");
		setAttr -e-keyable 1 ($modCore + "_MidIKCtrl.topIKInfPos");
		addAttr -ln "topIKInfRot"  -at double  -min 0 -max 1 -dv 0.5 ($modCore + "_MidIKCtrl");
		setAttr -e-keyable 1 ($modCore + "_MidIKCtrl.topIKInfRot");
		
		//CREATE LOCATOR FOR IK/FK MIDIKCtrlGrp INFLUENCE
		spaceLocator -n ($modCore + "_MidIKCtrlLctrGrp_InfLctr");
		group -n ($modCore + "_MidIKCtrlLctrGrp_InfLctrGrp");
		delete `parentConstraint ($modCore + "_MidIKCtrl") ($modCore + "_MidIKCtrlLctrGrp_InfLctrGrp")`;
		parent ($modCore + "_MidIKCtrlLctrGrp_InfLctrGrp") ($modCore + "_ScaleGrp");
		makeIdentity -apply true -t 1 ($modCore + "_MidIKCtrlLctrGrp_InfLctr");
		parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_TopIKCtrl") ($modCore + "_MidIKCtrlLctrGrp_InfLctr");
		if ($twistAxis == 1)
		{
			aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 1 0 -upVector 0 0 1 -worldUpType "none" -skip y ($modCore + "_TopIKCtrl") ($modCore + "_MidIKCtrlLctrGrp_InfLctr");
		}
		else
		{	
			aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" -skip x ($modCore + "_TopIKCtrl") ($modCore + "_MidIKCtrlLctrGrp_InfLctr");
		}
		setAttr ($modCore + "_MidIKCtrlLctrGrp_InfLctr.v") 0;
		
		//ROTATE BLEND
		shadingNode -asUtility blendColors -n ($modCore + "_MidIKCtrlLctrGrp_Inf_Rot_Blend");
		connectAttr -force ($modCore + "_MidSplineAimLctr.rotate") ($modCore + "_MidIKCtrlLctrGrp_Inf_Rot_Blend.color2");
		connectAttr -force ($modCore + "_MidIKCtrlLctrGrp_InfLctr.rotate") ($modCore + "_MidIKCtrlLctrGrp_Inf_Rot_Blend.color1");
		connectAttr -force ($modCore + "_MidIKCtrl.topIKInfRot") ($modCore + "_MidIKCtrlLctrGrp_Inf_Rot_Blend.blender");
		

		connectAttr -force ($modCore + "_MidIKCtrlLctrGrp_Inf_Rot_Blend.outputR") ($modCore + "_MidIKCtrlLctr.rotateX");
		connectAttr -force ($modCore + "_MidIKCtrlLctrGrp_Inf_Rot_Blend.outputG") ($modCore + "_MidIKCtrlLctr.rotateY");
		connectAttr -force ($modCore + "_MidIKCtrlLctrGrp_Inf_Rot_Blend.outputB") ($modCore + "_MidIKCtrlLctr.rotateZ");
		
		
		//TRANSLATE BLEND
		shadingNode -asUtility blendColors -n ($modCore + "_MidIKCtrlLctrGrp_Inf_Trn_Blend");
		connectAttr -force ($modCore + "_SplineMid_Blnd.output") ($modCore + "_MidIKCtrlLctrGrp_Inf_Trn_Blend.color2");
		connectAttr -force ($modCore + "_MidIKCtrlLctrGrp_InfLctr.translate") ($modCore + "_MidIKCtrlLctrGrp_Inf_Trn_Blend.color1");
		connectAttr -force ($modCore + "_MidIKCtrl.topIKInfPos") ($modCore + "_MidIKCtrlLctrGrp_Inf_Trn_Blend.blender");
		
		connectAttr -force ($modCore + "_MidIKCtrlLctrGrp_Inf_Trn_Blend.output") ($modCore + "_MidIKCtrlLctr.translate");
	
		//SPLINE LENGTH
		addAttr -ln "splineLength"  -at double ($modCore + "_MidIKCtrl");
		setAttr -e-channelBox true ($modCore + "_MidIKCtrl.splineLength");
		addAttr -ln "splineLength"  -at double ($modCore + "_TopIKCtrl");
		setAttr -e-channelBox true ($modCore + "_TopIKCtrl.splineLength");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_Length_MD");
		setAttr ($modCore + "_Length_MD.operation") 2;
		$splineLength[0] = `getAttr ($modCore + "_LengthInfo.arcLength")`;
		setAttr ($modCore + "_Length_MD.input2X") $splineLength[0];
		connectAttr -f ($modCore + "_LengthInfo.arcLength") ($modCore + "_Length_MD.input1X");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_LengthComp_MD");
		setAttr ($modCore + "_LengthComp_MD.operation") 2;
		connectAttr -force ($modCore + "_Length_MD.outputX") ($modCore + "_LengthComp_MD.input1X");
		connectAttr -force ($modName + "_MAINCtrl.scaleY") ($modCore + "_LengthComp_MD.input2X");
		
		connectAttr -f ($modCore + "_LengthComp_MD.outputX") ($modCore + "_MidIKCtrl.splineLength");
		connectAttr -f ($modCore + "_LengthComp_MD.outputX") ($modCore + "_TopIKCtrl.splineLength");
	
		shadingNode -asUtility blendColors -n ($modCore + "_Spline_Blnd");
		connectAttr -f ($modCore + "_LengthComp_MD.outputX") ($modCore + "_Spline_Blnd.color1R");
		connectAttr -f ($modCore + "_TopIKCtrl.splineCurve") ($modCore + "_Spline_Blnd.color2R");
		
		connectAttr -f ($modCore + "_Spline_Blnd.outputR") ($modCore + "_SplineBtm_ClusterGrp.sy");
		connectAttr -f ($modCore + "_Spline_Blnd.outputR") ($modCore + "_SplineMid_ClusterGrp.sy");
		connectAttr -f ($modCore + "_Spline_Blnd.outputR") ($modCore + "_SplineTop_ClusterGrp.sy");
		
		//////////////////////////////////LOCK & HIDE//////////////////////////////////
	
		//VISIBILITY
		$SpineCurveLctrs = `ls ($modCore + "_??CurveLctr")`;
		for ($crntLctr in $SpineCurveLctrs)
		{
			setAttr ($crntLctr + ".v") 0;
		}
		
	
		//SPLINE MICROS
		addAttr -ln "splineMicro"  -at bool  ($modCore + "_TopIKCtrl");
		setAttr -e-k true ($modCore + "_TopIKCtrl.splineMicro");
		
		$splineCurveCtrlGrp = `ls ($modCore + "_??CurveCtrlGrp")`;
		for ($crntCtrlGrp in $splineCurveCtrlGrp)
		{
			connectAttr -f ($modCore + "_TopIKCtrl.splineMicro") ($crntCtrlGrp + ".v");
		}
	
		setAttr ($modCore + "_StartLctr.v") 0;
		setAttr ($modName + "_" + $modAttachNode + "_" + $prfx + "Jnt_" + $core + "_Lctr.v") 0;
	
		setAttr ($modCore + "_SplineBtm_BtmClstr.v") 0;
		setAttr ($modCore + "_SplineBtm_TopClstr.v") 0;
		setAttr ($modCore + "_SplineTop_BtmClstr.v") 0;
		setAttr ($modCore + "_SplineTop_TopClstr.v") 0;
	
		setAttr ($modCore + "_LengthClstr01.v") 0;
		setAttr ($modCore + "_LengthClstr02.v") 0;
		setAttr ($modCore + "_LengthClstr03.v") 0;
	
	
		setAttr ($modCore + "_ribbon.v") 0;
		setAttr ($modCore + "_ribbonBlend.v") 0;
		setAttr ($modCore + "_ribbonBlend_rCluster.v") 0;
		setAttr ($modCore + "_ribbonBlend_lCluster.v") 0;
		setAttr ($modCore + "_BtmTX_Lctr.v") 0;
		setAttr ($modCore + "_TopTX_Lctr.v") 0;
		setAttr ($modCore + "_BtmJntIK.v") 0;
		setAttr ($modCore + "_MidJntIK.v") 0;
		setAttr ($modCore + "_TopJntIK.v") 0;
		setAttr ($modCore + "_LengthCurve.template") 1;
		
		setAttr -l 1 -k 0 ($modCore + "_BtmJntIK.v");
		setAttr -l 1 -k 0 ($modCore + "_MidJntIK.v");
		setAttr -l 1 -k 0 ($modCore + "_TopJntIK.v");
		
	
		addAttr -ln "nonControl"  -dt "string" ($modCore + "_LengthCurve");
		setAttr -e-keyable 1 ($modCore + "_LengthCurve.nonControl");
		setAttr -lock 1 ($modCore + "_LengthCurve.nonControl");
		
		$spineF = `ls ($modCore + "_??F")`;
		for ($crntF in $spineF)
		{
			setAttr ($crntF + ".v") 0;
		}
		
		setAttr ($modCore + "_MidSplineTargetLctr.v") 0;
		setAttr ($modCore + "_MidSplineAimLctr.v") 0;
		
		setAttr -l 1 -k 0 ($modCore + "_TopIKCtrl.v");

		setAttr -l 1 -k 0 ($modCore + "_MidIKCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_MidIKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_MidIKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_MidIKCtrl.v");
		
	
		//ADD CORE NAME
		$modControls = `ls ($modCore + "_*Ctrl")`;
		for ($crntModControl in $modControls)
		{
			if (!`objExists ($crntModControl + ".modCoreName")`)
			{
				addAttr -ln "modCoreName"  -dt "string" $crntModControl;
				setAttr -e-keyable 1 ($crntModControl + ".modCoreName");
				setAttr -type "string" ($crntModControl + ".modCoreName") ("_" + $prfx + $core);
				setAttr -e-lock 1 ($crntModControl + ".modCoreName");
			}
			//ADD MODULE TYPE
			if (!`objExists ($crntModControl + ".moduleType")`)
			{
				addAttr -ln "moduleType"  -dt "string" ($crntModControl);
				setAttr -e -keyable 1 ($crntModControl + ".moduleType");
				setAttr -type "string" ($crntModControl + ".moduleType") "spline";
				setAttr -l true ($crntModControl + ".moduleType");
			}
		}
		
		//CLEAN UP
		delete ($modCore + "_OrientLctr");
		
		select -cl;
		
		//SETUP FOR RIGHT SIDE
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$mirrorInt++;
		$multiplier = -1;
	}
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}


//////////////////////////////////////////////////////////////////////////////
///////////////////////////////    TOON LIMB    ///////////////////////////////
//////////////////////////////////////////////////////////////////////////////

global proc RRM_ToonLimbs_V1(string $modName, string $limbType, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, string $modCore, string $modOppCore, int $multiplier, int $inverseFront, string $modAttachNode, string $topNode)
{
	string $crntUnit = `currentUnit -query -linear`;
	$uValComp = 1;
	if ($crntUnit == "m")
	{
		$uValComp = 0.01;
	}

	$core = `getAttr ($topNode + ".core")`;

	float $elbow1Loc[];
	float $elbow2Loc[];	
	string $elbow1 = "_Elbow";
	string $elbow2 = "_Elbow";
	string $elbowType = "elbow";
	string $shoulder = "_Shoulder";
	string $clavicle = "_Clavicle";
	string $parentNode = "_ClavicleJnt";
	string $wrist = "_Wrist";
	string $wristDummy = "_WristJntDummy";
	string $FKCtrlGrp = "FKCtrlGrp2";
	int $segInteger = 1;
	float $limbLength;

	if ($limbType == "leg")
	{
		$elbow1 = "_Knee";
		$elbow2 = "_Knee";
		$elbowType = "knee";
		$shoulder = "_Hip";
		$clavicle = ("_" + $modAttachNode);
		$parentNode = "_HipFKCtrlGrp";
		$wrist = "_Ankle";
		$wristDummy = "_AnkleJnt";
		$FKCtrlGrp = "FKCtrlGrp";
		select ("RRM_" + $prfx + $core + "_Hip") ("RRM_" + $prfx + $core + "_Ankle");
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			select -add ("RRM_" + $prfx + $core + "_Knee");
		}
		else
		{
			select -add ("RRM_" + $prfx + $core + "_Knee1") ("RRM_" + $prfx + $core + "_Knee1");
		}
		//SET MULTIPLIER TO NOT MIRROR
		$multiplier = 1;
	}
	else
	{
		select ("RRM_" + $prfx + $core + "_Shoulder") ("RRM_" + $prfx + $core + "_Wrist");
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			select -add ("RRM_" + $prfx + $core + "_Elbow");
		}
		else
		{
			select -add ("RRM_" + $prfx + $core + "_Elbow1") ("RRM_" + $prfx + $core + "_Elbow1");
		}
	}
	$segments = `ls -sl`;
		
	float $middleLimbLength;

	if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")` && !`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
	{
		$elbow1Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$elbow2Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$upperLimbLength = `getAttr ($modCore + $elbow1 + "Jnt.translateX")`;
		$lowerLimbLength = `getAttr ($modCore + $wristDummy + ".translateX")`;
		$limbLength = (($upperLimbLength + $lowerLimbLength)/2);
	}
	else
	{
		$elbow1 = "_Elbow1";
		$elbow2 = "_Elbow2";
		if ($limbType == "leg")
		{
			$elbow1 = "_Knee1";
			$elbow2 = "_Knee2";
		}			
		$elbow1Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$elbow2Loc = `xform -q -ws -rp ($modCore + $elbow2 + "Jnt")`;
		$upperLimbLength = `getAttr ($modCore + $elbow1 + "Jnt.translateX")`;
		$middleLimbLength = `getAttr ($modCore + $elbow2 + "Jnt.translateX")`;
		$lowerLimbLength = `getAttr ($modCore + $wristDummy + ".translateX")`;
		$limbLength = (($upperLimbLength + $lowerLimbLength)/2);
	}
	
	//ADD CURVE ATTRIBUTES TO IK FK SWITCH
	addAttr -ln ($elbowType + "Curve")  -at double  -min 0 -max 1 -dv 0 ($modCore + "_SwitchCtrl");
	setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + $elbowType + "Curve");
	
	addAttr -ln "curve"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_SwitchCtrl");
	setAttr -e-keyable 1 ($modCore + "_SwitchCtrl.curve");
	
	shadingNode -asUtility multiplyDivide -n ($modCore + "_Curve_MD1");
	connectAttr -force ($modCore + "_SwitchCtrl.curve") ($modCore + "_Curve_MD1.input1X");
	setAttr ($modCore + "_Curve_MD1.input2X") 2;
	shadingNode -asUtility multiplyDivide -n ($modCore + "_Curve_MD2");
	connectAttr -force ($modCore + "_Curve_MD1.outputX") ($modCore + "_Curve_MD2.input1X");
	connectAttr -force ($modCore + $shoulder + "FKCtrl.scaleX") ($modCore + "_Curve_MD2.input2X");
	
	//ADD VISIBILITY ATTRIBUTES FOR CURVE CONTROLLERS
	addAttr -ln ($limbType + "Twist")  -at bool  -min 0 ($modCore + "_SwitchCtrl");
	setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + $limbType + "Twist");

	addAttr -ln ($limbType + "CurveMacro")  -at bool  -min 0 ($modCore + "_SwitchCtrl");
	setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + $limbType + "CurveMacro");
	
	addAttr -ln ($limbType + "CurveMicro")  -at bool  -min 0 ($modCore + "_SwitchCtrl");
	setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + $limbType + "CurveMicro");

	
	//GROUP FOR NODES
	group -em -n ($modCore + "_curveNodesGrp");
	parent ($modCore + "_curveNodesGrp") ($modCore + "_ScaleGrp");
	group -em -n ($modCore + "_extraCurveNodesGrp");
	setAttr ($modCore + "_extraCurveNodesGrp.inheritsTransform") 0; 
	parent ($modCore + "_extraCurveNodesGrp") ($modCore + "Grp");
	
	
	while ($segInteger < `size $segments` || $segInteger <= 3)
	{
		//UPPER
		$seg = "_Upper";
		$segStart = $shoulder;
		$segEnd = $elbow1;
		$startPos = `xform -q -ws -rp ($modCore + $segStart + "Jnt")`;
		$endPos = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		string $segParentStartOrient = ($modCore + $clavicle + "Jnt");
		if ($limbType == "leg")
		{
			$segParentStartOrient = $modAttachNode;
		}
		string $segEndOrient = ($modCore + $elbow1 + "Jnt");
		
		string $topSegPosAttach = ($modCore + $shoulder + "Jnt");
		string $topSegRotAttach = ($modCore + $parentNode);
		string $btmSegPosAttach = ($modCore + $elbow1 + "_CurveCtrl");
		string $btmSegRotAttach = ($modCore + $elbow1 + "_CurveCtrl");
		string $ikSplineUpObject2 = ($modCore + $shoulder + "Jnt");
		string $segStartUpOrientControl = ($modCore + $seg + "_TwistCtrl");
		string $segEndUpOrientControl = ($modCore + $elbow1 + "_CurveCtrl");
		
		if ($segInteger == 2)
		{//LOWER
			$seg = "_Lower";
			$segStart = $elbow2;
			$segEnd = $wrist;
			$startPos = `xform -q -ws -rp ($modCore + $elbow2 + "Jnt")`;
			$endPos = `xform -q -ws -rp ($modCore + $wrist + "Jnt")`;
			$segParentStartOrient = ($modCore + $elbow2 + "Jnt");
			$segEndOrient = ($modCore + $wrist + "Jnt");

			$topSegPosAttach = ($modCore + $elbow2 + "_CurveCtrl");
			$topSegRotAttach = ($modCore + $elbow2 + "_CurveCtrl");
			$btmSegPosAttach = ($modCore + $wrist + "Jnt");
			$btmSegRotAttach = ($modCore + $wrist + "Jnt");
			$ikSplineUpObject2 = ($modCore + $wrist + "JntGrp1");
			if ($limbType == "leg")
			{
				$ikSplineUpObject2 = ($modCore + $wrist + "Jnt");
			}
			$segStartUpOrientControl = ($modCore + $elbow2 + "_CurveCtrl");
			$segEndUpOrientControl = ($modCore + $seg + "_TwistCtrl");
		}
		else if ($segInteger == 3)
		{//MIDDLE
			$seg = "_Middle";
			$segStart = $elbow1;
			$segEnd = $elbow2;
			$startPos = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
			$endPos = `xform -q -ws -rp ($modCore + $elbow2 + "Jnt")`;
			$segParentStartOrient = ($modCore + $elbow1 + "Jnt");
			$segEndOrient = ($modCore + $elbow2 + "Jnt");

			$topSegPosAttach = ($modCore + $elbow1 + "_CurveCtrl");
			$topSegRotAttach = ($modCore + $elbow1 + "_CurveCtrl");
			$btmSegPosAttach = ($modCore + $elbow2 + "_CurveCtrl");
			$btmSegRotAttach = ($modCore + $elbow2 + "_CurveCtrl");
			$ikSplineUpObject2 = ($modCore + $elbow2 + "_CurveCtrl");
			$segStartUpOrientControl = ($modCore + $elbow1 + "_CurveCtrl");
			$segEndUpOrientControl = ($modCore + $elbow2 + "_CurveCtrl");
		}
		
		float $segLength;
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			if ($segInteger != 2)
			{
				$segLength = `getAttr ($modCore + $segEnd + "Jnt.tx")`;
			}
			else
			{
				$segLength = `getAttr ($modCore + $wristDummy + ".tx")`;
			}
		}
		else
		{
			$elbow1TX = `getAttr ($modCore + $elbow1 + "Jnt.tx")`;
			$elbow2TX = `getAttr ($modCore + $elbow2 + "Jnt.tx")`;
			$segLength = (($elbow1TX + $elbow2TX)*.667);
		}

		// SEGMENTS CHECK
		if (`objExists ("RRM_" + $prfx + $core + $seg + "1")`)
		{
			//CREATE MAIN SPLINE CURVES FOR CONTROL GROUP ATTACHMENT
			curve -n ($modCore + $seg + "CurveAttach") -d 1 -p $startPos[0] $startPos[1] $startPos[2]
			-p $endPos[0] $endPos[1] $endPos[2] -k 0 -k 1;
			rename `listRelatives -c ($modCore + $seg + "CurveAttach")` ($modCore + $seg + "CurveShape");
	
			rebuildCurve -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 ($modCore + $seg + "CurveAttach");
				
			//CREATE GUIDE SPLINE CURVES FOR MACRO CONTROL ATTACHMENT
			curve -n ($modCore + $seg + "CurveGuide") -d 1 -p $startPos[0] $startPos[1] $startPos[2]
			-p $endPos[0] $endPos[1] $endPos[2] -k 0 -k 1 ;
			pickWalk -d down;
			rename `listRelatives -c ($modCore + $seg + "CurveGuide")` ($modCore + $seg + "CurveGuideShape");
			
			rebuildCurve -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 1 ($modCore + $seg + "CurveGuide");
			delete -ch ($modCore + $seg + "CurveAttach") ($modCore + $seg + "CurveGuide");
			
			parent ($modCore + $seg + "CurveAttach") ($modCore + $seg + "CurveGuide") ($modCore + "_extraCurveNodesGrp");
			setAttr ($modCore + $seg + "CurveAttach.template") 1;
			setAttr ($modCore + $seg + "CurveGuide.v") 0;
			
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.tx");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.ty");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.tz");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.rx");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.ry");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.rz");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.sx");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.sy");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.sz");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.v");
				
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveGuide.tx");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveGuide.ty");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveGuide.tz");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveGuide.rx");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveGuide.ry");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveGuide.rz");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveGuide.sx");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveGuide.sy");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveGuide.sz");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveGuide.v");

			addAttr -ln "nonControl"  -dt "string" ($modCore + $seg + "CurveGuide");
			setAttr -e-keyable 1 ($modCore + $seg + "CurveGuide.nonControl");
			setAttr -lock 1 ($modCore + $seg + "CurveGuide.nonControl");

			addAttr -ln "nonControl"  -dt "string" ($modCore + $seg + "CurveAttach");
			setAttr -e-keyable 1 ($modCore + $seg + "CurveAttach.nonControl");
			setAttr -lock 1 ($modCore + $seg + "CurveAttach.nonControl");

			//HIDE SHOULDER AND ELBOW JOINTS SO THEY DON'T GET CONFUSED WITH THE TOON JOINTS
			//DETERMINE VERSION NUMBER
			$versionNum = `getApplicationVersionAsFloat`;
			if ($versionNum >= 2011)
			{
				setAttr ($modCore + $segStart + "Jnt.drawStyle") 2;
				if ($segInteger != 2)
				{
					setAttr ($modCore + $segEnd + "Jnt.drawStyle") 2;
				}
			}
			else
			{
				setAttr ($modCore + $segStart + "Jnt.visibility") 0;
				if ($segInteger != 2)
				{
					setAttr ($modCore + $segEnd + "Jnt.visibility") 0;
				}				
			}
			curve -n ($modCore + $seg + "_CurveCtrl") -d 1 -p 0 0.4 0.4 -p 0 0.4 -0.4 -p 0 -0.4 -0.4 -p 0 -0.4 0.4 -p 0 0.4 0.4 -k 0 -k 1 -k 2 -k 3 -k 4 ;
			setAttr ($modCore + $seg + "_CurveCtrl.rotateOrder") 1;
			rename `listRelatives -c ($modCore + $seg + "_CurveCtrl")` ($modCore + $seg + "_CurveCtrlShape");
			
			setAttr (($modCore + $seg + "_CurveCtrl.scale"), ($limbLength*.75), ($limbLength*.75), ($limbLength*.75));
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + $seg + "_CurveCtrl");
			connectAttr -f ($modCore + "_SwitchCtrl." + $limbType + "CurveMacro") ($modCore + $seg + "_CurveCtrl.v");
			
			group -n ($modCore + $seg + "_CurveCtrlGrp") ($modCore + $seg + "_CurveCtrl");
			setAttr ($modCore + $seg + "_CurveCtrlGrp.rotateOrder") 1;
			pathAnimation -n ($modCore + $seg + "Guide_MP") -fractionMode true -followAxis x -upAxis y -worldUpType "objectrotation"
			-worldUpVector 0 1 0 -inverseFront $inverseFront -worldUpObject ($modCore + $segStart + "Jnt") ($modCore + $seg + "_CurveCtrlGrp") ($modCore + $seg + "CurveGuide");
			cutKey -cl -t ":" -f ":" -at "u" ($modCore + $seg + "Guide_MP");
			setAttr ($modCore + $seg + "Guide_MP.uValue") (.5 * $uValComp);
			
			connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + $seg + "_CurveCtrlGrp.scale");
			parent ($modCore + $seg + "_CurveCtrlGrp") ($modCore + "_extraCurveNodesGrp");
			
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "_CurveCtrl.rx");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "_CurveCtrl.ry");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "_CurveCtrl.rz");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "_CurveCtrl.v");

	
			
			if (($segInteger == 1) || ($segInteger == 3 && !`objExists ($modCore + $segEnd + "_CurveCtrl")`))
			{//ELBOW1 CONTROL
				curve -n ($modCore + $segEnd + "_CurveCtrl") -d 1 -p 0 0.4 0.4 -p 0 0.4 -0.4 -p 0 -0.4 -0.4 -p 0 -0.4 0.4 -p 0 0.4 0.4 -k 0 -k 1 -k 2 -k 3 -k 4 ;
				setAttr ($modCore + $segEnd + "_CurveCtrl.rotateOrder") 1;
				rename `listRelatives -c ($modCore + $segEnd + "_CurveCtrl")` ($modCore + $segEnd + "_CurveCtrlShape");
				setAttr (($modCore + $segEnd + "_CurveCtrl.scale"), ($limbLength/1), ($limbLength/1), ($limbLength/1));
				makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + $segEnd + "_CurveCtrl");
	
				group -n ($modCore + $segEnd + "_CurveCtrlGrp") ($modCore + $segEnd + "_CurveCtrl");
				parent ($modCore + $segEnd + "_CurveCtrlGrp") ($modCore + "_curveNodesGrp");
				pointConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_CurveCtrlGrp");
				delete `orientConstraint ($modCore + $segStart + "Jnt") ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_CurveCtrlGrp")`;
				orientConstraint -mo ($modCore + $segStart + "Jnt") ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_CurveCtrlGrp");
				setAttr ($modCore + $segEnd + "_CurveCtrlGrp_orientConstraint1.interpType") 2;
				
				connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + $segEnd + "_CurveCtrlGrp.scale");
				parent ($modCore + $segEnd + "_CurveCtrlGrp") ($modCore + "_extraCurveNodesGrp");
				
				connectAttr -f ($modCore + "_SwitchCtrl." + $elbowType + "Curve") ($modCore + $segEnd + "_CurveCtrlGrp_orientConstraint1." + $modCore + $segStart + "JntW0");

				connectAttr -f ($modCore + "_SwitchCtrl." + $limbType + "CurveMacro") ($modCore + $segEnd + "_CurveCtrl.v");				
				setAttr -lock 1 -keyable 0 ($modCore + $segEnd + "_CurveCtrl.v");
			}//ELBOW1 CONTROL
			
			if (($segInteger == 2 && $elbow2 == "_Elbow2") || ($segInteger != 1 && !`objExists ($modCore + $segStart + "_CurveCtrl")`))
			{//ELBOW2 CONTROL
				curve -n ($modCore + $segStart + "_CurveCtrl") -d 1 -p 0 0.4 0.4 -p 0 0.4 -0.4 -p 0 -0.4 -0.4 -p 0 -0.4 0.4 -p 0 0.4 0.4 -k 0 -k 1 -k 2 -k 3 -k 4 ;
				setAttr ($modCore + $segStart + "_CurveCtrl.rotateOrder") 1;
				rename `listRelatives -c ($modCore + $segStart + "_CurveCtrl")` ($modCore + $segStart + "_CurveCtrlShape");
				setAttr (($modCore + $segStart + "_CurveCtrl.scale"), ($limbLength/1), ($limbLength/1), ($limbLength/1));
				makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + $segStart + "_CurveCtrl");
	
				group -n ($modCore + $segStart + "_CurveCtrlGrp") ($modCore + $segStart + "_CurveCtrl");
				parent ($modCore + $segStart + "_CurveCtrlGrp") ($modCore + "_curveNodesGrp");
				pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_CurveCtrlGrp");
				delete `orientConstraint ($modCore + $elbow1 + "Jnt") ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_CurveCtrlGrp")`;
				orientConstraint -mo ($modCore + $elbow1 + "Jnt") ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_CurveCtrlGrp");
				setAttr ($modCore + $segStart + "_CurveCtrlGrp_orientConstraint1.interpType") 2;
				
				connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + $segStart + "_CurveCtrlGrp.scale");
				parent ($modCore + $segStart + "_CurveCtrlGrp") ($modCore + "_extraCurveNodesGrp");

				connectAttr -f ($modCore + "_SwitchCtrl." + $elbowType + "Curve") ($modCore + $segStart + "_CurveCtrlGrp_orientConstraint1." + $modCore + $elbow1 + "JntW0");
				connectAttr -f ($modCore + "_SwitchCtrl." + $limbType + "CurveMacro") ($modCore + $segStart + "_CurveCtrl.v");				
				setAttr -lock 1 -keyable 0 ($modCore + $segStart + "_CurveCtrl.v");
			}//ELBOW2 CONTROL
				
			//CURVE CLUSTERS
			select ($modCore + $seg + "CurveAttach.cv[0:1]") ;
			newCluster " -envelope 1";
			rename ($modCore + $seg + "TopClstr");
			group -em -n ($modCore + $seg + "TopClstrGrp");
			delete `pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + "TopClstrGrp")`;
			parent ($modCore + $seg + "TopClstrGrp") ($modCore + $segStart + "Jnt");
			makeIdentity -apply false -r 1 ($modCore + $seg + "TopClstrGrp");
			parent -w ($modCore + $seg + "TopClstrGrp");
			parent ($modCore + $seg + "TopClstr") ($modCore + $seg + "TopClstrGrp");
	
			pointConstraint -mo  $topSegPosAttach ($modCore + $seg + "TopClstrGrp");
			orientConstraint -mo $topSegRotAttach ($modCore + $seg + "TopClstrGrp");
			
			select ($modCore + $seg + "CurveAttach.cv[3:4]") ;
			newCluster " -envelope 1";
			rename ($modCore + $seg + "BtmClstr");
			group -em -n ($modCore + $seg + "BtmClstrGrp");
			delete `pointConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + "BtmClstrGrp")`;
			parent ($modCore + $seg + "BtmClstrGrp") ($modCore + $segStart + "Jnt");
			makeIdentity -apply false -r 1 ($modCore + $seg + "BtmClstrGrp");
			parent -w ($modCore + $seg + "BtmClstrGrp");
			parent ($modCore + $seg + "BtmClstr") ($modCore + $seg + "BtmClstrGrp");
				
			delete `orientConstraint $segEndOrient ($modCore + $seg + "BtmClstrGrp")`;

			pointConstraint -mo  $btmSegPosAttach ($modCore + $seg + "BtmClstrGrp");
			orientConstraint -mo $btmSegRotAttach ($modCore + $seg + "BtmClstrGrp");
			
			select ($modCore + $seg + "CurveAttach.cv[2]") ;
			newCluster " -envelope 1";
			rename ($modCore + $seg + "MidClstr");
			
			//parentConstraint ($modCore + $seg + "_CurveCtrl") ($modCore + $seg + "MidClstr");
			//parent ($modCore + $seg + "MidClstr") ($modCore + "_extraCurveNodesGrp");
			parent ($modCore + $seg + "MidClstr") ($modCore + $seg + "_CurveCtrl");
			setAttr ($modCore + $seg + "MidClstr.v") 0;
	
			//GUIDE CURVE CLUSTERS
			select ($modCore + $seg + "CurveGuide.cv[0:1]") ;
			newCluster " -envelope 1";
			rename ($modCore + $seg + "TopGuideClstr");
			group -em -n ($modCore + $seg + "TopGuideClstrGrp");
			delete `pointConstraint ($modCore + $segStart + "FKCtrl") ($modCore + $seg + "TopGuideClstrGrp")`;
			parent ($modCore + $seg + "TopGuideClstrGrp") ($modCore + $segStart + "Jnt");
			makeIdentity -apply false -r 1 ($modCore + $seg + "TopGuideClstrGrp");
			parent -w ($modCore + $seg + "TopGuideClstrGrp");
			parent ($modCore + $seg + "TopGuideClstr") ($modCore + $seg + "TopGuideClstrGrp"); 
			
			pointConstraint -mo  $topSegPosAttach ($modCore + $seg + "TopGuideClstrGrp");
			orientConstraint -mo $topSegRotAttach ($modCore + $seg + "TopGuideClstrGrp");
	
			select ($modCore + $seg + "CurveGuide.cv[2:3]") ;
			newCluster " -envelope 1";
			rename ($modCore + $seg + "BtmGuideClstr");
			group -em -n ($modCore + $seg + "BtmGuideClstrGrp");
			delete `pointConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + "BtmGuideClstrGrp")`;
			parent ($modCore + $seg + "BtmGuideClstrGrp") ($modCore + $segStart + "Jnt");
			makeIdentity -apply false -r 1 ($modCore + $seg + "BtmGuideClstrGrp");
			parent -w ($modCore + $seg + "BtmGuideClstrGrp");
			parent ($modCore + $seg + "BtmGuideClstr") ($modCore + $seg + "BtmGuideClstrGrp");
	
			delete `orientConstraint $segEndOrient ($modCore + $seg + "BtmGuideClstrGrp")`;
			
			pointConstraint -mo  $btmSegPosAttach ($modCore + $seg + "BtmGuideClstrGrp");
			orientConstraint -mo $btmSegRotAttach ($modCore + $seg + "BtmGuideClstrGrp");
	
			//CONNECT SCALE TO OF THE CLUSTER GROUPS TO CURVE ATTRIBUTE TO MAKE THE ARM CURVES STRAIGHT	
			connectAttr -f ($modCore + "_Curve_MD2.outputX") ($modCore + $seg + "TopClstrGrp.scaleX");
			connectAttr -f ($modCore + "_Curve_MD2.outputX") ($modCore + $seg + "BtmClstrGrp.scaleX");
			connectAttr -f ($modCore + "_Curve_MD2.outputX") ($modCore + $seg + "TopGuideClstrGrp.scaleX");
			connectAttr -f ($modCore + "_Curve_MD2.outputX") ($modCore + $seg + "BtmGuideClstrGrp.scaleX");
			
			//PARENT CLUSTERS
			parent ($modCore + $seg + "TopClstrGrp") ($modCore + $seg + "BtmClstrGrp")
			($modCore + $seg + "TopGuideClstrGrp") ($modCore + $seg + "BtmGuideClstrGrp")
			($modCore + "_curveNodesGrp");
			
			//HIDE CLUSTERS
			setAttr ($modCore + $seg + "TopClstrGrp.v") 0;
			setAttr ($modCore + $seg + "BtmClstrGrp.v") 0;
			setAttr ($modCore + $seg + "TopGuideClstrGrp.v") 0;
			setAttr ($modCore + $seg + "BtmGuideClstrGrp.v") 0;
			
			//CREATE NON-FLIP JOINT CHAIN
			select -cl;
			joint -n ($modCore + $seg + $segStart + "_NoRollJnt");
			joint -n ($modCore + $seg + $segEnd + "_NoRollJnt") -p $segLength 0 0;
			setAttr ($modCore + $seg + $segStart + "_NoRollJnt.v") 0;
			setAttr ($modCore + $seg + $segEnd + "_NoRollJnt.v") 0;
			group -n ($modCore + $seg + $segStart + "_NoRollJntGrp") ($modCore + $seg + $segStart + "_NoRollJnt"); 
			delete `pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_NoRollJntGrp")`;
			delete `parentConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_NoRollJnt")`;
			makeIdentity -apply true -r 1 ($modCore + $seg + $segStart + "_NoRollJnt");
			parentConstraint -mo $segParentStartOrient ($modCore + $seg + $segStart + "_NoRollJntGrp");
			pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_NoRollJnt");
			select -cl;
			
			setAttr (($modCore + $seg + $segEnd + "_NoRollJnt.rotate"), 0, 0, 0);
			setAttr (($modCore + $seg + $segEnd + "_NoRollJnt.jointOrient"), 0, 0, 0);
			$segNoFlipLength = `getAttr ($modCore + $seg + $segEnd + "_NoRollJnt.translateX")`;
			
			//CREATE IK RP HANDLE
			select ($modCore + $seg + $segStart + "_NoRollJnt.rotatePivot") ($modCore + $seg + $segEnd + "_NoRollJnt.rotatePivot") ;
			ikHandle -n ($modCore + $seg + $segStart + "_NoRollIKHandle") -sol ikRPsolver;
			setAttr (($modCore + $seg + $segStart + "_NoRollIKHandle.poleVector"), 0, 0, 0);
			parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + $segStart + "_NoRollIKHandle");
			
			parent ($modCore + $seg + $segStart + "_NoRollJntGrp") ($modCore + $seg + $segStart + "_NoRollIKHandle") ($modCore + "_curveNodesGrp");
			setAttr ($modCore + $seg + $segStart + "_NoRollIKHandle.v") 0;

			//CREATE TWIST JOINT CHAIN
			select -cl;
			joint -n ($modCore + $seg + $segStart + "_TwistStartJnt");
			setAttr ($modCore + $seg + $segStart + "_TwistStartJnt.v") 0;
			delete `parentConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistStartJnt")`;
			if ($prfx == "r_" && $limbType == "arm")
			{
				rotate -r -os 0 180 0 ($modCore + $seg + $segStart + "_TwistStartJnt");
			}
			pointConstraint -mo ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistStartJnt");
			select -cl;
			
			joint -n ($modCore + $seg + $segStart + "_TwistEndJnt") -p $endPos[0] $endPos[1] $endPos[2];
			setAttr ($modCore + $seg + $segStart + "_TwistEndJnt.v") 0;
			parent ($modCore + $seg + $segStart + "_TwistEndJnt") ($modCore + $seg + $segStart + "_TwistStartJnt");
			setAttr (($modCore + $seg + $segStart + "_TwistEndJnt.jointOrient"), 0, 0, 0);
			$segNoFlipLength = `getAttr ($modCore + $seg + $segStart + "_TwistEndJnt.translateX")`;
			
			group -em -n ($modCore + $seg + $segStart + "_TwistJointsGrp");
			delete `pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistJointsGrp")`;
			makeIdentity -apply true -t 1 ($modCore + $seg + $segStart + "_TwistJointsGrp");
			parentConstraint -mo ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistJointsGrp");
			parent ($modCore + $seg + $segStart + "_TwistStartJnt") ($modCore + $seg + $segStart + "_TwistJointsGrp");
			
			parent ($modCore + $seg + $segStart + "_TwistJointsGrp") ($modCore + "_curveNodesGrp");
			
			
			//CREATE NON-FLIP SETUP FOR WRIST/ANKLE TWIST CTRL
			if ($segInteger == 2)
			{
				//ROLL JOINT CHAIN
				select -cl;
				joint -n ($modCore + $segEnd + "_RollBtmStartJnt");
				setAttr ($modCore + $segEnd + "_RollBtmStartJnt.v") 0;
				group -n ($modCore + $segEnd + "_RollBtmStartJntGrp"); 
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_RollBtmStartJntGrp")`;

				parent ($modCore + $segEnd + "_RollBtmStartJntGrp") ($modCore + $segEnd + "Jnt");
				
				select -cl;
				joint -n ($modCore + $segEnd + "_RollBtmEndJnt"); //-p $endPos[0] $endPos[1] $endPos[2];
				setAttr ($modCore + $segEnd + "_RollBtmEndJnt.v") 0;
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_RollBtmEndJnt")`;
				setAttr (($modCore + $segEnd + "_RollBtmEndJnt.translate"), 2, 0, 0);
				parent ($modCore + $segEnd + "_RollBtmEndJnt") ($modCore + $segEnd + "_RollBtmStartJnt");
				setAttr (($modCore + $segEnd + "_RollBtmEndJnt.jointOrient"), 0, 0, 0);
				setAttr (($modCore + $segEnd + "_RollBtmEndJnt.translate"), 2, 0, 0);				
				
				
				//NO ROLL SINGLE CHAIN RP
				select -cl;
				joint -n ($modCore + $segEnd + "_NoRollBtmStartJnt");
				setAttr ($modCore + $segEnd + "_NoRollBtmStartJnt.v") 0;
				group -n ($modCore + $segEnd + "_NoRollBtmStartJntGrp"); 
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_NoRollBtmStartJntGrp")`;
				
				select -cl;
				joint -n ($modCore + $segEnd + "_NoRollBtmEndJnt"); //-p $endPos[0] $endPos[1] $endPos[2];
				setAttr ($modCore + $segEnd + "_NoRollBtmEndJnt.v") 0;
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_NoRollBtmEndJnt")`;
				setAttr (($modCore + $segEnd + "_NoRollBtmEndJnt.translate"), 2, 0, 0);
				parent ($modCore + $segEnd + "_NoRollBtmEndJnt") ($modCore + $segEnd + "_NoRollBtmStartJnt");
				setAttr (($modCore + $segEnd + "_NoRollBtmEndJnt.jointOrient"), 0, 0, 0);
				setAttr (($modCore + $segEnd + "_NoRollBtmEndJnt.translate"), 2, 0, 0);
				
				//CREATE IK RP HANDLE
				select ($modCore + $segEnd + "_NoRollBtmStartJnt.rotatePivot") ($modCore + $segEnd + "_NoRollBtmEndJnt.rotatePivot") ;
				ikHandle -n ($modCore + $segEnd + "_NoRollBtmIKHandle") -sol ikRPsolver;
				setAttr (($modCore + $segEnd + "_NoRollBtmIKHandle.poleVector"), 0, 0, 0);
				parent ($modCore + $segEnd + "_NoRollBtmIKHandle") ($modCore + $segEnd + "_RollBtmEndJnt");
				//parentConstraint -mo ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_NoRollBtmIKHandle");
				
				//parent ($modCore + $segEnd + "_NoRollBtmStartJntGrp") /*($modCore + $seg + $segStart + "_NoRollIKHandle")*/ ($modCore + $seg + "_TwistCtrlGrp");
				parent ($modCore + $seg + $segStart + "_NoRollIKHandle") ($modCore + $segEnd + "_RollBtmStartJntGrp");
				
				//SPLINE JOINT CHAIN
				select -cl;
				joint -n ($modCore + $segEnd + "_SplineIKBtmStartJnt");
				group -n ($modCore + $segEnd + "_SplineIKBtmStartJntGrp");
				parent ($modCore + $segEnd + "_SplineIKBtmStartJntGrp") ($modCore + "_ScaleGrp");
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_SplineIKBtmStartJntGrp")`;

				parentConstraint -mo ($modCore + $segEnd + "JntDummy") ($modCore + $segEnd + "_SplineIKBtmStartJntGrp");

				select -cl;
				
				joint -n ($modCore + $segEnd + "_SplineIKBtmRollValJnt"); //-p $endPos[0] $endPos[1] $endPos[2];
				setAttr ($modCore + $segEnd + "_SplineIKBtmRollValJnt.v") 0;
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_SplineIKBtmRollValJnt")`;
				parent ($modCore + $segEnd + "_SplineIKBtmRollValJnt") ($modCore + $segEnd + "_SplineIKBtmStartJnt");
				setAttr (($modCore + $segEnd + "_SplineIKBtmRollValJnt.jointOrient"), 0, 0, 0);
				setAttr (($modCore + $segEnd + "_SplineIKBtmRollValJnt.rotate"), 0, 0, 0);
				setAttr (($modCore + $segEnd + "_SplineIKBtmRollValJnt.translate"), (1), 0, 0);
				
				select -cl;
				joint -n ($modCore + $segEnd + "_SplineIKBtmEndJnt"); //-p $endPos[0] $endPos[1] $endPos[2];
				setAttr ($modCore + $segEnd + "_SplineIKBtmEndJnt.v") 0; //-p $endPos[0] $endPos[1] $endPos[2];
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_SplineIKBtmEndJnt")`;
				parent ($modCore + $segEnd + "_SplineIKBtmEndJnt") ($modCore + $segEnd + "_SplineIKBtmRollValJnt");
				setAttr (($modCore + $segEnd + "_SplineIKBtmEndJnt.jointOrient"), 0, 0, 0);
				setAttr (($modCore + $segEnd + "_SplineIKBtmEndJnt.translate"), (1), 0, 0);
				
				//CREATE SPLINE IK HANDLE
				select ($modCore + $segEnd + "_SplineIKBtmStartJnt.rotatePivot") ($modCore + $segEnd + "_SplineIKBtmEndJnt.rotatePivot");
				ikHandle -n  ($modCore + $segEnd + "_SplineIKBtmIKHandle") -sol ikSplineSolver;
				$splineIKCurve = `listConnections -s 1 -d 0 -type "nurbsCurve" ($modCore + $segEnd + "_SplineIKBtmIKHandle")`;
				rename $splineIKCurve ($modCore + $segEnd + "_SplineIKBtmIKCurve");
					
				setAttr ($modCore + $segEnd + "_SplineIKBtmIKHandle.dTwistControlEnable") 1;
				setAttr ($modCore + $segEnd + "_SplineIKBtmIKHandle.dWorldUpType") 4;
				setAttr ($modCore + $segEnd + "_SplineIKBtmIKHandle.dWorldUpAxis") 3;
				setAttr (($modCore + $segEnd + "_SplineIKBtmIKHandle.dWorldUpVector"), 0, 0, 1);
				setAttr (($modCore + $segEnd + "_SplineIKBtmIKHandle.dWorldUpVectorEnd"), 0, 0, 1);
				
				//FIRST ROTATION LOCATOR
				spaceLocator -n ($modCore + $segEnd + "_SplineIKUpLctr1");
				parent ($modCore + $segEnd + "_SplineIKUpLctr1") ($modCore + "_ScaleGrp");
				setAttr ($modCore + $segEnd + "_SplineIKUpLctr1.inheritsTransform") 0;
				parentConstraint ($modCore + $segEnd + "_NoRollBtmStartJnt") ($modCore + $segEnd + "_SplineIKUpLctr1");
				setAttr ($modCore + $segEnd + "_SplineIKUpLctr1_parentConstraint1.interpType") 2;

				//SECOND ROTATION LOCATOR
				spaceLocator -n ($modCore + $segEnd + "_SplineIKUpLctr2");
				parent ($modCore + $segEnd + "_SplineIKUpLctr2") ($modCore + "_ScaleGrp");
				setAttr ($modCore + $segEnd + "_SplineIKUpLctr2.inheritsTransform") 0;
				parentConstraint ($modCore + $segEnd + "_RollBtmStartJnt") ($modCore + $segEnd + "_SplineIKUpLctr2");
				setAttr ($modCore + $segEnd + "_SplineIKUpLctr2_parentConstraint1.interpType") 2;

				connectAttr -f ($modCore + $segEnd + "_SplineIKUpLctr1.xformMatrix") ($modCore + $segEnd + "_SplineIKBtmIKHandle.dWorldUpMatrix");
				connectAttr -f ($modCore + $segEnd + "_SplineIKUpLctr2.xformMatrix") ($modCore + $segEnd + "_SplineIKBtmIKHandle.dWorldUpMatrixEnd");

				parent ($modCore + $segEnd + "_SplineIKBtmIKHandle") ($modCore + $segEnd + "_NoRollBtmStartJntGrp");
				parent ($modCore + $segEnd + "_SplineIKBtmIKCurve") ($modCore + $segEnd + "_RollBtmStartJntGrp");

				//HIDE AND LOCK ATTRIBUTES
				setAttr ($modCore + $segEnd + "_NoRollBtmStartJnt.v") 0;
				setAttr ($modCore + $segEnd + "_RollBtmStartJnt.v") 0;
				setAttr ($modCore + $segEnd + "_NoRollBtmIKHandle.v") 0;
				setAttr ($modCore + $segEnd + "_SplineIKBtmStartJnt.visibility") 0;
				setAttr ($modCore + $segEnd + "_SplineIKUpLctr1.visibility") 0;
				setAttr ($modCore + $segEnd + "_SplineIKUpLctr2.visibility") 0;
				setAttr ($modCore + $segEnd + "_SplineIKBtmIKHandle.visibility") 0;
				setAttr ($modCore + $segEnd + "_SplineIKBtmIKCurve.visibility") 0;
			}
	
	
			//////////////////////////////////////////////////////////////////////////////
			////////////////////////////CREATE ARM ROLL JOINTS////////////////////////////////
			//////////////////////////////////////////////////////////////////////////////
		
			$rollProxies = `ls ("RRM_" + $prfx + $core + $seg + "?")`;
			$sizeRollProxies = `size $rollProxies`;
			int $rpNum = 1;
			for ($eachRP in $rollProxies)
			{//CREATE TWIST JOINTS
				$rpNumRev = (($sizeRollProxies + 1) - $rpNum);
				
				//EXTRA TWIST JOINTS
				float $rpNumFloat = $rpNum;
				float $sizeRollProxiesFloat = $sizeRollProxies;
				
				duplicate -n ($modCore + $seg + $segStart + "_TwistJnt" + $rpNum) ($modCore + $seg + $segStart + "_TwistEndJnt");
				float $noFlipSpacing = ($segNoFlipLength /($sizeRollProxiesFloat + 1));
				setAttr ($modCore + $seg + $segStart + "_TwistJnt" + $rpNum + ".translateX") $noFlipSpacing;
				parent ($modCore + $seg + $segStart + "_TwistEndJnt") ($modCore + $seg + $segStart + "_TwistJnt" + $rpNum);
				
				if ($rpNum == $sizeRollProxies)
				{
					//ADD TWIST
					//CREATE TWIST CONTROLS
					if ($segInteger == 1)
					{
						circle -n ($modCore + $seg + "_TwistCtrl") -nr 0 1 0 -sw 45 -r 0.8 -ch 0;
						rotate -r 0 -22.5 0 ($modCore + $seg + "_TwistCtrl");
						makeIdentity -apply true -r 1 ($modCore + $seg + "_TwistCtrl");
						curve -n ($modCore + $seg + $segStart + "_WedgeCtrl") -d 1 -p -0.306147 0 -0.739104 -p 0 0 -0.432436 -p 0.306147 0 -0.739104 -k 0 -k 1 -k 2 ;
						rename `listRelatives -c ($modCore + $seg + $segStart + "_WedgeCtrl")` ($modCore + $seg + $segStart + "_WedgeCtrlShape");
						curve -n ($modCore + $seg + $segStart + "_lineCtrl") -d 1 -p 0 0 -0.432436 -p 0 0 0 -k 0 -k 1 ;
						rename `listRelatives -c ($modCore + $seg + $segStart + "_lineCtrl")` ($modCore + $seg + $segStart + "_lineCtrlShape");
						parent -r -s ($modCore + $seg + $segStart + "_WedgeCtrlShape") ($modCore + $seg + $segStart + "_lineCtrlShape") ($modCore + $seg + "_TwistCtrl");
						delete ($modCore + $seg + $segStart + "_WedgeCtrl") ($modCore + $seg + $segStart + "_lineCtrl");
						setAttr (($modCore + $seg + "_TwistCtrl.rotate"), 0, -90, (90*$multiplier));
						setAttr (($modCore + $seg + "_TwistCtrl.scale"), ($limbLength/2), ($limbLength/2), ($limbLength/2));
						makeIdentity -apply true -r 1 -s 1 ($modCore + $seg + "_TwistCtrl");
						connectAttr -f ($modCore + "_SwitchCtrl." + $limbType + "Twist") ($modCore + $seg + "_TwistCtrl.v");				
						spaceLocator -n ($modCore + $seg + $segEnd + "_TwistLctr");
						group -n ($modCore + $seg + "_TwistCtrlGrp") ($modCore + $seg + "_TwistCtrl"); xform -os -piv 0 0 0;
						setAttr ($modCore + $seg + "_TwistCtrlGrp.rotateOrder") 1;
						group -n ($modCore + $seg + $segStart + "_TwistGrp") ($modCore + $seg + "_TwistCtrlGrp") ($modCore + $seg + $segEnd + "_TwistLctr"); xform -os -piv 0 0 0;
						
						parent ($modCore + $seg + $segStart + "_TwistGrp") ($modCore + "_curveNodesGrp");
						setAttr ($modCore + $seg + $segEnd + "_TwistLctr.v") 0;
						
						delete `parentConstraint ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistGrp")`;
						orientConstraint -mo ($modCore + $shoulder + $FKCtrlGrp) ($modCore + $seg + $segStart + "_TwistGrp");
						pointConstraint -mo ($modCore + $shoulder + "FKCtrl") ($modCore + $seg + $segStart + "_TwistGrp");
						orientConstraint -mo ($modCore + $seg + $segStart + "_NoRollJnt") ($modCore + $seg + "_TwistCtrlGrp");
						parentConstraint $ikSplineUpObject2 ($modCore + $seg + $segEnd + "_TwistLctr");
					}
					else if ($segInteger == 2)
					{
						circle -n ($modCore + $seg + "_TwistCtrl") -nr 0 1 0 -sw 45 -r 0.8 -ch 0;
						rotate -r 0 -22.5 0 ($modCore + $seg + "_TwistCtrl");
						makeIdentity -apply true -r 1 ($modCore + $seg + "_TwistCtrl");
						curve -n ($modCore + $seg + $segEnd + "_WedgeCtrl") -d 1 -p -0.306147 0 -0.739104 -p 0 0 -0.432436 -p 0.306147 0 -0.739104 -k 0 -k 1 -k 2 ;
						rename `listRelatives -c ($modCore + $seg + $segEnd + "_WedgeCtrl")` ($modCore + $seg + $segEnd + "_WedgeCtrlShape");
						curve -n ($modCore + $seg + $segEnd + "_lineCtrl") -d 1 -p 0 0 -0.432436 -p 0 0 0 -k 0 -k 1 ;
						rename `listRelatives -c ($modCore + $seg + $segEnd + "_lineCtrl")` ($modCore + $seg + $segEnd + "_lineCtrlShape");
						parent -r -s ($modCore + $seg + $segEnd + "_WedgeCtrlShape") ($modCore + $seg + $segEnd + "_lineCtrlShape") ($modCore + $seg + "_TwistCtrl");
						delete ($modCore + $seg + $segEnd + "_WedgeCtrl") ($modCore + $seg + $segEnd + "_lineCtrl");
						setAttr (($modCore + $seg + "_TwistCtrl.rotate"), 0, -90, (90*$multiplier));
						setAttr (($modCore + $seg + "_TwistCtrl.scale"), ($limbLength/2.5), ($limbLength/2.5), ($limbLength/2.5));
						makeIdentity -apply true -r 1 -s 1 ($modCore + $seg + "_TwistCtrl");
						connectAttr -f ($modCore + "_SwitchCtrl." + $limbType + "Twist") ($modCore + $seg + "_TwistCtrl.v");				
						spaceLocator -n ($modCore + $seg + $segEnd + "_TwistLctr");
						group -n ($modCore + $seg + "_TwistCtrlGrp") ($modCore + $seg + "_TwistCtrl"); xform -os -piv 0 0 0;
						setAttr ($modCore + $seg + "_TwistCtrlGrp.rotateOrder") 1;
						group -n ($modCore + $seg + $segEnd + "_TwistGrp") ($modCore + $seg + "_TwistCtrlGrp") ($modCore + $seg + $segEnd + "_TwistLctr"); xform -os -piv 0 0 0;
						
						parent ($modCore + $seg + $segEnd + "_TwistGrp") ($modCore + "_curveNodesGrp");
						setAttr ($modCore + $seg + $segEnd + "_TwistLctr.v") 0;
						
						delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + $segEnd + "_TwistGrp")`;
						pointConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + $segEnd + "_TwistGrp");
						parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z ($modCore + $segStart + "Jnt") ($modCore + $seg + $segEnd + "_TwistGrp");
						connectAttr -f ($modCore + $segEnd + "_SplineIKBtmRollValJnt.rotateX") ($modCore + $seg + "_TwistCtrlGrp.rotateX");
						parentConstraint $ikSplineUpObject2 ($modCore + $seg + $segEnd + "_TwistLctr");
					}
					
					if (`objExists ($modCore + $segEnd + "_NoRollBtmStartJntGrp")`)
					{
						parent ($modCore + $segEnd + "_NoRollBtmStartJntGrp") ($modCore + $segEnd + "_SplineIKBtmStartJntGrp") ($modCore + $seg + $segEnd + "_TwistGrp");
					}
					
					if ($limbType == "leg" && $crntSide == "right" && `objExists ($modCore + $seg + "_TwistCtrl")`)
					{
						rotate -r 180 0 0  ($modCore + $seg + "_TwistCtrl");
						makeIdentity -apply true -r 1 ($modCore + $seg + "_TwistCtrl");
					}
					if (`objExists ($modCore + $seg + "_TwistCtrl")`)
					{
						setAttr -lock 1 -keyable 0 ($modCore + $seg + "_TwistCtrl.tx");
						setAttr -lock 1 -keyable 0 ($modCore + $seg + "_TwistCtrl.ty");
						setAttr -lock 1 -keyable 0 ($modCore + $seg + "_TwistCtrl.tz");
						setAttr -lock 1 -keyable 0 ($modCore + $seg + "_TwistCtrl.sx");
						setAttr -lock 1 -keyable 0 ($modCore + $seg + "_TwistCtrl.sy");
						setAttr -lock 1 -keyable 0 ($modCore + $seg + "_TwistCtrl.sz");
						setAttr -lock 1 -keyable 0 ($modCore + $seg + "_TwistCtrl.v");
					}
					
					spaceLocator -n ($modCore + $seg + $segStart + "_TwistSplineIK_Up1Lctr");
					spaceLocator -n ($modCore + $seg + $segStart + "_TwistSplineIK_Up2Lctr");
					parentConstraint $segStartUpOrientControl ($modCore + $seg + $segStart + "_TwistSplineIK_Up1Lctr");
					parentConstraint $segEndUpOrientControl ($modCore + $seg + $segStart + "_TwistSplineIK_Up2Lctr");
					
					parent ($modCore + $seg + $segStart + "_TwistSplineIK_Up1Lctr") ($modCore + $seg + $segStart + "_TwistSplineIK_Up2Lctr") ($modCore + "Grp");
					setAttr ($modCore + $seg + $segStart + "_TwistSplineIK_Up1Lctr.v") 0;
					setAttr ($modCore + $seg + $segStart + "_TwistSplineIK_Up2Lctr.v") 0;
					
					
					//SPLINE SETUP/////
					//CREATE ONE EXTRA JOINT TO BETTER DISTRIBUTE THE ROLL
					duplicate -n ($modCore + $seg + $segStart + "_TwistJointExtraJnt") ($modCore + $seg + $segStart + "_TwistEndJnt");
					setAttr ($modCore + $seg + $segStart + "_TwistJointExtraJnt.v") 0;
					float $noFlipSpacing = ($segNoFlipLength /(($sizeRollProxiesFloat + 1)*2));
					setAttr ($modCore + $seg + $segStart + "_TwistJointExtraJnt" + ".translateX") $noFlipSpacing;
					parent ($modCore + $seg + $segStart + "_TwistEndJnt") ($modCore + $seg + $segStart + "_TwistJointExtraJnt");
					
					//SPLINE IK
					select ($modCore + $seg + $segStart + "_TwistStartJnt.rotatePivot") ($modCore + $seg + $segStart + "_TwistEndJnt.rotatePivot") ;
					ikHandle -n ($modCore + $seg + $segStart + "_TwistSplineIKHandle") -sol ikSplineSolver;
					$splineIKCurve = `listConnections -s 1 -d 0 -type "nurbsCurve" ($modCore + $seg + $segStart + "_TwistSplineIKHandle")`;
					rename $splineIKCurve ($modCore + $seg + $segStart + "_TwistSplineIKCurve");
					parentConstraint -mo ($modCore + $segStart + "Jnt") ($modCore + $seg + $segStart + "_TwistSplineIKCurve");
					
					parent ($modCore + $seg + $segStart + "_TwistSplineIKHandle") ($modCore + "_curveNodesGrp");
					setAttr ($modCore + $seg + $segStart + "_TwistSplineIKHandle.v") 0;
	
					setAttr ($modCore + $seg + $segStart + "_TwistSplineIKHandle.dTwistControlEnable") 1;
					setAttr ($modCore + $seg + $segStart + "_TwistSplineIKHandle.dWorldUpType")  4;
	
					connectAttr -f ($modCore + $seg + $segStart + "_TwistSplineIK_Up1Lctr.xformMatrix") ($modCore + $seg + $segStart + "_TwistSplineIKHandle.dWorldUpMatrix");
					connectAttr -f ($modCore + $seg + $segStart + "_TwistSplineIK_Up2Lctr.xformMatrix") ($modCore + $seg + $segStart + "_TwistSplineIKHandle.dWorldUpMatrixEnd");

					addAttr -ln "nonControl"  -dt "string" ($modCore + $seg + $segStart + "_TwistSplineIKCurve");
					setAttr -e-keyable 1 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.nonControl");
					setAttr -lock 1 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.nonControl");

					setAttr ($modCore + $seg + $segStart + "_TwistSplineIKCurve.v") 0;
					
					setAttr -lock 1 -keyable 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.tx");
					setAttr -lock 1 -keyable 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.ty");
					setAttr -lock 1 -keyable 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.tz");
					setAttr -lock 1 -keyable 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.rx");
					setAttr -lock 1 -keyable 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.ry");
					setAttr -lock 1 -keyable 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.rz");
					setAttr -lock 1 -keyable 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.sx");
					setAttr -lock 1 -keyable 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.sy");
					setAttr -lock 1 -keyable 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.sz");
					setAttr -lock 1 -keyable 0 ($modCore + $seg + $segStart + "_TwistSplineIKCurve.v");
				}
				
				////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////
				//INDIVIDUAL ARM JOINTS AND CONTROLS
				////////////////////////////////////////////////////////////////////////////////////////////////
				circle -n ($modCore + $seg + "_Curve" + $rpNum + "Cb") -c 0 0 2.5 -nr 1 0 0 -r 0.5 -ch 0;
				circle -n ($modCore + $seg + "_Curve" + $rpNum + "Cc") -c 0 0 -2.5 -nr 1 0 0 -r 0.5 -ch 0;
				curve -n  ($modCore + $seg + "_Curve" + $rpNum + "Ctrl") -d 1 -p 0 0 -2 -p 0 0 2 -k 0 -k 1 ;
				rename `listRelatives -c ($modCore + $seg + "_Curve" + $rpNum + "Ctrl")` ($modCore + $seg + "_Curve" + $rpNum + "CtrlShape");
	
				parent -r -s ($modCore + $seg + "_Curve" + $rpNum + "CbShape") ($modCore + $seg + "_Curve" + $rpNum + "CcShape") ($modCore + $seg + "_Curve" + $rpNum + "Ctrl");
				delete ($modCore + $seg + "_Curve" + $rpNum + "Cb") ($modCore + $seg + "_Curve" + $rpNum + "Cc");
				
				setAttr ($modCore + $seg + "_Curve" + $rpNum + "Ctrl.rotateOrder") 1;
				connectAttr -f ($modCore + "_SwitchCtrl." + $limbType + "CurveMicro") ($modCore + $seg + "_Curve" + $rpNum + "Ctrl.v");
				setAttr -lock 1 -keyable 0 ($modCore + $seg + "_Curve" + $rpNum + "Ctrl.v");
				
	
				scale -r ($segLength/6) ($segLength/6) ($segLength/6) ($modCore + $seg + "_Curve" + $rpNum + "Ctrl");
				makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + $seg + "_Curve" + $rpNum + "Ctrl");
					
				group -n ($modCore + $seg + "_Curve" + $rpNum + "CtrlGrp") ($modCore + $seg + "_Curve" + $rpNum + "Ctrl");
				setAttr ($modCore + $seg + "_Curve" + $rpNum + "CtrlGrp.rotateOrder") 1;
				
				connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + $seg + "_Curve" + $rpNum + "CtrlGrp.scale");
				parent ($modCore + $seg + "_Curve" + $rpNum + "CtrlGrp") ($modCore + "_extraCurveNodesGrp");
				
				select -cl;
				joint -n ($modCore + $seg + "_Curve" + $rpNum + "Jnt");
				parentConstraint ($modCore + $seg + "_Curve" + $rpNum + "Ctrl") ($modCore + $seg + "_Curve" + $rpNum + "Jnt");
				
				shadingNode -asUtility multiplyDivide -n ($modCore + $seg + "_Curve" + $rpNum + "JntMD");
				connectAttr -f ($modCore + $seg + "_Curve" + $rpNum + "Ctrl.scale") ($modCore + $seg + "_Curve" + $rpNum + "JntMD.input1");
				connectAttr -f ($modCore + $segStart + "JntIKFK_BlndScale.outputR") ($modCore + $seg + "_Curve" + $rpNum + "JntMD.input2X");
				connectAttr -f ($modCore + $segStart + "JntIKFK_AutoBlnd.outputR") ($modCore + $seg + "_Curve" + $rpNum + "JntMD.input2Y");
				connectAttr -f ($modCore + $segStart + "JntIKFK_AutoBlnd.outputR") ($modCore + $seg + "_Curve" + $rpNum + "JntMD.input2Z");

				connectAttr -f ($modCore + $seg + "_Curve" + $rpNum + "JntMD.output") ($modCore + $seg + "_Curve" + $rpNum + "Jnt.scale");
				
				parent ($modCore + $seg + "_Curve" + $rpNum + "Jnt") ($modCore + "_curveNodesGrp");
	
				//ATTACH TO PATH
				float $segDivider = ($sizeRollProxies + 1);
				float $percentage = ($rpNumFloat/$segDivider);
	
				//NO FLIP JOINTS UP
				pathAnimation -n ($modCore + $seg + "" + $rpNum + "_MP") -fractionMode true -followAxis x -upAxis y-worldUpType "objectrotation"
				-worldUpVector 0 1 0 -inverseFront $inverseFront -worldUpObject ($modCore + $seg + $segStart + "_TwistJnt" + $rpNum) ($modCore + $seg + "_Curve" + $rpNum + "CtrlGrp") ($modCore + $seg + "CurveAttach");
				cutKey -cl -t ":" -f ":" -at "u" ($modCore + $seg + "" + $rpNum + "_MP");
				setAttr ($modCore + $seg + "" + $rpNum + "_MP.uValue") ($percentage * $uValComp);
				
				//MOVE CURVE AND JOINT TO THE PROXY
				delete `pointConstraint ("RRM_" + $prfx + $core + $seg + $rpNum) ($modCore + $seg + "_Curve" + $rpNum + "Ctrl")`;
				makeIdentity -apply true -t 1 ($modCore + $seg + "_Curve" + $rpNum + "Ctrl");
	
				select -cl;
				$rpNum++;
			}//CREATE TWIST JOINTS
			
			//CREATE TOP CURVE JOINT
			if (!`objExists ($modCore + $segStart + "_CurveJnt")`)
			{
				select -cl;
				joint -n ($modCore + $segStart + "_CurveJnt");
				delete `parentConstraint ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_CurveJnt")`;
				makeIdentity -apply true -r 1 ($modCore + $segStart + "_CurveJnt");
				if ($segInteger == 1)
				{
					//TARGET LOCATOR
					spaceLocator -n ($modCore + $segStart + "_CurveJnt_AimLctr");
					group -n ($modCore + $segStart + "_CurveJnt_AimLctrGrp");
					pathAnimation -n ($modCore + $segStart + "_CurveJnt_AimLctr_MP") -fractionMode true -followAxis x -upAxis y-worldUpType "objectrotation"
					-worldUpVector 0 1 0 -inverseFront $inverseFront -worldUpObject ($modCore + $seg + $segStart + "_NoRollJnt") ($modCore + $segStart + "_CurveJnt_AimLctrGrp") ($modCore + $seg + "CurveAttach");
					cutKey -cl -t ":" -f ":" -at "u" ($modCore + $segStart + "_CurveJnt_AimLctr_MP");
					setAttr ($modCore + $segStart + "_CurveJnt_AimLctr_MP.uValue") (0.002 * $uValComp);
					
					parent ($modCore + $segStart + "_CurveJnt_AimLctrGrp") ($modCore + "_extraCurveNodesGrp");
					setAttr ($modCore + $segStart + "_CurveJnt_AimLctrGrp.v") 0;
					
					pointConstraint ($modCore + $segStart + "Jnt") ($modCore + $segStart + "_CurveJnt");
					aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "objectrotation"
					-worldUpVector 0 1 0 -worldUpObject ($modCore + $seg + $segStart + "_TwistSplineIK_Up1Lctr") ($modCore + $segStart + "_CurveJnt_AimLctr") ($modCore + $segStart + "_CurveJnt");

					connectAttr -f ($modCore + $segStart + "JntIKFK_BlndScale.outputR") ($modCore + $segStart + "_CurveJnt.scaleX");
					connectAttr -f ($modCore + $segStart + "JntIKFK_AutoBlnd.outputR") ($modCore + $segStart + "_CurveJnt.scaleY");
					connectAttr -f ($modCore + $segStart + "JntIKFK_AutoBlnd.outputR") ($modCore + $segStart + "_CurveJnt.scaleZ");
				}
				else
				{
					parentConstraint ($modCore + $segStart + "_CurveCtrl") ($modCore + $segStart + "_CurveJnt");
					shadingNode -asUtility multiplyDivide -n ($modCore + $segStart + "_CurveJntMD");
					connectAttr -f ($modCore + $segStart + "_CurveCtrl.scale") ($modCore + $segStart + "_CurveJntMD.input1");
					connectAttr -f ($modCore + $segStart + "JntIKFK_BlndScale.outputR") ($modCore + $segStart + "_CurveJntMD.input2X");
					connectAttr -f ($modCore + $segStart + "JntIKFK_AutoBlnd.outputR") ($modCore + $segStart + "_CurveJntMD.input2Y");
					connectAttr -f ($modCore + $segStart + "JntIKFK_AutoBlnd.outputR") ($modCore + $segStart + "_CurveJntMD.input2Z");
	
					connectAttr -f ($modCore + $segStart + "_CurveJntMD.output") ($modCore + $segStart + "_CurveJnt.scale");
				}
				parent ($modCore + $segStart + "_CurveJnt") ($modCore + "_curveNodesGrp");
			}
			//CREATE BOTTOM CURVE JOINT
			if (($segInteger != 2) && (!`objExists ($modCore + $segEnd + "_CurveJnt")`))
			{
				select -cl;
				joint -n ($modCore + $segEnd + "_CurveJnt");
				delete `parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_CurveJnt")`;
				makeIdentity -apply true -r 1 ($modCore + $segEnd + "_CurveJnt");
				if ($segInteger == 1)
				{				
					parentConstraint ($modCore + $segEnd + "_CurveCtrl") ($modCore + $segEnd + "_CurveJnt");
				}
				else
				{
					parentConstraint ($modCore + $segEnd + "Jnt") ($modCore + $segEnd + "_CurveJnt");
				}
				shadingNode -asUtility multiplyDivide -n ($modCore + $segEnd + "_CurveJntMD");
				connectAttr -f ($modCore + $segEnd + "_CurveCtrl.scale") ($modCore + $segEnd + "_CurveJntMD.input1");
				connectAttr -f ($modCore + $segEnd + "JntIKFK_BlndScale.outputR") ($modCore + $segEnd + "_CurveJntMD.input2X");
				connectAttr -f ($modCore + $segEnd + "JntIKFK_AutoBlnd.outputR") ($modCore + $segEnd + "_CurveJntMD.input2Y");
				connectAttr -f ($modCore + $segEnd + "JntIKFK_AutoBlnd.outputR") ($modCore + $segEnd + "_CurveJntMD.input2Z");

				connectAttr -f ($modCore + $segEnd + "_CurveJntMD.output") ($modCore + $segEnd + "_CurveJnt.scale");

				parent ($modCore + $segEnd + "_CurveJnt") ($modCore + "_curveNodesGrp");
			}
	    }//CREATE JOINTS AND CONTROLS FOR EACH PROXY
	    else
	    {//CREATE CONNECTOR LINES ONLY
			//CREATE GUIDE SPLINE CURVES FOR MACRO CONTROL ATTACHMENT
			curve -n ($modCore + $seg + "CurveAttach") -d 1 -p $startPos[0] $startPos[1] $startPos[2]
			-p $endPos[0] $endPos[1] $endPos[2] -k 0 -k 1 ;
			rename `listRelatives -c ($modCore + $seg + "CurveAttach")` ($modCore + $seg + "CurveAttachShape");
			
			//CREATE CLUSTERS FOR EACH END
			select ($modCore + $seg + "CurveAttach.cv[0]");
			newCluster " -envelope 1";
			rename ($modCore + $seg + "TopGuideClstr");
			
			pointConstraint  ($modCore + $segStart + "Jnt") ($modCore + $seg + "TopGuideClstr");
			
			select ($modCore + $seg + "CurveAttach.cv[1]");
			newCluster " -envelope 1";
			rename ($modCore + $seg + "BtmGuideClstr");
						
			pointConstraint ($modCore + $segEnd + "Jnt") ($modCore + $seg + "BtmGuideClstr");

			parent ($modCore + $seg + "CurveAttach") ($modCore + "_extraCurveNodesGrp");
			setAttr ($modCore + $seg + "CurveAttach.template") 1;
			
			parent ($modCore + $seg + "TopGuideClstr") ($modCore + $seg + "BtmGuideClstr") ($modCore + "_curveNodesGrp");
			setAttr ($modCore + $seg + "TopGuideClstr.v") 0;
			setAttr ($modCore + $seg + "BtmGuideClstr.v") 0;
				
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.tx");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.ty");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.tz");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.rx");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.ry");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.rz");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.sx");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.sy");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.sz");
			setAttr -lock 1 -keyable 0 ($modCore + $seg + "CurveAttach.v");
	    }
		$segInteger ++;
	}
}

//////////////////////////////////////////////////////////////////////////////
///////////////////////////////    ROLL LIMB    ///////////////////////////////
//////////////////////////////////////////////////////////////////////////////

global proc RRM_RollLimbs_V1(string $modName, string $limbType, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, string $modCore, string $modOppCore, int $multiplier, int $inverseFront, string $modAttachNode, string $topNode)
{
	$core = `getAttr ($topNode + ".core")`;

	float $elbow1Loc[];
	float $elbow2Loc[];	
	string $elbow1 = "_Elbow";
	string $elbow2 = "_Elbow";
	string $elbowType = "elbow";
	string $shoulder = "_Shoulder";
	string $clavicle = "_Clavicle";
	string $parentNode = "_ClavicleJnt";
	string $wrist = "_Wrist";
	string $wristDummy = "_WristJntDummy";
	string $FKCtrlGrp = "FKCtrlGrp2";
	int $segInteger = 1;
	float $limbLength;

	if ($limbType == "leg")
	{
		$elbow1 = "_Knee";
		$elbow2 = "_Knee";
		$elbowType = "knee";
		$shoulder = "_Hip";
		$clavicle = ("_" + $modAttachNode);
		$parentNode = "_HipFKCtrlGrp";
		$wrist = "_Ankle";
		$wristDummy = "_AnkleJnt";
		$FKCtrlGrp = "FKCtrlGrp";
		select ("RRM_" + $prfx + $core + "_Hip") ("RRM_" + $prfx + $core + "_Ankle");
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			select -add ("RRM_" + $prfx + $core + "_Knee");
		}
		else
		{
			select -add ("RRM_" + $prfx + $core + "_Knee1") ("RRM_" + $prfx + $core + "_Knee1");
		}
		//SET MULTIPLIER TO NOT MIRROR
		$multiplier = 1;
	}
	
	if (`objExists ("RRM_" + $prfx + $core + "_Elbow1")` || `objExists ("RRM_" + $prfx + $core + "_Knee1")`)
	{
		$elbow1 = "_Elbow1";
		$elbow2 = "_Elbow2";
		if ($limbType == "leg")
		{
			$elbow1 = "_Knee1";
			$elbow2 = "_Knee2";
		}
	}

	//UPPER TWIST
	if (`objExists ("RRM_" + $prfx + $core + "_Upper1")`)
	{
		select -cl;
		joint -n ($modCore + $shoulder + "_CurveJnt");
		setAttr ($modCore + $shoulder + "_CurveJnt.radius") 2;
		delete `parentConstraint ($modCore + $shoulder + "Jnt") ($modCore + $shoulder + "_CurveJnt")`;
		parent ($modCore + $shoulder + "_CurveJnt") ($modCore + "_ClavicleJnt");
		makeIdentity -apply 1 -r 1 ($modCore + $shoulder + "_CurveJnt");
		connectAttr -f ($modCore + $shoulder + "Jnt.translate") ($modCore + $shoulder + "_CurveJnt.translate");
		connectAttr -f ($modCore + $shoulder + "Jnt.scale") ($modCore + $shoulder + "_CurveJnt.scale");
	
		select -cl;
		joint -n ($modCore + $shoulder + "_CurveEndJnt");
		setAttr ($modCore + $shoulder + "_CurveEndJnt.radius") 2;
		delete `parentConstraint ($modCore + $elbow1 + "Jnt") ($modCore + $shoulder + "_CurveEndJnt")`;
		parent ($modCore + $shoulder + "_CurveEndJnt") ($modCore + $shoulder + "_CurveJnt");
		makeIdentity -apply 1 -r 1 ($modCore + $shoulder + "_CurveEndJnt");   
		  
		$prev = 0;
		$i = 1;
		$upperArmCurve = `ls ("RRM_" + $prfx + $core + "_Upper?")`;
		
		//DISTRIBUTE SHOULDER ROTATION ACROSS TWIST JOINTS
		shadingNode -asUtility multiplyDivide -n ($modCore + $shoulder + "Curve_MD");
		setAttr ($modCore + $shoulder + "Curve_MD.operation") 2;
		setAttr ($modCore + $shoulder + "Curve_MD.input2X") `size $upperArmCurve`;
		connectAttr -f ($modCore + $shoulder + "Jnt.rotateX") ($modCore + $shoulder + "Curve_MD.input1X");
		
		for ($each in $upperArmCurve)
		{
			select -cl;
			joint -n ($modCore + "_Upper_Curve" + $i + "Jnt");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Upper" + $i) ($modCore + "_Upper_Curve" + $i + "Jnt")`;
			if ($prev == 0)
			{
				parent ($modCore + "_Upper_Curve" + $i + "Jnt") ($modCore + $shoulder + "_CurveJnt");
			}
			else
			{
				parent ($modCore + "_Upper_Curve" + $i + "Jnt") ($modCore + "_Upper_Curve" + $prev + "Jnt");
	
			}
			setAttr (($modCore + "_Upper_Curve" + $i + "Jnt.rotate"), 0, 0, 0);
			setAttr (($modCore + "_Upper_Curve" + $i + "Jnt.jointOrient"), 0, 0, 0);
			connectAttr -f ($modCore + $shoulder + "Curve_MD.outputX") ($modCore + "_Upper_Curve" + $i + "Jnt.rotateX");
			connectAttr -f ($modCore + $shoulder + "Jnt.scale")($modCore + "_Upper_Curve" + $i + "Jnt.scale");
			
			$prev++;
			$i++;
		}
		
		//CREATE IK HANDLE
		select ($modCore + $shoulder + "_CurveJnt.rotatePivot") ($modCore + $shoulder + "_CurveEndJnt.rotatePivot");
		ikHandle -n ($modCore + "_Upper_CurveIkHandle") -sol ikSCsolver;
		parent ($modCore + "_Upper_CurveIkHandle") ($modCore + "_ClavicleCtrl");
		pointConstraint ($modCore + $elbow1 + "Jnt") ($modCore + "_Upper_CurveIkHandle");
		setAttr ($modCore + "_Upper_CurveIkHandle.visibility") 0;
		
		//DISTRIBUTE SHOULDER ROTATION ACROSS TWIST JOINTS
		shadingNode -asUtility multiplyDivide -n ($modCore + $shoulder + "Curve_MD");
		setAttr ($modCore + $shoulder + "Curve_MD.operation") 2;

		//HIDE SHOULDER AND ELBOW JOINTS SO THEY DON'T GET CONFUSED WITH THE TOON JOINTS
		//DETERMINE VERSION NUMBER
		$versionNum = `getApplicationVersionAsFloat`;
		if ($versionNum >= 2011)
		{
			setAttr ($modCore + $shoulder + "_CurveJnt.drawStyle") 2;
			setAttr ($modCore + $shoulder + "_CurveEndJnt.drawStyle") 2;

		}
		else
		{
			setAttr ($modCore + $shoulder + "_CurveJnt.visibility") 0;
			setAttr ($modCore + $shoulder + "_CurveEndJnt.visibility") 0;
		}
	}
	
	//MIDDLE TWIST
	if (`objExists ("RRM_" + $prfx + $core + "_Middle1")`)
	{
		$prev = 0;
		$i = 1;
		$midArmCurve = `ls ("RRM_" + $prfx + $core + "_Middle?")`;
		
		////DISTRIBUTE SHOULDER ROTATION ACROSS TWIST JOINTS
		//shadingNode -asUtility multiplyDivide -n ($modCore + $elbow1 + "Curve_MD");
		//setAttr ($modCore + $elbow1 + "Curve_MD.operation") 2;
		//setAttr ($modCore + $elbow1 + "Curve_MD.input2X") `size $upperArmCurve`;
		//connectAttr -f ($modCore + "_WristJntGrp1.rotateX") ($modCore + $elbow1 + "Curve_MD.input1X");
		
		for ($each in $midArmCurve)
		{
			select -cl;
			joint -n ($modCore + "_Middle_Curve" + $i + "Jnt");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Middle" + $i) ($modCore + "_Middle_Curve" + $i + "Jnt")`;
			if ($prev == 0)
			{
				parent ($modCore + "_Middle_Curve" + $i + "Jnt") ($modCore + $elbow1 + "Jnt");
			}
			else
			{
				parent ($modCore + "_Middle_Curve" + $i + "Jnt") ($modCore + "_Middle_Curve" + $prev + "Jnt");
	
			}
			setAttr (($modCore + "_Middle_Curve" + $i + "Jnt.rotate"), 0, 0, 0);
			setAttr (($modCore + "_Middle_Curve" + $i + "Jnt.jointOrient"), 0, 0, 0);
			//connectAttr -f ($modCore + $elbow1 + "Curve_MD.outputX") ($modCore + "_Middle_Curve" + $i + "Jnt.rotateX");
			//connectAttr -f ($modCore + $elbow1 + "Jnt.scale")($modCore + "_Middle_Curve" + $i + "Jnt.scale");
    
			$prev++;
			$i++;			
		}
	}	
	
	//LOWER TWIST
	if (`objExists ("RRM_" + $prfx + $core + "_Lower1")`)
	{
		$prev = 0;
		$i = 1;
		$lowerArmCurve = `ls ("RRM_" + $prfx + $core + "_Lower?")`;
		
		//DISTRIBUTE SHOULDER ROTATION ACROSS TWIST JOINTS
		shadingNode -asUtility multiplyDivide -n ($modCore + $elbow2 + "Curve_MD");
		setAttr ($modCore + $elbow2 + "Curve_MD.operation") 2;
		setAttr ($modCore + $elbow2 + "Curve_MD.input2X") `size $lowerArmCurve`;
		connectAttr -f ($modCore + "_WristJntGrp1.rotateX") ($modCore + $elbow2 + "Curve_MD.input1X");
		
		for ($each in $lowerArmCurve)
		{
			select -cl;
			joint -n ($modCore + "_Lower_Curve" + $i + "Jnt");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Lower" + $i) ($modCore + "_Lower_Curve" + $i + "Jnt")`;
			if ($prev == 0)
			{
				parent ($modCore + "_Lower_Curve" + $i + "Jnt") ($modCore + $elbow2 + "Jnt");
			}
			else
			{
				parent ($modCore + "_Lower_Curve" + $i + "Jnt") ($modCore + "_Lower_Curve" + $prev + "Jnt");
	
			}
			setAttr (($modCore + "_Lower_Curve" + $i + "Jnt.rotate"), 0, 0, 0);
			setAttr (($modCore + "_Lower_Curve" + $i + "Jnt.jointOrient"), 0, 0, 0);
			connectAttr -f ($modCore + $elbow2 + "Curve_MD.outputX") ($modCore + "_Lower_Curve" + $i + "Jnt.rotateX");
			connectAttr -f ($modCore + $elbow2 + "Jnt.scale")($modCore + "_Lower_Curve" + $i + "Jnt.scale");

			$prev++;
			$i++;			
		}
	}
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE ARM MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_RollJoints_V1(string $modName, string $limbType, string $prfx, string $oppPrfx, string $crntSide, string $oppSide, string $modCore, string $modOppCore, int $multiplier, int $inverseFront, string $modAttachNode, string $topNode)
{
	$core = `getAttr ($topNode + ".core")`;

	float $elbow1Loc[];
	float $elbow2Loc[];	
	string $elbow1 = "_Elbow";
	string $elbow2 = "_Elbow";
	string $elbowType = "elbow";
	string $shoulder = "_Shoulder";
	string $clavicle = "_Clavicle";
	string $parentNode = "_ClavicleJnt";
	string $wrist = "_Wrist";
	string $wristDummy = "_WristJntDummy";
	string $FKCtrlGrp = "FKCtrlGrp2";
	int $segInteger = 1;
	float $limbLength;

	if ($limbType == "leg")
	{
		$elbow1 = "_Knee";
		$elbow2 = "_Knee";
		$elbowType = "knee";
		$shoulder = "_Hip";
		$clavicle = ("_" + $modAttachNode);
		$parentNode = "_HipFKCtrlGrp";
		$wrist = "_Ankle";
		$wristDummy = "_AnkleJnt";
		$FKCtrlGrp = "FKCtrlGrp";
		select ("RRM_" + $prfx + $core + "_Hip") ("RRM_" + $prfx + $core + "_Ankle");
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			select -add ("RRM_" + $prfx + $core + "_Knee");
		}
		else
		{
			select -add ("RRM_" + $prfx + $core + "_Knee1") ("RRM_" + $prfx + $core + "_Knee1");
		}
		//SET MULTIPLIER TO NOT MIRROR
		$multiplier = 1;
	}
	else
	{
		select ("RRM_" + $prfx + $core + "_Shoulder") ("RRM_" + $prfx + $core + "_Wrist");
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			select -add ("RRM_" + $prfx + $core + "_Elbow");
		}
		else
		{
			select -add ("RRM_" + $prfx + $core + "_Elbow1") ("RRM_" + $prfx + $core + "_Elbow1");
		}
	}
	$segments = `ls -sl`;
		
	float $middleLimbLength;

	if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")` && !`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
	{
		$elbow1Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$elbow2Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$upperLimbLength = `getAttr ($modCore + $elbow1 + "Jnt.translateX")`;
		$lowerLimbLength = `getAttr ($modCore + $wristDummy + ".translateX")`;
		$limbLength = (($upperLimbLength + $lowerLimbLength)/2);
	}
	else
	{
		$elbow1 = "_Elbow1";
		$elbow2 = "_Elbow2";
		if ($limbType == "leg")
		{
			$elbow1 = "_Knee1";
			$elbow2 = "_Knee2";
		}			
		$elbow1Loc = `xform -q -ws -rp ($modCore + $elbow1 + "Jnt")`;
		$elbow2Loc = `xform -q -ws -rp ($modCore + $elbow2 + "Jnt")`;
		$upperLimbLength = `getAttr ($modCore + $elbow1 + "Jnt.translateX")`;
		$middleLimbLength = `getAttr ($modCore + $elbow2 + "Jnt.translateX")`;
		$lowerLimbLength = `getAttr ($modCore + $wristDummy + ".translateX")`;
		$limbLength = (($upperLimbLength + $lowerLimbLength)/2);
	}
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE ARM MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

global proc RRM_GenerateRig_V1Arm_V1(string $modName, string $moduleName, string $topNode)
{
	$core = `getAttr ($topNode + ".core")`;

	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	int $inverseFront = 0;
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}

	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	$i = 0;

	//ARM
	while ($i !=2)
	{
		if (!`objExists ($topNode + ".pair")`)
		{
			$prfx = "";
			$oppPrfx = "";
			select $topNode;
			
			$crntSide = `getAttr ($topNode + ".single")`;
			if ($crntSide == "right")
			{
				$multiplier = -1;
				$inverseFront = 1;
			}
		}
		
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modName + "_" + $prfx + $core);
		
		$modOppCore = ($modName + "_" + $oppPrfx + $core);
		
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		delete `orientConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_OffsetLctr");
		
		group -em -n ($modCore);
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modName + "_ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_ROOTJnt") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modName + "_MAINCtrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "arm";
		setAttr -l true ($modCore + "Grp.topNode");	
		
		//CORE NAME
		addAttr -ln "coreName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ("_" + $prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable 1 ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ("_" + $oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable 1 ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");
		}
		
		//NODE-SPECIFIC ATTRIBUTES
		//UPPER ROLL JOINTS
		string $UpperCJnt[];
		if (`objExists ($modCore + "_Upper_Curve1Jnt")`)
		{
			$UpperCJnt = `ls ($modCore + "_Upper_Curve?Jnt")`;
		}
		addAttr -ln "upperRoll"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.upperRoll") ;
		setAttr -type "string" ($modCore + "Grp.upperRoll") `size $UpperCJnt`;
		setAttr -l true ($modCore + "Grp.upperRoll");
		
		string $LowerCJnt[];
		if (`objExists ($modCore + "_Lower_Curve1Jnt")`)
		{
			$UpperCJnt = `ls ($modCore + "_Lower_Curve?Jnt")`;
		}
		addAttr -ln "lowerRoll"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.lowerRoll") ;
		setAttr -type "string" ($modCore + "Grp.lowerRoll") `size $LowerCJnt`;
		setAttr -l true ($modCore + "Grp.lowerRoll");
	
	
		addAttr -ln "elbowNum"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.elbowNum") ;
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			setAttr -type "string" ($modCore + "Grp.elbowNum") "1";
		}
		else
		{
			setAttr -type "string" ($modCore + "Grp.elbowNum") "2";
		}		
		setAttr -l true ($modCore + "Grp.elbowNum");
		
	
		int $sizeMiddleCJnt = 0;
		string $MiddleCJnt[];
		if (`objExists ($modCore + "_Middle_Curve1Jnt")`)
		{
			$MiddleCJnt = `ls ($modCore + "_Middle_Curve?Jnt")`;
		}
		addAttr -ln "midRoll"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.midRoll") ;
		setAttr -type "string" ($modCore + "Grp.midRoll") $MiddleCJnt;
		setAttr -l true ($modCore + "Grp.midRoll");
		
		
	
		//SCALE GROUP
		group -em -n ($modCore + "_ScaleGrp");
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Clavicle") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Clavicle") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + "_ScaleGrp.scale");
		
		
		//CONTROLS
		
		//SCALE
		float $ArmLength;
		float $elbowLength[];
		float $elbow1Length[];
		float $elbow2Length[];
		float $WristLength[];
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			spaceLocator -n ($modCore + "_StartLctr") -p 0 0 0;
			spaceLocator -n ($modCore + "_EndLctr") -p 0 0 0;
			parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_EndLctr")`;
			$elbowLength = `xform -q -t ($modCore + "_EndLctr")`;
			
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_EndLctr")`;
			$WristLength = `xform -q -t ($modCore + "_EndLctr")`;
			
			$ArmLength = (($elbowLength[0] + $WristLength[0]) /2);
			delete ($modCore + "_StartLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_StartLctr") -p 0 0 0;
			spaceLocator -n ($modCore + "_EndLctr") -p 0 0 0;
			parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_EndLctr")`;
			$elbow1Length = `xform -q -t ($modCore + "_EndLctr")`;
			
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_EndLctr")`;
			$elbow2Length = `xform -q -t ($modCore + "_EndLctr")`;
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_EndLctr")`;
			$WristLength = `xform -q -t ($modCore + "_EndLctr")`;

			$ArmLength = (($elbow1Length[0] + $elbow2Length[0]) /2);
			delete ($modCore + "_StartLctr");
		}	

		//CLAVICLE CONTROL
		circle -n ($modCore + "_ClavicleCtrl") -nr 0 1 0 -r 1 -ch 0;
		setAttr ($modCore + "_ClavicleCtrl.rotateOrder") 1;
		move -r ($multiplier * 1.35) 2 0 ($modCore + "_ClavicleCtrl.cv[3]") ($modCore + "_ClavicleCtrl.cv[7]") ;
		move -r ($multiplier * 0.5) 1.25 0 ($modCore + "_ClavicleCtrl.cv[2]") ($modCore + "_ClavicleCtrl.cv[4]") ($modCore + "_ClavicleCtrl.cv[0]") ($modCore + "_ClavicleCtrl.cv[6]") ;
		group -n ($modCore + "_ClavicleCtrlGrp") ($modCore + "_ClavicleCtrl"); xform -os -piv 0 0 0;
		setAttr ($modCore + "_ClavicleCtrlGrp.rotateOrder") 1;
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Clavicle") ($modCore + "_ClavicleCtrlGrp")`;
		
		setAttr (($modCore + "_ClavicleCtrlGrp.scale"), (($ArmLength/2) * 0.4), (($ArmLength/2) * 1), (($ArmLength/2) * 1.25));
		
		makeIdentity -apply true -t 0 -s 1 ($modCore + "_ClavicleCtrlGrp");
		
		//SHOULDER FK CONTROL
		circle -n ($modCore + "_ShoulderFKCtrl") -nr 1 0 0 -r 1 -ch 0;
		setAttr ($modCore + "_ShoulderFKCtrl.rotateOrder") 1;
		group -n ($modCore + "_ShoulderFKCtrlGrp") ($modCore + "_ShoulderFKCtrl");
		group -n ($modCore + "_ShoulderFKCtrlGrp2") ($modCore + "_ShoulderFKCtrlGrp");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_ShoulderFKCtrlGrp2")`;
		float $upVector = 1;
		float $elbowLocCheck;
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			$elbowLocCheck = `getAttr ("RRM_" + $prfx + $core + "_Elbow.translateZ")`;
		}
		else
		{
			$elbowLocCheck = `getAttr ("RRM_" + $prfx + $core + "_Elbow1.translateZ")`;
		}
		if ($elbowLocCheck > 0.0001)
		{
			$upVector = -1;
		}
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			delete `aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 $upVector 0 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow")
			("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_ShoulderFKCtrlGrp2")`;
		}
		else
		{
			delete `aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 $upVector 0 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow1")
			("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_ShoulderFKCtrlGrp2")`;
		}
		
	
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_ShoulderFKCtrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_ShoulderFKCtrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_ShoulderFKCtrl");
		
		setAttr (($modCore + "_ShoulderFKCtrl.scale"), ($ArmLength/2), ($ArmLength/2), ($ArmLength/2));
		makeIdentity -apply true -s 1 ($modCore + "_ShoulderFKCtrlGrp2");
			
		//ELBOW FK CONTROL
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			duplicate -n ($modCore + "_ElbowFKCtrlGrp") ($modCore + "_ShoulderFKCtrlGrp");
			parent -w ($modCore + "_ElbowFKCtrlGrp");
			select ($modCore + "_ElbowFKCtrlGrp");
			pickWalk -d down;
			rename ($modCore + "_ElbowFKCtrl");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_ElbowFKCtrlGrp")`;
			delete `aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "objectrotation"
			-worldUpVector 0 $upVector 0 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow")
			("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_ElbowFKCtrlGrp")`;
			scale -r 0.8 0.8 0.8 ($modCore + "_ElbowFKCtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + "_ElbowFKCtrlGrp");
		}
		else
		{
			duplicate -n ($modCore + "_Elbow1FKCtrlGrp") ($modCore + "_ShoulderFKCtrlGrp");
			parent -w ($modCore + "_Elbow1FKCtrlGrp");
			select ($modCore + "_Elbow1FKCtrlGrp");
			pickWalk -d down;
			rename ($modCore + "_Elbow1FKCtrl");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_Elbow1FKCtrlGrp")`;
			delete `aimConstraint -offset 0 0 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "objectrotation"
			-worldUpVector 0 $upVector 0 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow1")
			("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_Elbow1FKCtrlGrp")`;
			scale -r 0.8 0.8 0.8 ($modCore + "_Elbow1FKCtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + "_Elbow1FKCtrlGrp");
			
			duplicate -n ($modCore + "_Elbow2FKCtrlGrp") ($modCore + "_ShoulderFKCtrlGrp");
			parent -w ($modCore + "_Elbow2FKCtrlGrp");
			select ($modCore + "_Elbow2FKCtrlGrp");
			pickWalk -d down;
			rename ($modCore + "_Elbow2FKCtrl");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_Elbow2FKCtrlGrp")`;
			scale -r 0.8 0.8 0.8 ($modCore + "_Elbow2FKCtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + "_Elbow2FKCtrlGrp");
		}

		//WRIST FK CONTROL
		duplicate -n ($modCore + "_WristFKCtrlGrp") ($modCore + "_ShoulderFKCtrlGrp");
		parent -w ($modCore + "_WristFKCtrlGrp");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_WristFKCtrlGrp")`;
		scale -r 0.8 0.8 0.8 ($modCore + "_WristFKCtrlGrp");
		makeIdentity -apply true -s 1 ($modCore + "_WristFKCtrlGrp");
		select ($modCore + "_WristFKCtrlGrp");
		pickWalk -d down;
		rename ($modCore + "_WristFKCtrl");
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_WristFKCtrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_WristFKCtrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_WristFKCtrl");
	
	
		//////////////////////JOINTS//////////////////////
		select -cl;
		joint -n ($modCore + "_ClavicleJnt");
		setAttr ($modCore + "_ClavicleJnt.rotateOrder") 1;
		delete `parentConstraint ($modCore + "_ClavicleCtrl") ($modCore + "_ClavicleJnt")`;
		
		select -cl;
		joint -n ($modCore + "_ShoulderJnt");
		setAttr ($modCore + "_ShoulderJnt.rotateOrder") 1;
		delete `parentConstraint ($modCore + "_ShoulderFKCtrl") ($modCore + "_ShoulderJnt")`;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			select -cl;
			joint -n ($modCore + "_ElbowJnt");
			setAttr ($modCore + "_ElbowJnt.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_ElbowFKCtrl") ($modCore + "_ElbowJnt")`;
		
			select -cl;
			joint -n ($modCore + "_WristJnt");
			delete `parentConstraint ($modCore + "_WristFKCtrl") ($modCore + "_WristJnt")`;
			select -cl;
			joint -n ($modCore + "_WristJntDummy");
			delete `parentConstraint ($modCore + "_WristFKCtrl") ($modCore + "_WristJntDummy")`;
			
			makeIdentity -apply true -r 1 ($modCore + "_ClavicleJnt") ($modCore + "_ShoulderJnt")
			($modCore + "_ElbowJnt") ($modCore + "_WristJnt") ($modCore + "_WristJntDummy");
			
			parent ($modCore + "_ShoulderJnt") ($modCore + "_ClavicleJnt");
			parent ($modCore + "_ElbowJnt")  ($modCore + "_ShoulderJnt");
			parent ($modCore + "_WristJnt") ($modCore + "_ElbowJnt");
			parent ($modCore + "_WristJntDummy") ($modCore + "_ElbowJnt");
		}
		else
		{
			select -cl;
			joint -n ($modCore + "_Elbow1Jnt");
			setAttr ($modCore + "_Elbow1Jnt.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_Elbow1FKCtrl") ($modCore + "_Elbow1Jnt")`;
		
			select -cl;
			joint -n ($modCore + "_Elbow2Jnt");
			setAttr ($modCore + "_Elbow2Jnt.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_Elbow2FKCtrl") ($modCore + "_Elbow2Jnt")`;
	
			select -cl;
			joint -n ($modCore + "_WristJnt");
			delete `parentConstraint ($modCore + "_WristFKCtrl") ($modCore + "_WristJnt")`;
			select -cl;
			joint -n ($modCore + "_WristJntDummy");
			delete `parentConstraint ($modCore + "_WristFKCtrl") ($modCore + "_WristJntDummy")`;
			
			makeIdentity -apply true -r 1 ($modCore + "_ClavicleJnt") ($modCore + "_ShoulderJnt")
			($modCore + "_Elbow1Jnt") ($modCore + "_Elbow2Jnt") ($modCore + "_WristJnt") ($modCore + "_WristJntDummy");
	
			parent ($modCore + "_ShoulderJnt") ($modCore + "_ClavicleJnt");
			parent ($modCore + "_Elbow1Jnt")  ($modCore + "_ShoulderJnt");
			parent ($modCore + "_Elbow2Jnt") ($modCore + "_Elbow1Jnt"); 
			parent ($modCore + "_WristJnt") ($modCore + "_Elbow2Jnt");
			parent ($modCore + "_WristJntDummy") ($modCore + "_Elbow2Jnt");
		}
		//HIDE WRIST DUMMY 
		setAttr ($modCore + "_WristJntDummy.v") 0;
		//ELBOW ORIENTATION
		if (`objExists ($modCore + "_ElbowJnt")`)
		{
			if ($elbowLocCheck > 0.0001)
			{
				setAttr ($modCore + "_ElbowJnt.preferredAngleY") ($multiplier * 60);
			}
			else
			{
				setAttr ($modCore + "_ElbowJnt.preferredAngleY") ($multiplier * -60);
			}
			group -em -n ($modCore + "_WristJntGrp1");
			pointConstraint ($modCore + "_WristJntDummy") ($modCore + "_WristJntGrp1");
			delete `orientConstraint ($modCore + "_WristJnt") ($modCore + "_WristJntGrp1")`;
			group -em -n ($modCore + "_WristJntGrp2") ;
			delete `pointConstraint ($modCore + "_ElbowJnt") ($modCore + "_WristJntGrp2")`;
			delete `orientConstraint ($modCore + "_WristJnt") ($modCore + "_WristJntGrp2")`;	
			parentConstraint -mo ($modCore + "_ElbowJnt") ($modCore + "_WristJntGrp2");
		}
		else
		{
			if ($elbowLocCheck > 0.0001)
			{
				setAttr ($modCore + "_Elbow1Jnt.preferredAngleY") ($multiplier * 30);
			}
			else
			{
				setAttr ($modCore + "_Elbow1Jnt.preferredAngleY") ($multiplier * -30);
			}
			group -em -n ($modCore + "_WristJntGrp1");
			pointConstraint ($modCore + "_WristJntDummy") ($modCore + "_WristJntGrp1");
			delete `orientConstraint ($modCore + "_WristJnt") ($modCore + "_WristJntGrp1")`;
			group -em -n ($modCore + "_WristJntGrp2") ;
			delete `pointConstraint ($modCore + "_Elbow2Jnt") ($modCore + "_WristJntGrp2")`;
			delete `orientConstraint ($modCore + "_WristJnt") ($modCore + "_WristJntGrp2")`;	
			parentConstraint -mo ($modCore + "_Elbow2Jnt") ($modCore + "_WristJntGrp2");
		}
		parent ($modCore + "_WristJntGrp1") ($modCore + "_WristJntGrp2");
		parent ($modCore + "_WristJnt") ($modCore + "_WristJntGrp1");	
	
		
		
		////////////////////IK/FK JOINTS////////////////////////////////////	
		//ARM FK
		duplicate -n ($modCore + "_ShoulderJntFK") ($modCore + "_ShoulderJnt");
		select ($modCore + "_ShoulderJntFK");
		pickWalk -d down;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			rename ($modCore + "_ElbowJntFK");
			pickWalk -d down;
			rename ($modCore + "_WristJntFK");
		}
		else
		{
			rename ($modCore + "_Elbow1JntFK");
			pickWalk -d down;
			rename ($modCore + "_Elbow2JntFK");
			pickWalk -d down;
			rename ($modCore + "_WristJntFK");
		}
		
		//ARM IK
		duplicate -n ($modCore + "_ShoulderJntIK") ($modCore + "_ShoulderJnt");
		select ($modCore + "_ShoulderJntIK");
		pickWalk -d down;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			rename ($modCore + "_ElbowJntIK");
			pickWalk -d down;
			rename ($modCore + "_WristJntIK");
		}
		else
		{
			rename ($modCore + "_Elbow1JntIK");
			pickWalk -d down;
			rename ($modCore + "_Elbow2JntIK");
			pickWalk -d down;
			rename ($modCore + "_WristJntIK");
		}	
	
		//DETACH FK ARM JOINTS FOR SCALE COMPENSATION
	
		parent -w ($modCore + "_WristJntFK");
		group -n ($modCore + "_WristJntFKGrp1") ($modCore + "_WristJntFK");
		group -n ($modCore + "_WristJntFKGrp2") ($modCore + "_WristJntFKGrp1");
		$WristLocation = `xform -q -ws -t ($modCore + "_WristJnt")`;
		move $WristLocation[0] $WristLocation[1] $WristLocation[2] ($modCore + "_WristJntFKGrp2.scalePivot") ($modCore + "_WristJntFKGrp2.rotatePivot") ;
		pointConstraint ($modCore + "_WristFKCtrl") ($modCore + "_WristJntFKGrp1");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			parentConstraint -mo ($modCore + "_ElbowJntFK") ($modCore + "_WristJntFKGrp2");
		}
		else
		{
			parentConstraint -mo ($modCore + "_Elbow2JntFK") ($modCore + "_WristJntFKGrp2");
		}
			
		$elbowLocation = `xform -q -ws -t ($modCore + "_ShoulderJnt")`;
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			parent -w ($modCore + "_ElbowJntFK") ($modCore + "_WristJntFK");
			group -n ($modCore + "_ElbowJntFKGrp1") ($modCore + "_ElbowJntFK");
			group -n ($modCore + "_ElbowJntFKGrp2") ($modCore + "_ElbowJntFKGrp1");
			$elbowLocation = `xform -q -ws -t ($modCore + "_ElbowJnt")`;
			move $elbowLocation[0] $elbowLocation[1] $elbowLocation[2] ($modCore + "_ElbowJntFKGrp1.scalePivot") ($modCore + "_ElbowJntFKGrp1.rotatePivot") ;
			move $elbowLocation[0] $elbowLocation[1] $elbowLocation[2] ($modCore + "_ElbowJntFKGrp2.scalePivot") ($modCore + "_ElbowJntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_ElbowFKCtrl") ($modCore + "_ElbowJntFKGrp1");
			parentConstraint -mo ($modCore + "_ShoulderJntFK") ($modCore + "_ElbowJntFKGrp2");
		}
		else
		{
			parent -w ($modCore + "_Elbow1JntFK") ($modCore + "_Elbow2JntFK") ($modCore + "_WristJntFK");
			
			group -n ($modCore + "_Elbow1JntFKGrp1") ($modCore + "_Elbow1JntFK");
			group -n ($modCore + "_Elbow1JntFKGrp2") ($modCore + "_Elbow1JntFKGrp1");
			$elbowLocation = `xform -q -ws -t ($modCore + "_Elbow1Jnt")`;
			move $elbowLocation[0] $elbowLocation[1] $elbowLocation[2] ($modCore + "_Elbow1JntFKGrp2.scalePivot") ($modCore + "_Elbow1JntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_Elbow1FKCtrl") ($modCore + "_Elbow1JntFKGrp1");
			parentConstraint -mo ($modCore + "_ShoulderJntFK") ($modCore + "_Elbow1JntFKGrp2");
	
			group -n ($modCore + "_Elbow2JntFKGrp1") ($modCore + "_Elbow2JntFK");
			group -n ($modCore + "_Elbow2JntFKGrp2") ($modCore + "_Elbow2JntFKGrp1");
			$elbowLocation = `xform -q -ws -t ($modCore + "_Elbow2Jnt")`;
			move $elbowLocation[0] $elbowLocation[1] $elbowLocation[2] ($modCore + "_Elbow1JntFKGrp2.scalePivot") ($modCore + "_Elbow1JntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_Elbow2FKCtrl") ($modCore + "_Elbow2JntFKGrp1");
			parentConstraint -mo ($modCore + "_Elbow1JntFK") ($modCore + "_Elbow2JntFKGrp2");
		}
	
		//IK CONTROLS///////////////////////////////////////////////////////////////		
		circle -n ($modCore + "_WristIKCtrl") -nr 0 1 0 -sw 180 -r 1 -ch 0;
		circle -n ($modCore + "_WristIKCtrl2") -nr 0 1 0 -sw 180 -r 1 -ch 0;
		rotate -r 0 0 -90 ($modCore + "_WristIKCtrl2");
		circle -n ($modCore + "_WristIKCtrl3") -nr 0 1 0 -sw 90 -r 1 -ch 0;
		rotate -r 90 0 0 ($modCore + "_WristIKCtrl3");
		curve -n ($modCore + "_WristIKCtrl4") -d 1 -p 0 0 1 -p 0 0 -1 -k 0 -k 1 ;
		rename `listRelatives -c ($modCore + "_WristIKCtrl4")` ($modCore + "_WristIKCtrl4Shape");
		curve -n ($modCore + "_WristIKCtrl5") -d 1 -p 0 1 0 -p 0 0 0 -p -1 0 0 -k 0 -k 1 -k 2 ;
		rename `listRelatives -c ($modCore + "_WristIKCtrl5")` ($modCore + "_WristIKCtrl5Shape");
		makeIdentity -apply true -r 1 ($modCore + "_WristIKCtrl2") ($modCore + "_WristIKCtrl3") ($modCore + "_WristIKCtrl4") ($modCore + "_WristIKCtrl5");
		parent -r -s  ($modCore + "_WristIKCtrl2Shape") ($modCore + "_WristIKCtrl3Shape") ($modCore + "_WristIKCtrl4Shape") ($modCore + "_WristIKCtrl5Shape") ($modCore + "_WristIKCtrl");
		delete ($modCore + "_WristIKCtrl2") ($modCore + "_WristIKCtrl3") ($modCore + "_WristIKCtrl4") ($modCore + "_WristIKCtrl5");
		if ($crntSide == "left")
		{
			rotate -r -ws 0 180 0 ($modCore + "_WristIKCtrl");
		}
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_WristIKCtrl"); 
		
		//SCALE CONTROL
		spaceLocator -n ($modCore + "_armLengthAimLctr");
		spaceLocator -n ($modCore + "_armLengthTargetLctr");
		parent ($modCore + "_armLengthTargetLctr") ($modCore + "_armLengthAimLctr");
		pointConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_armLengthAimLctr");
		aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_armLengthAimLctr");
		pointConstraint ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_armLengthTargetLctr");
		$armLength = `getAttr ($modCore + "_armLengthTargetLctr.tx")`;
		scale -r ($armLength/4) ($armLength/4) ($armLength/4) ($modCore + "_WristIKCtrl");
		makeIdentity -apply true -s 1 ($modCore + "_WristIKCtrl");
		delete ($modCore + "_armLengthAimLctr");
		
		group -n ($modCore + "_WristIKCtrlGrp") ($modCore + "_WristIKCtrl"); xform -os -piv 0 0 0;
		delete `parentConstraint ($modCore + "_WristJnt") ($modCore + "_WristIKCtrlGrp")`;
		
	
		//ELBOW IK CONTROL
		curve -n ($modCore + "_ElbowIKCtrl") -d 1 -p 0 -5 0 -p -2 -3 0 -p -1 -3 0 -p -1 -1 0 -p -3 -1 0 -p -3 -2 0
		-p -5 0 0 -p -3 2 0 -p -3 1 0 -p -1 1 0 -p -1 3 0 -p -2 3 0 -p 0 5 0 -p 2 3 0
		-p 1 3 0 -p 1 1 0 -p 3 1 0 -p 3 2 0 -p 5 0 0 -p 3 -2 0 -p 3 -1 0 -p 1 -1 0	
		-p 1 -3 0 -p 2 -3 0 -p 0 -5 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9
		-k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22
		-k 23 -k 24 ;
		rename `listRelatives -c ($modCore + "_ElbowIKCtrl")` ($modCore + "_ElbowIKCtrlShape");
		
		move -r 0 0 0.95 ($modCore + "_ElbowIKCtrl.cv[12]")  ($modCore + "_ElbowIKCtrl.cv[0]") ($modCore + "_ElbowIKCtrl.cv[24]") ($modCore + "_ElbowIKCtrl.cv[18]") ($modCore + "_ElbowIKCtrl.cv[6]") ;
		move -r 0 0 -0.65 ($modCore + "_ElbowIKCtrl.cv[3]") ($modCore + "_ElbowIKCtrl.cv[9]") ($modCore + "_ElbowIKCtrl.cv[15]") ($modCore + "_ElbowIKCtrl.cv[21]") ;
		group -n ($modCore + "_ElbowIKCtrlGrp") ($modCore + "_ElbowIKCtrl"); xform -os -piv 0 0 0;
		
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Elbow") ($modCore + "_ElbowIKCtrlGrp")`;
			setAttr (($modCore + "_ElbowIKCtrl.scale"), ($ArmLength / 14), ($ArmLength / 14), ($ArmLength / 14));
			setAttr ($modCore + "_ElbowIKCtrl.tz") ($ArmLength * -2);
			
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_ElbowIKCtrl");
		}
		else
		{
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Elbow1") ($modCore + "_ElbowIKCtrlGrp")`;
			setAttr (($modCore + "_ElbowIKCtrl.scale"), ($ArmLength / 14), ($ArmLength / 14), ($ArmLength / 14));
			setAttr ($modCore + "_ElbowIKCtrl.tz") ($ArmLength * -2);
			
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_ElbowIKCtrl");
		}
		
		//LOWER ARM CONTROL
		if (`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			curve -n ($modCore + "_LowerArmIKCtrl") -d 1 -p -1 0 4 -p -4 0 4 -p -3 0 5 -p -2 0 6 -p -1 0 7 -p 0 0 8 -p 1 0 7 -p 2 0 6 -p 3 0 5 -p 4 0 4 -p 1 0 4 -p 1 0 3 -p 1 0 2 -p 1 0 1 -p 1 0 0 -p 1 0 -1 -p 1 0 -2 -p 1 0 -3 -p 1 0 -4 -p 4 0 -4 -p 3 0 -5 -p 2 0 -6 -p 1 0 -7 -p 0 0 -8 -p -1 0 -7 -p -2 0 -6 -p -3 0 -5 -p -4 0 -4 -p -1 0 -4 -p -1 0 -3 -p -1 0 -2 -p -1 0 -1 -p -1 0 0 -p -1 0 1 -p -1 0 2 -p -1 0 3 -p -1 0 4 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 28 -k 29 -k 30 -k 31 -k 32 -k 33 -k 34 -k 35 -k 36 ;
			rename `listRelatives -c ($modCore + "_LowerArmIKCtrl")` ($modCore + "_LowerArmIKCtrlShape");
			nonLinear -type bend -lowBound -1 -highBound 1 -curvature 0.6;
			$bend = `ls -sl`;
			rename $bend ($modCore + "_LowerArmIKCBend");
			rotate -a -os -90 0 -90 ($modCore + "_LowerArmIKCBend");
	
			rotate 0 0 90 ($modCore + "_LowerArmIKCtrl");
			setAttr (($modCore + "_LowerArmIKCtrl.scale"), ($ArmLength/14), ($ArmLength/14), ($ArmLength/14));
			makeIdentity -apply true -r 1 -s 1 ($modCore + "_LowerArmIKCtrl");
	
			group -n ($modCore + "_LowerArmIKCtrlGrp") ($modCore + "_LowerArmIKCtrl");
			group -n ($modCore + "_LowerArmIKCtrlGrp2") ($modCore + "_LowerArmIKCtrlGrp");
			parent ($modCore + "_LowerArmIKCtrlGrp2") ($modCore + "_ScaleGrp");
			setAttr ($modCore + "_LowerArmIKCtrlGrp.rotateOrder") 1;
			setAttr ($modCore + "_LowerArmIKCtrlGrp2.rotateOrder") 1;
	
			spaceLocator -n ($modCore + "_lowerArmIKLctr");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_lowerArmIKLctr")`;
			parent ($modCore + "_lowerArmIKLctr") ($modCore + "_ShoulderFKCtrl");
			setAttr ($modCore + "_lowerArmIKLctr.v") 0;
			
			delete `pointConstraint ($modCore + "_WristIKCtrl") ($modCore + "_LowerArmIKCtrlGrp2")`;
			//ALIGN GROUP
			delete `aimConstraint -offset 0 0 0 -aimVector ($multiplier * -1) 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow2")
			("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_LowerArmIKCtrlGrp2")`;
			//AIM CONSTRAIN GROUP WITH OFFSET
			aimConstraint -offset 0 0 0 -aimVector ($multiplier * -1) 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + "_WristIKCtrl")
			($modCore + "_lowerArmIKLctr") ($modCore + "_LowerArmIKCtrlGrp2");
			delete `aimConstraint -offset 0 0 0 -aimVector ($multiplier * -1) 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject ("RRM_" + $prfx + $core + "_Elbow2")
			("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_LowerArmIKCtrlGrp")`;
			pointConstraint -mo ($modCore + "_WristIKCtrl") ($modCore + "_LowerArmIKCtrlGrp2");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Elbow2") ($modCore + "_LowerArmIKCtrl")`;
			$WristPos = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Wrist")`;
			move -a $WristPos[0] $WristPos[1] $WristPos[2] ($modCore + "_LowerArmIKCtrl.scalePivot") ($modCore + "_LowerArmIKCtrl.rotatePivot") ;
			makeIdentity -apply true -t 1 -s 1 ($modCore + "_LowerArmIKCtrl");
			
			//ADD ORIENTATION ATTRIBUTE FOR LOWER LEG IKCtrl ORIENTATION
			spaceLocator -n ($modCore + "_LowerArmIKCtrlGrp2_LctrOffset");
			delete `parentConstraint ($modCore + "_LowerArmIKCtrlGrp2") ($modCore + "_LowerArmIKCtrlGrp2_LctrOffset")`;
			parentConstraint -mo ($modCore + "_WristIKCtrl") ($modCore + "_LowerArmIKCtrlGrp2_LctrOffset");
			
			orientConstraint -mo ($modCore + "_LowerArmIKCtrlGrp2") ($modCore + "_LowerArmIKCtrlGrp2_LctrOffset") ($modCore + "_LowerArmIKCtrlGrp");
			parent ($modCore + "_LowerArmIKCtrlGrp2_LctrOffset") ($modCore + "_WristIKCtrl");
			
			addAttr -ln "autoOrient" -at double -min 0 -max 1 -dv 1 ($modCore + "_LowerArmIKCtrl");
			setAttr -e-keyable 1 ($modCore + "_LowerArmIKCtrl.autoOrient");
			connectAttr -f ($modCore + "_LowerArmIKCtrl.autoOrient") ($modCore + "_LowerArmIKCtrlGrp_orientConstraint1." + $modCore + "_LowerArmIKCtrlGrp2W0");
			
			shadingNode -asUtility reverse -n ($modCore + "_LowerArmIKCtrl_Reverse");
			connectAttr -f ($modCore + "_LowerArmIKCtrl.autoOrient") ($modCore + "_LowerArmIKCtrl_Reverse.inputX");
			connectAttr -f ($modCore + "_LowerArmIKCtrl_Reverse.outputX") ($modCore + "_LowerArmIKCtrlGrp_orientConstraint1." + $modCore + "_LowerArmIKCtrlGrp2_LctrOffsetW1");
			setAttr ($modCore + "_LowerArmIKCtrlGrp2_LctrOffset.v") 0;
			
			spaceLocator -n ($modCore + "_LowerElbowIKOffsetLctr");
			delete `pointConstraint ($modCore + "_Elbow2Jnt") ($modCore + "_LowerElbowIKOffsetLctr")`;
			
		}
	
		//ELBOW AIM LOCATORS
		spaceLocator -n ($modCore + "_ElbowIKCtrl_TargetLctr");
		spaceLocator -n ($modCore + "_ElbowIKCtrl_ShoulderLctr");
		spaceLocator -n ($modCore + "_ElbowIKCtrl_WristLctr");
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Shoulder") ($modCore + "_ElbowIKCtrl_ShoulderLctr")`;
		parentConstraint -mo ($modCore + "_ClavicleCtrl") ($modCore + "_ElbowIKCtrl_ShoulderLctr");
		
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Wrist") ($modCore + "_ElbowIKCtrl_WristLctr")`;
		parentConstraint -mo ($modCore + "_WristIKCtrl")  ($modCore + "_ElbowIKCtrl_WristLctr");
		
		parent ($modCore + "_ElbowIKCtrl_ShoulderLctr") ($modCore + "_ElbowIKCtrl_WristLctr") ($modCore + "_ScaleGrp");
		setAttr ($modCore + "_ElbowIKCtrl_ShoulderLctr.v") 0;
		setAttr ($modCore + "_ElbowIKCtrl_WristLctr.v") 0;
			
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{	
			delete `pointConstraint ($modCore + "_ElbowJnt") ($modCore + "_ElbowIKCtrl_TargetLctr")`;
			pointConstraint -mo ($modCore + "_ElbowIKCtrl_ShoulderLctr") ($modCore + "_ElbowIKCtrl_WristLctr") ($modCore + "_ElbowIKCtrl_TargetLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			($modCore + "_ElbowIKCtrl_TargetLctr") ($modCore + "_ElbowIKCtrl");
		}
		else
		{
			pointConstraint ($modCore + "_ElbowIKCtrl_ShoulderLctr") ($modCore + "_LowerElbowIKOffsetLctr") ($modCore + "_ElbowIKCtrl_TargetLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			($modCore + "_ElbowIKCtrl_TargetLctr") ($modCore + "_ElbowIKCtrl");
		}
	
	
		//IK SCALE
		
		//CREATE DUMMY WRIST JOINT
		select ($modCore + "_WristJntIK");
		duplicate -n ($modCore + "_WristJntIKDummy");
		parent -w;
		group -n ($modCore + "_WristJntIKDummyGrp1");
		group -n ($modCore + "_WristJntIKDummyGrp2");
		
		move $elbowLocation[0] $elbowLocation[1] $elbowLocation[2] ($modCore + "_WristJntIKDummyGrp2.scalePivot") ($modCore + "_WristJntIKDummyGrp2.rotatePivot") ;
		pointConstraint ($modCore + "_WristJntIK") ($modCore + "_WristJntIKDummyGrp1");
		parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z ($modCore + "_WristIKCtrl") ($modCore + "_WristJntIKDummy");
		setAttr ($modCore + "_WristJntIKDummy_parentConstraint1.interpType") 2;
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			parentConstraint -mo ($modCore + "_ElbowJntIK") ($modCore + "_WristJntIKDummyGrp2");
		}
		else
		{
			parentConstraint -mo ($modCore + "_Elbow2JntIK") ($modCore + "_WristJntIKDummyGrp2");
		}
		
		//NODES
		spaceLocator -n ($modCore + "_ArmLengthOriginLctr");
		pointConstraint ($modCore + "_ShoulderJntIK") ($modCore + "_ArmLengthOriginLctr");
		
		spaceLocator -n ($modCore + "_ArmLengthEndLctr");
		parent ($modCore + "_ArmLengthEndLctr") ($modCore + "_ArmLengthOriginLctr");
	
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			pointConstraint ($modCore + "_WristIKCtrl") ($modCore + "_ArmLengthEndLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_WristIKCtrl") ($modCore + "_ArmLengthOriginLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_LowerArmIKCLctr");
			setAttr ($modCore + "_LowerArmIKCLctr.v") 0;
			delete `parentConstraint ($modCore + "_Elbow2Jnt") ($modCore + "_LowerArmIKCLctr")`;
			parent  ($modCore + "_LowerArmIKCLctr") ($modCore + "_LowerArmIKCtrl");
			pointConstraint ($modCore + "_LowerArmIKCLctr") ($modCore + "_ArmLengthEndLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_LowerElbowIKOffsetLctr") ($modCore + "_ArmLengthOriginLctr");
		}
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ArmLength_MD");
		setAttr ($modCore + "_ArmLength_MD.operation") 2;
		connectAttr -f ($modCore + "_ArmLengthEndLctr.translateX") ($modCore + "_ArmLength_MD.input1X");
		setAttr ($modCore + "_ArmLength_MD.input2X") ($ArmLength*2);
		
		shadingNode -asUtility condition -n ($modCore + "_ArmLength_Condition");
		connectAttr -f ($modCore + "_ArmLength_MD.outputX") ($modCore + "_ArmLength_Condition.firstTerm");
		setAttr ($modCore + "_ArmLength_Condition.secondTerm") 1;
		setAttr ($modCore + "_ArmLength_Condition.operation") 2;
		connectAttr -f ($modCore + "_ArmLength_MD.outputX") ($modCore + "_ArmLength_Condition.colorIfTrueR");
		
		shadingNode -asUtility blendColors -n ($modCore + "_ArmLength_Blnd");
		connectAttr -f ($modCore + "_ArmLength_Condition.outColorR") ($modCore + "_ArmLength_Blnd.color1R");
		setAttr ($modCore + "_ArmLength_Blnd.color2") -type double3 1 0 1 ;
		
		//ADD STRETCH TO IK WRIST CONTROL
		addAttr -ln "stretch"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_WristIKCtrl");

		//ARM IK LOCK
		
		//ARM IK LOCK LOCATORS
		spaceLocator -n ($modCore + "_ShoulderIKLockLctr");
		spaceLocator -n ($modCore + "_ElbowIKLockLctr");
		spaceLocator -n ($modCore + "_WristIKLockLctr");
		parent ($modCore + "_ElbowIKLockLctr") ($modCore + "_ShoulderIKLockLctr");
		parent ($modCore + "_WristIKLockLctr") ($modCore + "_ElbowIKLockLctr");
		pointConstraint ($modCore + "_ShoulderJntIK") ($modCore + "_ShoulderIKLockLctr");
		aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_ElbowIKCtrl") ($modCore + "_ShoulderIKLockLctr");
		pointConstraint ($modCore + "_ElbowIKCtrl") ($modCore + "_ElbowIKLockLctr");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_WristIKCtrl") ($modCore + "_ElbowIKLockLctr");
			pointConstraint ($modCore + "_WristIKCtrl") ($modCore + "_WristIKLockLctr");

			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_ShoulderLockLength_MD");
			setAttr ($modCore + "_ShoulderLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_ElbowIKLockLctr.translateX") ($modCore + "_ShoulderLockLength_MD.input1X");
			setAttr ($modCore + "_ShoulderLockLength_MD.input2X") $elbowLength[0];
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_elbowLockLength_MD");
			setAttr ($modCore + "_elbowLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_WristIKLockLctr.translateX") ($modCore + "_elbowLockLength_MD.input1X");
			setAttr ($modCore + "_elbowLockLength_MD.input2X") $WristLength[0];
			
			shadingNode -asUtility blendColors -n ($modCore + "_ShoulderLock_Blnd");
			connectAttr -f ($modCore + "_ShoulderLockLength_MD.outputX") ($modCore + "_ShoulderLock_Blnd.color1R");
			connectAttr -f ($modCore + "_ArmLength_Blnd.outputR") ($modCore + "_ShoulderLock_Blnd.color2R");
			
			shadingNode -asUtility blendColors -n ($modCore + "_elbowLock_Blnd");
			connectAttr -f ($modCore + "_elbowLockLength_MD.outputX") ($modCore + "_elbowLock_Blnd.color1R");
			connectAttr -f ($modCore + "_ArmLength_Blnd.outputR") ($modCore + "_elbowLock_Blnd.color2R");
		}
		else
		{
			parent ($modCore + "_LowerElbowIKOffsetLctr") ($modCore + "_ShoulderIKLockLctr");
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore + "_LowerArmIKCtrl") ($modCore + "_LowerElbowIKOffsetLctr");
			
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_LowerElbowIKOffsetLctr") ($modCore + "_ElbowIKLockLctr");
			pointConstraint ($modCore + "_LowerElbowIKOffsetLctr") ($modCore + "_WristIKLockLctr");

			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_ShoulderLockLength_MD");
			setAttr ($modCore + "_ShoulderLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_ElbowIKLockLctr.translateX") ($modCore + "_ShoulderLockLength_MD.input1X");
			setAttr ($modCore + "_ShoulderLockLength_MD.input2X") $elbow1Length[0];
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_elbowLockLength_MD");
			setAttr ($modCore + "_elbowLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_WristIKLockLctr.translateX") ($modCore + "_elbowLockLength_MD.input1X");
			setAttr ($modCore + "_elbowLockLength_MD.input2X") $elbow2Length[0];
			
			shadingNode -asUtility blendColors -n ($modCore + "_ShoulderLock_Blnd");
			connectAttr -f ($modCore + "_ShoulderLockLength_MD.outputX") ($modCore + "_ShoulderLock_Blnd.color1R");
			connectAttr -f ($modCore + "_ArmLength_Blnd.outputR") ($modCore + "_ShoulderLock_Blnd.color2R");
			
			shadingNode -asUtility blendColors -n ($modCore + "_elbowLock_Blnd");
			connectAttr -f ($modCore + "_elbowLockLength_MD.outputX") ($modCore + "_elbowLock_Blnd.color1R");
			connectAttr -f ($modCore + "_ArmLength_Blnd.outputR") ($modCore + "_elbowLock_Blnd.color2R");
			
			//AUTO STRETCH ON LOWER ARM IK CONTROL
			addAttr -ln "lowerScale" -at double -min 0.01 -dv 1 ($modCore + "_LowerArmIKCtrl");
			setAttr -e-keyable 1 ($modCore + "_LowerArmIKCtrl.lowerScale");
			
			//GET ARM LENGTH
			
			$elbow1Length2 = `getAttr ($modCore + "_Elbow1Jnt.tx")`;
			$elbow2Length2 = `getAttr ($modCore + "_Elbow2Jnt.tx")`;
			$WristLength2 = `getAttr ($modCore + "_WristJntDummy.tx")`;
			$FullArmLength = ($elbow1Length2 + $elbow2Length2 + $WristLength2);
			
			//ARM LENGTH LOCATORS
			spaceLocator -n ($modCore + "_FullArmLengthAimLctr");
			spaceLocator -n ($modCore + "_FullArmLengthEndLctr");
			parent ($modCore + "_FullArmLengthEndLctr") ($modCore + "_FullArmLengthAimLctr");
			parent ($modCore + "_FullArmLengthAimLctr") ($modCore + "_ScaleGrp");
			pointConstraint ($modCore + "_ShoulderJntIK") ($modCore + "_FullArmLengthAimLctr");
			pointConstraint ($modCore + "_WristIKCtrl")   ($modCore + "_FullArmLengthEndLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_WristIKCtrl") ($modCore + "_FullArmLengthAimLctr");

			shadingNode -asUtility multiplyDivide -n ($modCore + "_FullArmLength_MD");
			setAttr ($modCore + "_FullArmLength_MD.operation") 2;
			connectAttr -force ($modCore + "_FullArmLengthEndLctr.translateX") ($modCore + "_FullArmLength_MD.input1X");
			setAttr ($modCore + "_FullArmLength_MD.input2X") $FullArmLength;
			
			shadingNode -asUtility condition -n ($modCore + "_FullArmLength_Condition");
			connectAttr -force ($modCore + "_FullArmLength_MD.outputX") ($modCore + "_FullArmLength_Condition.firstTerm");
			setAttr ($modCore + "_FullArmLength_Condition.secondTerm") 1;
			setAttr ($modCore + "_FullArmLength_Condition.operation") 2;
			connectAttr -force ($modCore + "_FullArmLength_MD.outputX") ($modCore + "_FullArmLength_Condition.colorIfTrueR");
			
			shadingNode -asUtility blendColors -n ($modCore + "_FullArmLength_Blnd");
			connectAttr -force ($modCore + "_WristIKCtrl.stretch") ($modCore + "_FullArmLength_Blnd.blender");
			connectAttr -force ($modCore + "_FullArmLength_Condition.outColorR") ($modCore + "_FullArmLength_Blnd.color1R");
			setAttr ($modCore + "_FullArmLength_Blnd.color2R") 1;
			
			setAttr ($modCore + "_FullArmLengthAimLctr.v") 0;

			
			//MULTIPLY STRETCH WITH LOWER SCALE
			shadingNode -asUtility multiplyDivide -n ($modCore + "_FullArmLength2_MD");
			connectAttr -force ($modCore + "_LowerArmIKCtrl.lowerScale") ($modCore + "_FullArmLength2_MD.input1X");
			connectAttr -force ($modCore + "_FullArmLength_Blnd.outputR") ($modCore + "_FullArmLength2_MD.input2X");
			connectAttr -force ($modCore + "_FullArmLength2_MD.outputX") ($modCore + "_LowerArmIKCtrl.scaleX");
			connectAttr -force ($modCore + "_FullArmLength2_MD.outputX") ($modCore + "_Elbow2JntIK.scaleX");
		}
		
	
		//ADD STRETCH TO IK WRIST CONTROL
		setAttr -e-k true ($modCore + "_WristIKCtrl.stretch");
		connectAttr -f ($modCore + "_WristIKCtrl.stretch") ($modCore + "_ArmLength_Blnd.blender");
		
		//ADD ELBOW LOCK TO IK WRIST CONTROL
		addAttr -ln "elbowLock"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_WristIKCtrl");
		setAttr -e-k true ($modCore + "_WristIKCtrl.elbowLock");
		connectAttr -f ($modCore + "_WristIKCtrl.elbowLock") ($modCore + "_ShoulderLock_Blnd.blender");
		connectAttr -f ($modCore + "_WristIKCtrl.elbowLock") ($modCore + "_elbowLock_Blnd.blender");
		
		//ADD ARM SCALE
		addAttr -ln "armScale"  -at double  -min 0.01 -dv 1 ($modCore + "_WristIKCtrl");
		setAttr -e-k true ($modCore + "_WristIKCtrl.armScale");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ShoulderScale_MD");
		connectAttr -force ($modCore + "_ShoulderLock_Blnd.outputR") ($modCore + "_ShoulderScale_MD.input1X");
		connectAttr -force ($modCore + "_WristIKCtrl.armScale") ($modCore + "_ShoulderScale_MD.input2X");
		connectAttr -force ($modCore + "_ShoulderScale_MD.outputX") ($modCore + "_ShoulderJntIK.scaleX");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ElbowScale_MD");
		connectAttr -force ($modCore + "_elbowLock_Blnd.outputR") ($modCore + "_ElbowScale_MD.input1X");
		connectAttr -force ($modCore + "_WristIKCtrl.armScale") ($modCore + "_ElbowScale_MD.input2X");
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			connectAttr -force ($modCore + "_ElbowScale_MD.outputX") ($modCore + "_ElbowJntIK.scaleX");
		}
		else
		{
			connectAttr -force ($modCore + "_ElbowScale_MD.outputX") ($modCore + "_Elbow1JntIK.scaleX");
		}
		
	
		//////////////////////////////////HAND IKFK SWITCH CONTROL///////////////////////////////////////////
		curve -n ($modCore + "_SwitchCtrl") -d 1 -p 0 0 0 -p -2 0 -2 -p -1 0 -2 -p -1 0 -5 -p 1 0 -5 -p 1 0 -2
		-p 2 0 -2 -p 0 0 0 -p 0 2 -2 -p 0 1 -2 -p 0 1 -5 -p 0 -1 -5 -p 0 -1 -2
		-p 0 -2 -2 -p 0 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10
		-k 11 -k 12 -k 13 -k 14 ;

		rename `listRelatives -c ($modCore + "_SwitchCtrl")` ($modCore + "_SwitchCtrlShape");
		
		move -r -os -wd 0 0 -8 ($modCore + "_SwitchCtrl");
		group -n ($modCore + "_SwitchCtrlGrp") ($modCore + "_SwitchCtrl"); xform -os -piv 0 0 0;
		scale -r 0.2 0.2 0.2 ($modCore + "_SwitchCtrlGrp");
		makeIdentity -apply true -t 0 -r 1 -s 1 ($modCore + "_SwitchCtrlGrp");
		delete `pointConstraint ($modCore + "_WristJnt") ($modCore + "_SwitchCtrlGrp")`;
		parent ($modCore + "_SwitchCtrlGrp") ($modCore + "_WristIKCtrlGrp");
		makeIdentity -apply false -r 1 ($modCore + "_SwitchCtrlGrp");
		parent -w ($modCore + "_SwitchCtrlGrp");
		
		setAttr (($modCore + "_SwitchCtrlGrp.scale"), ($ArmLength / 3.5), ($ArmLength / 3.5), ($ArmLength / 3.5));
		
		addAttr -ln "switchIkFk"  -at double  -min 0 -max 1 -dv 1 ($modCore + "_SwitchCtrl");
		setAttr -e-k true ($modCore + "_SwitchCtrl.switchIkFk");
		addAttr -ln "autoVolume"  -at double  -min 0 -max 1 -dv 1 ($modCore + "_SwitchCtrl");
		setAttr -e-k true ($modCore + "_SwitchCtrl.autoVolume");
		setAttr ($modCore + "_SwitchCtrl.autoVolume") 1;
		
		xform -cp ($modCore + "_SwitchCtrl");
		
		parentConstraint -mo ($modCore + "_WristJnt") ($modCore + "_SwitchCtrlGrp");
		
		//PARENT ORIENT
		$parentOrient = ($modCore + "_SwitchCtrl");
		RRM_ParentOrient_V1($modCore, $modName, $modAttachNode, $parentOrient); 	
	
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////CONNECT CONTROLS///////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		
		////////////////////////////////////SIDE////////////////////////////////////
		//ARM
		parentConstraint -mo ($modCore + "_ScaleGrp") ($modCore + "_ClavicleCtrlGrp");
		
		//FK
		parentConstraint -mo ($modCore + "_ClavicleCtrl") ($modCore + "_ClavicleJnt");
		parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore + "_ClavicleCtrl") ($modCore + "_ShoulderFKCtrlGrp");
		parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z
		($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ClavicleCtrl") ($modName + "_MAINCtrl") ($modCore + "_ShoulderFKCtrlGrp2");

		setAttr ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1.interpType") 2;
		
		//SHOULDER ORIENT
		addAttr -ln "shoulderOrient"  -at double  -min 0 -max 1 -dv 1 ($modCore + "_ShoulderFKCtrl");
		setAttr -e-k true ($modCore + "_ShoulderFKCtrl.shoulderOrient");
	
		setAttr ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1." + $modName + "_MAINCtrlW2") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_ShoulderFKCtrl.shoulderOrient") ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1." + $modName + "_MAINCtrlW2");
		setAttr ($modCore + "_ShoulderFKCtrl.shoulderOrient") 0;
		setAttr ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1." + $modName + "_MAINCtrlW2") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_ShoulderFKCtrl.shoulderOrient") ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1." + $modName + "_MAINCtrlW2");
		setAttr ($modCore + "_ShoulderFKCtrl.shoulderOrient") 1;
		
		
		
		//CHEST & CLAVICLE INFLUENCE
		addAttr -ln "clavicleInfluence"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_ShoulderFKCtrl");
		setAttr -e-keyable 1 ($modCore + "_ShoulderFKCtrl.clavicleInfluence");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ShoulderFK_Inf_MD");
		connectAttr -force ($modCore + "_ShoulderFKCtrl.clavicleInfluence") ($modCore + "_ShoulderFK_Inf_MD.input1Y");
		setAttr ($modCore + "_ShoulderFK_Inf_MD.input1X") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_ShoulderFKCtrl.clavicleInfluence") ($modCore + "_ShoulderFK_Inf_MD.input1X");
		setAttr ($modCore + "_ShoulderFKCtrl.clavicleInfluence") 1;
		setAttr ($modCore + "_ShoulderFK_Inf_MD.input1X") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_ShoulderFKCtrl.clavicleInfluence") ($modCore + "_ShoulderFK_Inf_MD.input1X");
		setAttr ($modCore + "_ShoulderFKCtrl.clavicleInfluence") 0;
		
		connectAttr -force  ($modCore + "_ShoulderFKCtrl.shoulderOrient") ($modCore + "_ShoulderFK_Inf_MD.input2X");
		connectAttr -force  ($modCore + "_ShoulderFKCtrl.shoulderOrient") ($modCore + "_ShoulderFK_Inf_MD.input2Y");
		connectAttr -force  ($modCore + "_ShoulderFK_Inf_MD.outputX") ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW0");
		connectAttr -force  ($modCore + "_ShoulderFK_Inf_MD.outputY") ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1." + $modCore + "_ClavicleCtrlW1");
		
		//selectKey -k -f 0 -f 1 ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1_" + $modName + "_MAINCtrlW2") ;
		//selectKey -add -k -f 0 -f 1 ($modCore + "_ShoulderFK_Inf_MD_input1X") ;
		keyTangent -itt spline -ott spline ($modCore + "_ShoulderFKCtrlGrp2_parentConstraint1_" + $modName + "_MAINCtrlW2") ($modCore + "_ShoulderFK_Inf_MD_input1X");

		parentConstraint -mo ($modCore + "_ShoulderFKCtrl") ($modCore + "_ShoulderJntFK");
		pointConstraint  -mo ($modCore + "_ShoulderFKCtrl") ($modCore + "_ShoulderJnt");
		pointConstraint  -mo ($modCore + "_ShoulderFKCtrl") ($modCore + "_ShoulderJntIK");
	
		connectAttr -f ($modCore + "_ShoulderFKCtrl.scaleX") ($modCore + "_ShoulderJntFK.scaleX");
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			parentConstraint -mo ($modCore + "_ShoulderFKCtrl") ($modCore + "_ElbowFKCtrlGrp");
		
			parentConstraint -mo ($modCore + "_ElbowFKCtrl") ($modCore + "_ElbowJntFK");
			parentConstraint -mo ($modCore + "_ElbowFKCtrl") ($modCore + "_WristFKCtrlGrp");
		}
		else
		{
			parentConstraint -mo ($modCore + "_ShoulderFKCtrl") ($modCore + "_Elbow1FKCtrlGrp");
		
			parentConstraint -mo ($modCore + "_Elbow1FKCtrl") ($modCore + "_Elbow1JntFK");
			parent ($modCore + "_Elbow2FKCtrlGrp") ($modCore + "_Elbow1FKCtrl");
	
			parentConstraint -mo ($modCore + "_Elbow2FKCtrl") ($modCore + "_Elbow2JntFK");
			parentConstraint -mo ($modCore + "_Elbow2FKCtrl") ($modCore + "_WristFKCtrlGrp");
		}		
			
		parentConstraint -mo ($modCore + "_WristFKCtrl") ($modCore + "_WristJntFK");
		setAttr ($modCore + "_WristJntFK_parentConstraint1.interpType") 2;
		
		//CONNECT SCALE TO FK CONTROLS
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			connectAttr -f ($modCore + "_ShoulderFKCtrl.scaleX") ($modCore + "_ElbowJntFK.scaleX");
		}
		else
		{
			connectAttr -f ($modCore + "_ShoulderFKCtrl.scaleX") ($modCore + "_Elbow1JntFK.scaleX");
			connectAttr -f ($modCore + "_ShoulderFKCtrl.scaleX") ($modCore + "_Elbow2JntFK.scaleX");
		}
	
		//IK
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{	
			select ($modCore + "_ShoulderJntIK.rotatePivot") ($modCore + "_WristJntIK.rotatePivot") ;
			ikHandle -n ($modCore + "_ArmIKHandle") -sol ikRPsolver;
			parent ($modCore + "_ArmIKHandle") ($modCore + "_WristIKCtrl");
		}
		else
		{
			select ($modCore + "_Elbow2JntIK.rotatePivot") ($modCore + "_WristJntIK.rotatePivot");
			ikHandle -n ($modCore + "_LowerArmIKHandle") -sol ikSCsolver;
			parentConstraint -mo ($modCore + "_WristIKCtrl") ($modCore + "_LowerArmIKHandle");
			setAttr ($modCore + "_LowerArmIKHandle.v") 0;
	
			select ($modCore + "_ShoulderJntIK.rotatePivot") ($modCore + "_Elbow2JntIK.rotatePivot") ;
			ikHandle -n ($modCore + "_ArmIKHandle") -sol ikRPsolver;
			parent ($modCore + "_ArmIKHandle") ($modCore + "_LowerArmIKCtrl");
			
		}
		poleVectorConstraint ($modCore + "_ElbowIKCtrl") ($modCore + "_ArmIKHandle") ;
		parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z -weight 1 ($modCore + "_WristIKCtrl") ($modCore + "_WristJntIK");
		setAttr ($modCore + "_WristJntIK_parentConstraint1.interpType") 2;
	
		//CHECK POLE VECTOR
		if (`objExists ($modCore + "_Elbow1Jnt")`)
		{
			$lSelectionOrient = `getAttr ($modCore + "_ShoulderJntIK.rotate")`;
			if ($lSelectionOrient[0] > 90 || $lSelectionOrient[0] < -90 || $lSelectionOrient[2] > 90 || $lSelectionOrient[2] < -90)
			{
				setAttr ($modCore + "_ArmIKHandle.twist") 180;
			}
				
		}
	
		//CONNECT IK AND FK JOINTS TO ORIGINALS
		//SHOULDER
		shadingNode -asUtility blendColors -n ($modCore + "_ShoulderJntIKFK_BlndScale");
		connectAttr -f ($modCore + "_ShoulderJntFK.scale") ($modCore + "_ShoulderJntIKFK_BlndScale.color1");
		connectAttr -f ($modCore + "_ShoulderJntIK.scale") ($modCore + "_ShoulderJntIKFK_BlndScale.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_ShoulderJntIKFK_BlndScale.blender");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_ShoulderVolume_MD");
		setAttr ($modCore + "_ShoulderVolume_MD.input1X") 1;
		setAttr ($modCore + "_ShoulderVolume_MD.operation") 2;
		connectAttr -f ($modCore + "_ShoulderJntIKFK_BlndScale.outputR") ($modCore + "_ShoulderVolume_MD.input2X");
		
		shadingNode -asUtility blendColors -n ($modCore + "_ShoulderJntIKFK_AutoBlnd");
		setAttr ($modCore + "_ShoulderJntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
		connectAttr -f ($modCore + "_ShoulderVolume_MD.outputX") ($modCore + "_ShoulderJntIKFK_AutoBlnd.color1R");
		connectAttr -f ($modCore + "_ShoulderJntIKFK_AutoBlnd.outputR") ($modCore + "_ShoulderJnt.scaleY");
		connectAttr -f ($modCore + "_ShoulderJntIKFK_AutoBlnd.outputR") ($modCore + "_ShoulderJnt.scaleZ");
		connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_ShoulderJntIKFK_AutoBlnd.blender");
		
		shadingNode -asUtility blendColors -n  ($modCore + "_ShoulderJntIKFK_BlndRotate");
		connectAttr -f ($modCore + "_ShoulderJntFK.rotate") ($modCore + "_ShoulderJntIKFK_BlndRotate.color1");
		connectAttr -f ($modCore + "_ShoulderJntIK.rotate") ($modCore + "_ShoulderJntIKFK_BlndRotate.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_ShoulderJntIKFK_BlndRotate.blender");
		
		connectAttr -f ($modCore + "_ShoulderJntIKFK_BlndScale.outputR") ($modCore + "_ShoulderJnt.scaleX");
		connectAttr -f ($modCore + "_ShoulderJntIKFK_BlndRotate.output") ($modCore + "_ShoulderJnt.rotate");
		
		
		//ELBOW
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			shadingNode -asUtility blendColors -n ($modCore + "_ElbowJntIKFK_BlndScale");
			connectAttr -f ($modCore + "_ElbowJntFK.scale") ($modCore + "_ElbowJntIKFK_BlndScale.color1");
			connectAttr -f ($modCore + "_ElbowJntIK.scale") ($modCore + "_ElbowJntIKFK_BlndScale.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_ElbowJntIKFK_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_ElbowVolume_MD");
			setAttr ($modCore + "_ElbowVolume_MD.input1X") 1;
			setAttr ($modCore + "_ElbowVolume_MD.operation") 2;
			connectAttr -f ($modCore + "_ElbowJntIKFK_BlndScale.outputR") ($modCore + "_ElbowVolume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_ElbowJntIKFK_AutoBlnd");
			setAttr ($modCore + "_ElbowJntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_ElbowVolume_MD.outputX") ($modCore + "_ElbowJntIKFK_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_ElbowJntIKFK_AutoBlnd.outputR") ($modCore + "_ElbowJnt.scaleY");
			connectAttr -f ($modCore + "_ElbowJntIKFK_AutoBlnd.outputR") ($modCore + "_ElbowJnt.scaleZ");
			connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_ElbowJntIKFK_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_ElbowJntIKFK_BlndRotate");
			connectAttr -f ($modCore + "_ElbowJntFK.rotate") ($modCore + "_ElbowJntIKFK_BlndRotate.color1");
			connectAttr -f ($modCore + "_ElbowJntIK.rotate") ($modCore + "_ElbowJntIKFK_BlndRotate.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_ElbowJntIKFK_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_ElbowJntIKFK_BlndScale.outputR") ($modCore + "_ElbowJnt.scaleX");
			connectAttr -f ($modCore + "_ElbowJntIKFK_BlndRotate.output") ($modCore + "_ElbowJnt.rotate");
		}
		else
		{
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow1JntIKFK_BlndScale");
			connectAttr -f ($modCore + "_Elbow1JntFK.scale") ($modCore + "_Elbow1JntIKFK_BlndScale.color1");
			connectAttr -f ($modCore + "_Elbow1JntIK.scale") ($modCore + "_Elbow1JntIKFK_BlndScale.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Elbow1JntIKFK_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_Elbow1Volume_MD");
			setAttr ($modCore + "_Elbow1Volume_MD.input1X") 1;
			setAttr ($modCore + "_Elbow1Volume_MD.operation") 2;
			connectAttr -f ($modCore + "_Elbow1JntIKFK_BlndScale.outputR") ($modCore + "_Elbow1Volume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow1JntIKFK_AutoBlnd");
			setAttr ($modCore + "_Elbow1JntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_Elbow1Volume_MD.outputX") ($modCore + "_Elbow1JntIKFK_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_Elbow1JntIKFK_AutoBlnd.outputR") ($modCore + "_Elbow1Jnt.scaleY");
			connectAttr -f ($modCore + "_Elbow1JntIKFK_AutoBlnd.outputR") ($modCore + "_Elbow1Jnt.scaleZ");
			connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_Elbow1JntIKFK_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow1JntIKFK_BlndRotate");
			connectAttr -f ($modCore + "_Elbow1JntFK.rotate") ($modCore + "_Elbow1JntIKFK_BlndRotate.color1");
			connectAttr -f ($modCore + "_Elbow1JntIK.rotate") ($modCore + "_Elbow1JntIKFK_BlndRotate.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Elbow1JntIKFK_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_Elbow1JntIKFK_BlndScale.outputR") ($modCore + "_Elbow1Jnt.scaleX");
			connectAttr -f ($modCore + "_Elbow1JntIKFK_BlndRotate.output") ($modCore + "_Elbow1Jnt.rotate");
	
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow2JntIKFK_BlndScale");
			connectAttr -f ($modCore + "_Elbow2JntFK.scale") ($modCore + "_Elbow2JntIKFK_BlndScale.color1");
			connectAttr -f ($modCore + "_Elbow2JntIK.scale") ($modCore + "_Elbow2JntIKFK_BlndScale.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Elbow2JntIKFK_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_Elbow2Volume_MD");
			setAttr ($modCore + "_Elbow2Volume_MD.input1X") 1;
			setAttr ($modCore + "_Elbow2Volume_MD.operation") 2;
			connectAttr -f ($modCore + "_Elbow2JntIKFK_BlndScale.outputR") ($modCore + "_Elbow2Volume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow2JntIKFK_AutoBlnd");
			setAttr ($modCore + "_Elbow2JntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_Elbow2Volume_MD.outputX") ($modCore + "_Elbow2JntIKFK_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_Elbow2JntIKFK_AutoBlnd.outputR") ($modCore + "_Elbow2Jnt.scaleY");
			connectAttr -f ($modCore + "_Elbow2JntIKFK_AutoBlnd.outputR") ($modCore + "_Elbow2Jnt.scaleZ");
			connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_Elbow2JntIKFK_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Elbow2JntIKFK_BlndRotate");
			connectAttr -f ($modCore + "_Elbow2JntFK.rotate") ($modCore + "_Elbow2JntIKFK_BlndRotate.color1");
			connectAttr -f ($modCore + "_Elbow2JntIK.rotate") ($modCore + "_Elbow2JntIKFK_BlndRotate.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Elbow2JntIKFK_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_Elbow2JntIKFK_BlndScale.outputR") ($modCore + "_Elbow2Jnt.scaleX");
			connectAttr -f ($modCore + "_Elbow2JntIKFK_BlndRotate.output") ($modCore + "_Elbow2Jnt.rotate");
		}
	
		//WRIST
		orientConstraint -mo ($modCore + "_WristJntFK") ($modCore + "_WristJntIKDummy") ($modCore + "_WristJntGrp1");
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1.interpType") 2;
		setAttr ($modCore + "_SwitchCtrl.switchIkFk") 0;
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntIKDummyW1") 0;
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntFKW0") 0;
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntIKDummyW1") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntFKW0");
		setDrivenKeyframe -currentDriver ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntIKDummyW1");
		setAttr ($modCore + "_SwitchCtrl.switchIkFk") 1;
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntFKW0") 1;
		setAttr ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntIKDummyW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntFKW0");
		setDrivenKeyframe -currentDriver ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_WristJntGrp1_orientConstraint1." + $modCore + "_WristJntIKDummyW1");
		
		shadingNode -asUtility blendColors -n ($modCore + "_WristJntIKFK_BlndScale");
		connectAttr -f ($modCore + "_WristJntFK.scale") ($modCore + "_WristJntIKFK_BlndScale.color1");
		connectAttr -f ($modCore + "_WristJntIK.scale") ($modCore + "_WristJntIKFK_BlndScale.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_WristJntIKFK_BlndScale.blender");
		
		connectAttr -f ($modCore + "_WristJntIKFK_BlndScale.output") ($modCore + "_WristJnt.scale");
		

		//ELBOWIKCtrl FOLLOW
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_WristIKCtrl") ($modCore + "_ShoulderFKCtrl") ($modCore + "_ElbowIKCtrlGrp");
		addAttr -ln "follow"  -at "enum" -en "Main:Wrist:Shoulder:Wrist and Shoulder:" ($modCore + "_ElbowIKCtrl");
		setAttr -e-keyable 1 ($modCore + "_ElbowIKCtrl.follow");
		setAttr ($modCore + "_ElbowIKCtrl.follow") 0;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_ShoulderFKCtrlW2") 0;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_ShoulderFKCtrlW2"); 
		
		setAttr ($modCore + "_ElbowIKCtrl.follow") 1;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0") 0;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_ShoulderFKCtrlW2");
		
		setAttr ($modCore + "_ElbowIKCtrl.follow") 2;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_ShoulderFKCtrlW2") 1;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_ShoulderFKCtrlW2");
		
		setAttr ($modCore + "_ElbowIKCtrl.follow") 3;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1") 1;
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_ShoulderFKCtrlW2") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_WristIKCtrlW1");
		setDrivenKeyframe -currentDriver ($modCore + "_ElbowIKCtrl.follow") ($modCore + "_ElbowIKCtrlGrp_parentConstraint1." + $modCore + "_ShoulderFKCtrlW2");
		
		setAttr ($modCore + "_ElbowIKCtrl.follow") 0;
		
		keyTangent -itt spline -ott spline ($modCore + "_WristJntGrp1_orientConstraint1_" + $modCore + "_WristJntFKW0")
		($modCore + "_WristJntGrp1_orientConstraint1_" + $modCore + "_WristJntIKDummyW1")
		($modCore + "_ElbowIKCtrlGrp_parentConstraint1_" + $modName + "_MAINCtrlW0")
		($modCore + "_ElbowIKCtrlGrp_parentConstraint1_" + $modCore + "_WristIKCtrlW1")
		($modCore + "_ElbowIKCtrlGrp_parentConstraint1_" + $modCore + "_ShoulderFKCtrlW2"); 
		
		//CONNECTOR LINE
		curve -n ($modCore + "_ElbowIKConnectorCtrl") -d 1 -p 0 0 0 -p 0 0 1 -k 0 -k 1 ;
		rename `listRelatives -c ($modCore + "_ElbowIKConnectorCtrl")` ($modCore + "_ElbowIKConnectorCtrlShape");
		delete `parentConstraint ($modCore + "_ElbowIKCtrl") ($modCore + "_ElbowIKConnectorCtrl") `;
		parent ($modCore + "_ElbowIKConnectorCtrl") ($modCore + "_ElbowIKCtrl");
		spaceLocator -n ($modCore + "_ElbowIKAimConnectorLctr");
		spaceLocator -n ($modCore + "_ElbowIKTargetConnectorLctr");
		parent ($modCore + "_ElbowIKTargetConnectorLctr") ($modCore + "_ElbowIKAimConnectorLctr");
		delete `parentConstraint ($modCore + "_ElbowIKCtrl") ($modCore + "_ElbowIKAimConnectorLctr")`;
		parent ($modCore + "_ElbowIKAimConnectorLctr") ($modCore + "_ElbowIKCtrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_ElbowIKAimConnectorLctr");
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			pointConstraint ($modCore + "_ElbowJnt") ($modCore + "_ElbowIKTargetConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_ElbowJnt") ($modCore + "_ElbowIKAimConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_ElbowJnt") ($modCore + "_ElbowIKConnectorCtrl");
		}
		else
		{
			pointConstraint  ($modCore + "_Elbow1Jnt") ($modCore + "_ElbowIKTargetConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_Elbow1Jnt") ($modCore + "_ElbowIKAimConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_Elbow1Jnt") ($modCore + "_ElbowIKConnectorCtrl");
		}
		connectAttr -f ($modCore + "_ElbowIKTargetConnectorLctr.tz") ($modCore + "_ElbowIKConnectorCtrl.sz");
		setAttr ($modCore + "_ElbowIKAimConnectorLctr.v") 0;
		
		addAttr -ln "nonControl"  -dt "string" ($modCore + "_ElbowIKConnectorCtrl");
		setAttr -e-keyable 1 ($modCore + "_ElbowIKConnectorCtrl.nonControl");
		setAttr -lock 1 ($modCore + "_ElbowIKConnectorCtrl.nonControl");
		
		//VISIBILITY TOGGLES////////////////////////////////////////////////////////////////////
	
		//ARM
		shadingNode -asUtility condition -n ($modCore + "_ArmIKViz");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_ArmIKViz.firstTerm");
		setAttr ($modCore + "_ArmIKViz.secondTerm") 0.7;
		setAttr ($modCore + "_ArmIKViz.operation") 3;
			
		connectAttr -f ($modCore + "_ArmIKViz.outColorR") ($modCore + "_ElbowIKCtrl.v");
		connectAttr -f ($modCore + "_ArmIKViz.outColorR") ($modCore + "_WristIKCtrl.v");
		if (`objExists ($modCore + "_LowerArmIKCtrl")`)
		{
			connectAttr -f ($modCore + "_ArmIKViz.outColorR") ($modCore + "_LowerArmIKCtrl.v");
			setAttr -lock 1 -keyable 0 ($modCore + "_LowerArmIKCtrl.v");
		}
		shadingNode -asUtility condition -n ($modCore + "_ArmFKViz");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_ArmFKViz.firstTerm");
		setAttr ($modCore + "_ArmFKViz.secondTerm") 0.3;
		setAttr ($modCore + "_ArmFKViz.operation") 5;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			connectAttr -f ($modCore + "_ArmFKViz.outColorR") ($modCore + "_ElbowFKCtrl.v");
		}
		else
		{
			connectAttr -f ($modCore + "_ArmFKViz.outColorR") ($modCore + "_Elbow1FKCtrl.v");
			connectAttr -f ($modCore + "_ArmFKViz.outColorR") ($modCore + "_Elbow2FKCtrl.v");
		}
		connectAttr -f ($modCore + "_ArmFKViz.outColorR") ($modCore + "_WristFKCtrl.v");
		
		//////////////////////////////////LOCK & HIDE//////////////////////////////////
	
		//JOINTS
		setAttr ($modCore + "_ShoulderJntIK.v") 0;
		setAttr ($modCore + "_ShoulderJntFK.v") 0;
		setAttr ($modCore + "_WristJntFK.v") 0;
		
		setAttr -l 1 -k 0 ($modCore + "_ShoulderJntIK.v") 0;
		setAttr -l 1 -k 0 ($modCore + "_ShoulderJntFK.v") 0;
		setAttr -l 1 -k 0 ($modCore + "_WristJntFK.v") 0;
	
	
		setAttr ($modCore + "_ArmLengthOriginLctr.v") 0;
		setAttr ($modCore + "_WristJntIKDummyGrp2.v") 0;
		setAttr ($modCore + "_WristJntFKGrp2.v") 0;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			setAttr ($modCore + "_ElbowJntFKGrp2.v") 0;
		}
		else
		{
			setAttr ($modCore + "_Elbow1JntFKGrp2.v") 0;
			setAttr ($modCore + "_Elbow2JntFKGrp2.v") 0;
		}
		
		
		setAttr ($modCore + "_ElbowIKCtrl_TargetLctr.v") 0;
		
		//CONTROLS
		setAttr -l 1 -k 0 ($modCore + "_ClavicleCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_ClavicleCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ClavicleCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ClavicleCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_ShoulderFKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ShoulderFKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ShoulderFKCtrl.v");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_ElbowFKCtrl.v");
		}
		else
		{
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow1FKCtrl.v");
			
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_Elbow2FKCtrl.v");
			
			
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_LowerArmIKCtrl.v");
			transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_LowerArmIKCtrl");
		}
		
		setAttr -l 1 -k 0 ($modCore + "_WristFKCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_WristFKCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_WristFKCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_WristFKCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKCtrl.rx");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKCtrl.ry");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKCtrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_WristIKCtrl.v");
			
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.rx");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.ry");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.v");

		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.rx");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.ry");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ElbowIKConnectorCtrl.v");
		setAttr ($modCore + "_ElbowIKConnectorCtrl.template") 1;
		
		setAttr ($modCore + "_ArmIKHandle.v") 0;
		
		
		//LOCK GROUPS
		
		/////////////////////////////////SNAP ASSETS/////////////////////////////////
		select -cl;
		//WRIST FK LOCATOR
		spaceLocator -n ($modCore + "_WristFKLctr");
		delete `parentConstraint ($modCore + "_WristIKCtrlGrp") ($modCore + "_WristFKLctr")`;
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_WristFKLctr");
		parent ($modCore + "_WristFKLctr") ($modCore + "_WristIKCtrlGrp");
		parentConstraint ($modCore + "_WristFKCtrl") ($modCore + "_WristFKLctr");
		
		//WRIST IK LOCATOR
		spaceLocator -n ($modCore + "_WristIKLctr");
		delete `parentConstraint ($modCore + "_WristFKCtrlGrp") ($modCore + "_WristIKLctr")`;
		parent ($modCore + "_WristIKLctr") ($modCore + "_WristFKCtrlGrp");
		orientConstraint -mo ($modCore + "_WristIKCtrl") ($modCore + "_WristIKLctr");
		setAttr ($modCore + "_WristIKLctr_orientConstraint1.interpType") 2;
		
		//ELBOW FK LOCATOR
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			spaceLocator -n ($modCore + "_Elbow_FKAimLctr");
			delete `parentConstraint ($modCore + "_ElbowIKCtrl") ($modCore + "_Elbow_FKAimLctr")`;
			parent ($modCore + "_Elbow_FKAimLctr") ($modCore + "_ElbowIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Elbow_FKAimLctr");
		
			parentConstraint -mo ($modCore + "_ElbowFKCtrl") ($modCore + "_ShoulderFKCtrl") ($modCore + "_Elbow_FKAimLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_Elbow1_FKAimLctr");
			parent ($modCore + "_Elbow1_FKAimLctr") ($modCore + "_Elbow1FKCtrl");
			makeIdentity -apply false -t 1 -r 1 ($modCore + "_Elbow1_FKAimLctr");
			delete `pointConstraint -offset 0 0 0 -skip x -skip y -weight 1 ($modCore + "_ElbowIKCtrl") ($modCore + "_Elbow1_FKAimLctr")`;
	
			parent ($modCore + "_Elbow1_FKAimLctr") ($modCore + "_ElbowIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Elbow1_FKAimLctr");
		
			parentConstraint -mo ($modCore + "_Elbow1FKCtrl") ($modCore + "_ShoulderFKCtrl") ($modCore + "_Elbow1_FKAimLctr");
			
			spaceLocator -n ($modCore + "_Elbow2_FKAimLctr");
			parent ($modCore + "_Elbow2_FKAimLctr") ($modCore + "_Elbow2FKCtrl");
			makeIdentity -apply false -t 1 -r 1 ($modCore + "_Elbow2_FKAimLctr");
			delete `pointConstraint -offset 0 0 0 -skip x -skip y -weight 1 ($modCore + "_ElbowIKCtrl") ($modCore + "_Elbow2_FKAimLctr")`;
	
			parent ($modCore + "_Elbow2_FKAimLctr") ($modCore + "_ElbowIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Elbow2_FKAimLctr");
		
			parentConstraint -mo ($modCore + "_Elbow2FKCtrl") ($modCore + "_ShoulderFKCtrl") ($modCore + "_Elbow2_FKAimLctr");
		}		
		
		//SHOULDER FK LOCATOR
		spaceLocator -n ($modCore + "_ShoulderFKOrientLctr");
		delete `parentConstraint ($modCore + "_ShoulderJnt") ($modCore + "_ShoulderFKOrientLctr")`;
		parent ($modCore + "_ShoulderFKOrientLctr") ($modCore + "_ShoulderFKCtrlGrp");
		orientConstraint ($modCore + "_ShoulderJntIK") ($modCore + "_ShoulderFKOrientLctr");
		
		//HIDE SNAP LOCATORS
		setAttr ($modCore + "_ShoulderFKOrientLctr.v") 0;
		if (`objExists ($modCore + "_Elbow_FKAimLctr.v")`)
		{
			setAttr ($modCore + "_Elbow_FKAimLctr.v") 0;
		}
		else
		{
			setAttr ($modCore + "_Elbow1_FKAimLctr.v") 0;
			setAttr ($modCore + "_Elbow2_FKAimLctr.v") 0;
		}		
		setAttr ($modCore + "_WristIKLctr.v") 0;
		setAttr ($modCore + "_WristFKLctr.v") 0;
		
		setAttr ($modCore + "_ShoulderIKLockLctr.v") 0;
		
		
		//PARENT TO MAIN CONTROL
		
		//SET ALL CONSTRAINTS TO SHORTEST INTERPOLATION
		select ;
		
		string $selectedParentConstraints[] = `ls ($modCore + "*_parentConstraint1")`;
		for ($crntParentConstraint in $selectedParentConstraints)
		{setAttr ($crntParentConstraint + ".interpType") 2;}
		
		setAttr ($modCore + "_ElbowIKCtrlGrp_parentConstraint1.interpType") 2;
		
		if (`objExists ($modCore + "_Shoulder_CurveJnt")`)
		{
			setAttr ($modCore + "_LowerTwist75Lctr_parentConstraint1.interpType") 2;
			setAttr ($modCore + "_LowerTwist25Lctr_parentConstraint1.interpType") 2;
			setAttr ($modCore + "_LowerTwistHalfLctr_parentConstraint1.interpType") 2;
		}
		
		//HIERARCHY CLEAN-UP
		parent ($modCore + "_ClavicleCtrlGrp") ($modCore + "_ClavicleJnt")
		($modCore + "_WristJntFKGrp2") ($modCore + "_WristIKCtrlGrp") ($modCore + "_ElbowIKCtrlGrp")
		($modCore + "_ElbowIKCtrl_TargetLctr") ($modCore + "_WristJntIKDummyGrp2")
		($modCore + "_ArmLengthOriginLctr") ($modCore + "_ShoulderIKLockLctr")
		($modCore + "_SwitchCtrlGrp") ($modCore + "_ShoulderFKCtrlGrp2")
		($modCore + "_WristFKCtrlGrp") ($modCore + "_WristJntGrp2")
		($modCore + "_WristJntFK")
		($modCore + "_ScaleGrp");
			
		//if (`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		//{
		//	parent ($modCore + "_Elbow1JntFKGrp2") ($modCore + "_Elbow2JntFKGrp2") ($modCore + "_LowerArmIKHandle") ($modCore + "_ScaleGrp");
		//}

		//CREATE CONSTRAINT FOR WRIST IKCtrlGrp
		//CHECK IF ATTACHED TO ROOT
		if ($modAttachNode == "ROOT")
		{
			parentConstraint -mo ($modName + "_MAINCtrl") ($modName + "_ROOTCtrl") ($modName + "_ROOTSecondaryCtrl") ($modCore + "_WristIKCtrlGrp");
		}
		else
		{
			parentConstraint -mo ($modName + "_MAINCtrl") ($modName + "_ROOTCtrl") ($modName + "_ROOTSecondaryCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_WristIKCtrlGrp");
		}

		//ADD DYNAMIC PARENTING CHANNELS
		addAttr -ln "follow" -at double  -min 1 -max 1 -dv 1 ($modCore + "_WristIKCtrl");
		setAttr -e -keyable 1 ($modCore + "_WristIKCtrl.follow");
		setAttr -lock 1 ($modCore + "_WristIKCtrl.follow");
		if ($modAttachNode != "ROOT")
		{
			addAttr -ln "parent" -at double -min 0 -max 1 -dv 0 ($modCore + "_WristIKCtrl");
			setAttr -e-keyable 1 ($modCore + "_WristIKCtrl.parent");
		}
		addAttr -ln "ROOT"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_WristIKCtrl");
		setAttr -e-keyable 1 ($modCore + "_WristIKCtrl.ROOT");

		addAttr -ln "ROOTType" -at "enum" -en "ROOTC:ROOTsecondaryC:" ($modCore + "_WristIKCtrl");
		setAttr -e-keyable 1 ($modCore + "_WristIKCtrl.ROOTType");


		//IK WRIST DYNAMIC CONSTRAINTS
		if ($modAttachNode != "ROOT")
		{
			connectAttr -f ($modCore + "_WristIKCtrl.parent") ($modCore + "_WristIKCtrlGrp_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW3");
		}
		
		//ROOT CONNECTIONS
		shadingNode -asUtility multiplyDivide -n ($modCore + "_WristIKROOTInf_MD");
		connectAttr -f ($modCore + "_WristIKCtrl.ROOT") ($modCore + "_WristIKROOTInf_MD.input1X");
		connectAttr -f ($modCore + "_WristIKCtrl.ROOT") ($modCore + "_WristIKROOTInf_MD.input1Y");
		connectAttr -f ($modCore + "_WristIKCtrl.ROOTType") ($modCore + "_WristIKROOTInf_MD.input2Y");
		
		shadingNode -asUtility reverse -n ($modCore + "_WristIKROOTInf_Reverse");
		connectAttr -f ($modCore + "_WristIKCtrl.ROOTType") ($modCore + "_WristIKROOTInf_Reverse.inputX");
		connectAttr -f ($modCore + "_WristIKROOTInf_Reverse.outputX") ($modCore + "_WristIKROOTInf_MD.input2X");

		connectAttr -f ($modCore + "_WristIKROOTInf_MD.outputX") ($modCore + "_WristIKCtrlGrp_parentConstraint1." + $modName + "_ROOTCtrlW1");
		connectAttr -f ($modCore + "_WristIKROOTInf_MD.outputY") ($modCore + "_WristIKCtrlGrp_parentConstraint1." + $modName + "_ROOTSecondaryCtrlW2");
		
		shadingNode -asUtility plusMinusAverage -n ($modCore + "_WristIKParent_PMA");
		if ($modAttachNode != "ROOT")
		{
			connectAttr -f ($modCore + "_WristIKCtrl.parent") ($modCore + "_WristIKParent_PMA.input1D[0]");
		}
		connectAttr -f ($modCore + "_WristIKCtrl.ROOT") ($modCore + "_WristIKParent_PMA.input1D[1]");
		
		shadingNode -asUtility condition -n ($modCore + "_WristIKParent_Condition");
		setAttr ($modCore + "_WristIKParent_Condition.operation") 4;
		setAttr ($modCore + "_WristIKParent_Condition.secondTerm") 1;
		connectAttr -f ($modCore + "_WristIKParent_PMA.output1D") ($modCore + "_WristIKParent_Condition.firstTerm");
		connectAttr -force ($modCore + "_WristIKParent_PMA.output1D") ($modCore + "_WristIKParent_Condition.colorIfTrueR");
		
		shadingNode -asUtility reverse -n ($modCore + "_WristIKParent_Reverse");
		connectAttr -f ($modCore + "_WristIKParent_Condition.outColorR") ($modCore + "_WristIKParent_Reverse.inputX");
		connectAttr -f ($modCore + "_WristIKParent_Reverse.outputX") ($modCore + "_WristIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");
		
		/////////////////////////////////SNAP ASSETS/////////////////////////////////
		
		//SINGLE ELBOW
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow1")`)
		{
			//WRIST IK TO FK LOCATOR
			spaceLocator -n ($modCore + "_WristIKtoFKLctr");
			delete `parentConstraint ($modCore + "_WristIKCtrlGrp") ($modCore + "_WristIKtoFKLctr")`;
			parent ($modCore + "_WristIKtoFKLctr") ($modCore + "_WristIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_WristIKtoFKLctr");
			parentConstraint ($modCore + "_WristFKCtrl") ($modCore + "_WristIKtoFKLctr");
			
			//WRIST FK TO IK LOCATOR
			spaceLocator -n ($modCore + "_WristFKtoIKLctr");
			setAttr ($modCore + "_WristFKtoIKLctr.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_WristFKCtrlGrp") ($modCore + "_WristFKtoIKLctr")`;
			parent ($modCore + "_WristFKtoIKLctr") ($modCore + "_WristFKCtrlGrp");
			orientConstraint -mo ($modCore + "_WristIKCtrl") ($modCore + "_WristFKtoIKLctr");
			setAttr ($modCore + "_WristFKtoIKLctr_orientConstraint1.interpType") 2;
			
			//ELBOW IK TO FK LOCATOR
			spaceLocator -n ($modCore + "_ElbowIKtoFKAimLctr");
			delete `parentConstraint ($modCore + "_ElbowIKCtrl") ($modCore + "_ElbowIKtoFKAimLctr")`;
			parent ($modCore + "_ElbowIKtoFKAimLctr") ($modCore + "_ElbowIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_ElbowIKtoFKAimLctr");
			parentConstraint -mo ($modCore + "_ElbowFKCtrl") ($modCore + "_ShoulderFKCtrl") ($modCore + "_ElbowIKtoFKAimLctr");
			
			//SHOULDER FK TO IK LOCATOR
			spaceLocator -n ($modCore + "_ShoulderFKtoIKOrientLctr");
			setAttr ($modCore + "_ShoulderFKtoIKOrientLctr.rotateOrder") 1;
			delete `parentConstraint ($modCore + "_ShoulderJnt") ($modCore + "_ShoulderFKtoIKOrientLctr")`;
			parent ($modCore + "_ShoulderFKtoIKOrientLctr") ($modCore + "_ShoulderFKCtrlGrp");
			orientConstraint ($modCore + "_ShoulderJntIK") ($modCore + "_ShoulderFKtoIKOrientLctr");
			
			//TURN OFF VISIBILITY
			setAttr ($modCore + "_WristIKtoFKLctr.v") 0;
			setAttr ($modCore + "_WristFKtoIKLctr.v") 0;
			setAttr ($modCore + "_ElbowIKtoFKAimLctr.v") 0;
			setAttr ($modCore + "_ShoulderFKtoIKOrientLctr.v") 0;
		}
		
		//ELBOW HIERARCHY CLEANUP////////////////////////////////////////////////////////
		if (`objExists ($modCore + "_ElbowJntFKGrp2")`)
		{
			parent ($modCore + "_ElbowJntFKGrp2") ($modCore + "_ElbowFKCtrlGrp") ($modCore + "_ScaleGrp");
		}
		else
		{
			parent ($modCore + "_Elbow1FKCtrlGrp") ($modCore + "_Elbow2FKCtrlGrp")
			($modCore + "_Elbow1JntFKGrp2") ($modCore + "_Elbow2JntFKGrp2")
			($modCore + "_ScaleGrp");
		}
		
		select $topNode;
	
		if (`objExists ("RRM_" + $prfx + $core + "_Lower1")` || `objExists ("RRM_" + $prfx + $core + "_Middle1")` || `objExists ("RRM_" + $prfx + $core + "_Upper1")`)
		{
			if (`getAttr ("RRM_" + $core + ".toonArms")` == 1)
			{
				RRM_ToonLimbs_V1($modName, "arm", $prfx, $oppPrfx, $crntSide, $oppSide, $modCore, $modOppCore, $multiplier, $inverseFront, $modAttachNode, $topNode);
			}
			else
			{
				RRM_RollLimbs_V1($modName, "arm", $prfx, $oppPrfx, $crntSide, $oppSide, $modCore, $modOppCore, $multiplier, $inverseFront, $modAttachNode, $topNode);
			}
		}
		
		//ADD JOINT ANGLE ATTRIBUTES
		addAttr -ln "shoulderAngleX"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + "shoulderAngleX");
		addAttr -ln "shoulderAngleY"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + "shoulderAngleY");
		addAttr -ln "shoulderAngleZ"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + "shoulderAngleZ");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow2")`)
		{
			addAttr -ln "elbowAngleY" -at double ($modCore + "_SwitchCtrl");
			setAttr -e-keyable 1 ($modCore + "_SwitchCtrl.elbowAngleY");
		}
		else
		{
			addAttr -ln "elbow1AngleY" -at double ($modCore + "_SwitchCtrl");
			setAttr -e-keyable 1 ($modCore + "_SwitchCtrl.elbow1AngleY");
			addAttr -ln "elbow2AngleY" -at double ($modCore + "_SwitchCtrl");
			setAttr -e-keyable 1 ($modCore + "_SwitchCtrl.elbow2AngleY");
		}
		
		addAttr -ln "wristAngleX"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + "wristAngleX");
		addAttr -ln "wristAngleY"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + "wristAngleY");
		addAttr -ln "wristAngleZ"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + "wristAngleZ");
		
		//CONNECT JOINT ANGLE ATTRIBUTES
		connectAttr -force ($modCore + "_ShoulderJnt.rotateX") ($modCore + "_SwitchCtrl." + "shoulderAngleX");
		connectAttr -force ($modCore + "_ShoulderJnt.rotateY") ($modCore + "_SwitchCtrl." + "shoulderAngleY");
		connectAttr -force ($modCore + "_ShoulderJnt.rotateZ") ($modCore + "_SwitchCtrl." + "shoulderAngleZ"); 
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow2")`)
		{
			connectAttr -force ($modCore + "_ElbowJnt.rotateY") ($modCore + "_SwitchCtrl.elbowAngleY");
		}
		else
		{
			connectAttr -force ($modCore + "_Elbow1Jnt.rotateY") ($modCore + "_SwitchCtrl.elbow1AngleY");
			connectAttr -force ($modCore + "_Elbow2Jnt.rotateY") ($modCore + "_SwitchCtrl.elbow2AngleY");
		}
			
	
		connectAttr -force ($modCore + "_WristJntGrp1.rotateX") ($modCore + "_SwitchCtrl.wristAngleX");
		connectAttr -force ($modCore + "_WristJntGrp1.rotateY") ($modCore + "_SwitchCtrl.wristAngleY");
		connectAttr -force ($modCore + "_WristJntGrp1.rotateZ") ($modCore + "_SwitchCtrl.wristAngleZ");
		
		setAttr -lock 1 ($modCore + "_SwitchCtrl.shoulderAngleX");  
		setAttr -lock 1 ($modCore + "_SwitchCtrl.shoulderAngleY");  
		setAttr -lock 1 ($modCore + "_SwitchCtrl.shoulderAngleZ");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Elbow2")`)
		{
			setAttr -lock 1 ($modCore + "_SwitchCtrl.elbowAngleY");
		}
		else
		{
			setAttr -lock 1 ($modCore + "_SwitchCtrl.elbow1AngleY");
			setAttr -lock 1 ($modCore + "_SwitchCtrl.elbow2AngleY");
		}
		
		setAttr -lock 1 ($modCore + "_SwitchCtrl.wristAngleX");  
		setAttr -lock 1 ($modCore + "_SwitchCtrl.wristAngleY");  
		setAttr -lock 1 ($modCore + "_SwitchCtrl.wristAngleZ");
		
		
		//ADD CORE NAME
		$modControls = `ls ($modCore + "_*Ctrl")`;
		string $crntModControl;
		for ($crntModControl in $modControls)
		{
			addAttr -ln "modCoreName"  -dt "string" $crntModControl;
			setAttr -e-keyable 1 ($crntModControl + ".modCoreName");
			setAttr -type "string" ($crntModControl + ".modCoreName") ("_" + $prfx + $core);
			setAttr -e-lock 1 ($crntModControl + ".modCoreName");

			//ADD MODULE TYPE
			addAttr -ln "moduleType"  -dt "string" ($crntModControl);
			setAttr -e -keyable 1 ($crntModControl + ".moduleType");
			setAttr -type "string" ($crntModControl + ".moduleType") "arm";
			setAttr -l true ($crntModControl + ".moduleType");
		}

		//SET UP FOR RIGHT SIDE
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
		$inverseFront = 1;
	
		if (!`objExists ($topNode + ".pair")`)
		{
			$i = 2;
		}
	}
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE LEG MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

global proc RRM_GenerateRig_V1Leg_V1(string $modName, string $moduleName, string $topNode)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;     
	$core = `getAttr ($topNode + ".core")`;

	//INTEGER FOR LOOP
	$mirrorInt = 1;
		
	string $prfx = "l_";
	string $oppPrfx = "r_";
	int $inverseFront = 0;
	$i = 2;
	if (!`objExists ($topNode + ".pair")`)
	{
		$prfx = "";
		$mirrorInt = 2;
	}

	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;

	while ($mirrorInt <=2)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modName + "_" + $prfx + $core);
		
		$modOppCore = ($modName + "_" + $oppPrfx + $core);
		
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		delete `orientConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_OffsetLctr");
		
		group -em -n ($modCore);
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modName + "_ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_ROOTJnt") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modName + "_MAINCtrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "leg";
		setAttr -l true ($modCore + "Grp.topNode");
			
		//CORE NAME
		addAttr -ln "coreName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ("_" + $prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable 1 ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ("_" + $oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable 1 ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");
		}
		
		//NODE-SPECIFIC ATTRIBUTES
		//UPPER ROLL JOINTS
		string $UpperCJnt[];
		if (`objExists ($modCore + "_Upper_Curve1Jnt")`)
		{
			$UpperCJnt = `ls ($modCore + "_Upper_Curve?Jnt")`;
		}
		addAttr -ln "upperRoll"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.upperRoll") ;
		setAttr -type "string" ($modCore + "Grp.upperRoll") `size $UpperCJnt`;
		setAttr -l true ($modCore + "Grp.upperRoll");
		
		string $LowerCJnt[];
		if (`objExists ($modCore + "_Lower_Curve1Jnt")`)
		{
			$UpperCJnt = `ls ($modCore + "_Lower_Curve?Jnt")`;
		}
		addAttr -ln "lowerRoll"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.lowerRoll") ;
		setAttr -type "string" ($modCore + "Grp.lowerRoll") `size $LowerCJnt`;
		setAttr -l true ($modCore + "Grp.lowerRoll");
	
		addAttr -ln "kneeNum"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.kneeNum") ;
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			setAttr -type "string" ($modCore + "Grp.kneeNum") "1";
		}
		else
		{
			setAttr -type "string" ($modCore + "Grp.kneeNum") "2";
		}		
		setAttr -l true ($modCore + "Grp.kneeNum");
		
		int $sizeMiddleCJnt = 0;
		string $MiddleCJnt[];
		if (`objExists ($modCore + "_Middle_Curve1Jnt")`)
		{
			$MiddleCJnt = `ls ($modCore + "_Middle_Curve?Jnt")`;
		}
		addAttr -ln "midRoll"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.midRoll") ;
		setAttr -type "string" ($modCore + "Grp.midRoll") $MiddleCJnt;
		setAttr -l true ($modCore + "Grp.midRoll");
			
		//SCALE GROUP
		group -em -n ($modCore + "_ScaleGrp");
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Hip")  ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + "_ScaleGrp.scale");
	
		//HIP FK CONTROL
		circle -n ($modCore + "_HipFKCtrl") -nr 1 0 0 -r 1 -ch 0;
		group -n ($modCore + "_HipFKCtrlGrp") ($modCore + "_HipFKCtrl");
		setAttr ($modCore + "_HipFKCtrlGrp.rotateOrder") 1;
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_HipFKCtrlGrp")`;
		float $upVector = 1;
		float $kneeLocCheck;
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			$kneeLocCheck = `getAttr ("RRM_" + $prfx + $core + "_Knee.translateZ")`;
		}
		else
		{
			$kneeLocCheck = `getAttr ("RRM_" + $prfx + $core + "_Knee1.translateZ")`;
		}
		if ($kneeLocCheck < -0.0001)
		{
			$upVector = -1;
		}
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 $upVector -worldUpObject ("RRM_" + $prfx + $core + "_Knee")
			("RRM_" + $prfx + $core + "_Knee") ($modCore + "_HipFKCtrlGrp")`;
		}
		else
		{
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 $upVector -worldUpObject ("RRM_" + $prfx + $core + "_Knee1")
			("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_HipFKCtrlGrp")`;
		}
		
		float $lLegLength;
		float $lKneeLength[];
		float $lKnee1Length[];
		float $lKnee2Length[];
		float $lAnkleLength[];
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			spaceLocator -n ($modCore + "_StartLctr") -p 0 0 0;
			spaceLocator -n ($modCore + "_EndLctr") -p 0 0 0;
			parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Knee") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee") ($modCore + "_EndLctr")`;
			$lKneeLength = `xform -q -t ($modCore + "_EndLctr")`;
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_EndLctr")`;
			$lAnkleLength = `xform -q -t ($modCore + "_EndLctr")`;
			
			$lLegLength = (($lKneeLength[0] + $lAnkleLength[0]) /2);
			delete ($modCore + "_StartLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_StartLctr") -p 0 0 0;
			spaceLocator -n ($modCore + "_EndLctr") -p 0 0 0;
			parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_EndLctr")`;
			$lKnee1Length = `xform -q -t ($modCore + "_EndLctr")`;
			
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_EndLctr")`;
			$lKnee2Length = `xform -q -t ($modCore + "_EndLctr")`;
			
			$lKneeLength[0] = ($lKnee1Length[0] + $lKnee2Length[0]);
	
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_StartLctr")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_StartLctr")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_EndLctr")`;
			$lAnkleLength = `xform -q -t ($modCore + "_EndLctr")`;
	
			$lLegLength = (($lKnee1Length[0] + $lKnee2Length[0]) /2);
			delete ($modCore + "_StartLctr");
		}
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_HipFKCtrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_HipFKCtrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_HipFKCtrl");
		
		setAttr (($modCore + "_HipFKCtrl.scale"), ($lLegLength/2), ($lLegLength/2), ($lLegLength/2));
		makeIdentity -apply true -s 1 ($modCore + "_HipFKCtrlGrp");
			
		//KNEE FK CONTROL
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			duplicate -n ($modCore + "_KneeFKCtrlGrp") ($modCore + "_HipFKCtrlGrp");
			select ($modCore + "_KneeFKCtrlGrp");
			pickWalk -d down;
			rename ($modCore + "_KneeFKCtrl");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Knee") ($modCore + "_KneeFKCtrlGrp")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "objectrotation"
			-worldUpVector 0 0 $upVector -worldUpObject ("RRM_" + $prfx + $core + "_Knee")
			("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_KneeFKCtrlGrp")`;

			scale -r 0.8 0.8 0.8 ($modCore + "_KneeFKCtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + "_KneeFKCtrlGrp");
		}
		else
		{
			duplicate -n ($modCore + "_Knee1FKCtrlGrp") ($modCore + "_HipFKCtrlGrp");
			select ($modCore + "_Knee1FKCtrlGrp");
			pickWalk -d down;
			rename ($modCore + "_Knee1FKCtrl");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_Knee1FKCtrlGrp")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "objectrotation"
			-worldUpVector 0 0 $upVector -worldUpObject ("RRM_" + $prfx + $core + "_Knee1")
			("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_Knee1FKCtrlGrp")`;
			scale -r 0.8 0.8 0.8 ($modCore + "_Knee1FKCtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + "_Knee1FKCtrlGrp");
			
			duplicate -n ($modCore + "_Knee2FKCtrlGrp") ($modCore + "_HipFKCtrlGrp");
			select ($modCore + "_Knee2FKCtrlGrp");
			pickWalk -d down;
			rename ($modCore + "_Knee2FKCtrl");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_Knee2FKCtrlGrp")`;
			rotate -r -os 0 0 -90 ($modCore + "_Knee2FKCtrlGrp");
			scale -r 0.8 0.8 0.8 ($modCore + "_Knee2FKCtrlGrp");
			makeIdentity -apply true -s 1 ($modCore + "_Knee2FKCtrlGrp");
		}
		
		
		//ANKLE FK CONTROL
		duplicate -n ($modCore + "_AnkleFKCtrlGrp") ($modCore + "_HipFKCtrlGrp");
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_AnkleFKCtrlGrp")`;
		delete `orientConstraint -offset 0 0 -90 ("RRM_" + $prfx + $core + "_Toe") ($modCore + "_AnkleFKCtrlGrp")`;
		scale -r 0.8 0.8 0.8 ($modCore + "_AnkleFKCtrlGrp");
		makeIdentity -apply true -s 1 ($modCore + "_AnkleFKCtrlGrp");
		select ($modCore + "_AnkleFKCtrlGrp");
		pickWalk -d down;
		rename ($modCore + "_AnkleFKCtrl");
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_AnkleFKCtrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_AnkleFKCtrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_AnkleFKCtrl");
	
		//BALL CONTROL LOCATORS
		spaceLocator -n ($modCore + "_StartLctr") -p 0 0 0;
		spaceLocator -n ($modCore + "_EndLctr") -p 0 0 0;
		parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");
		
		delete `pointConstraint ("RRM_" + $prfx + $core + "_HeelPivot") ($modCore + "_StartLctr")`;
		delete `pointConstraint -skip x -skip z ("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_StartLctr")`;
		delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modCore + "_AnkleFKCtrlGrp")
		("RRM_" + $prfx + $core + "_Toe") ($modCore + "_StartLctr")`;
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Toe") ($modCore + "_EndLctr")`;
		$lFootLength = `xform -q -t ($modCore + "_EndLctr")`;
		delete ($modCore + "_StartLctr");
	
		//BALL FK CONTROL
		circle -n ($modCore + "_BallFKCtrl") -nr 1 0 0 -r 1 -ch 0;
		move -r 0 0 0.5 ($modCore + "_BallFKCtrl.cv[0:7]");
	
		group -n ($modCore + "_BallFKCtrlGrp") ($modCore + "_BallFKCtrl"); xform -os -piv 0 0 0;
		setAttr ($modCore + "_BallFKCtrlGrp.rotateOrder") 1;
	
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Ball") ($modCore + "_BallFKCtrlGrp")`;
		delete `orientConstraint -offset 0 -90 -90 ("RRM_" + $prfx + $core + "_Ball") ($modCore + "_BallFKCtrlGrp")`;
		scale -r ($lFootLength[0]/5) ($lFootLength[0]/5) ($lFootLength[0]/4) ($modCore + "_BallFKCtrlGrp");
		makeIdentity -apply true -s 1 ($modCore + "_BallFKCtrlGrp");
		select ($modCore + "_BallFKCtrlGrp");
		pickWalk -d down;
		rename ($modCore + "_BallFKCtrl");
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_BallFKCtrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_BallFKCtrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_BallFKCtrl");
		
		//TOE FK CONTROL
		circle -n ($modCore + "_ToeFKCtrl") -nr 1 0 0 -r 1 -ch 0;
		move -r 0 0 0.5 ($modCore + "_ToeFKCtrl.cv[0:7]");
	
		group -n ($modCore + "_ToeFKCtrlGrp") ($modCore + "_ToeFKCtrl"); xform -os -piv 0 0 0;
		setAttr ($modCore + "_ToeFKCtrlGrp.rotateOrder") 1;
	
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Toe") ($modCore + "_ToeFKCtrlGrp")`;
		delete `orientConstraint -offset 0 -90 -90 ("RRM_" + $prfx + $core + "_Toe") ($modCore + "_ToeFKCtrlGrp")`;
		scale -r ($lFootLength[0]/5) ($lFootLength[0]/5) ($lFootLength[0]/4) ($modCore + "_ToeFKCtrlGrp");
		select ($modCore + "_ToeFKCtrlGrp");
		pickWalk -d down;
		rename ($modCore + "_ToeFKCtrl");
		transformLimits -sx 0.01 1 -esx 1 0 ($modCore + "_ToeFKCtrl");
		transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_ToeFKCtrl");
		transformLimits -sz 0.01 1 -esz 1 0 ($modCore + "_ToeFKCtrl");
		
		//////////////////////JOINTS//////////////////////
		select -cl;
		joint -n ($modCore + "_HipJnt");
		delete `parentConstraint ($modCore + "_HipFKCtrl") ($modCore + "_HipJnt")`;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			select -cl;
			joint -n ($modCore + "_KneeJnt");
			delete `parentConstraint ($modCore + "_KneeFKCtrl") ($modCore + "_KneeJnt")`;
		
			select -cl;
			joint -n ($modCore + "_AnkleJnt");
			delete `parentConstraint ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleJnt")`;
			select -cl;
			joint -n ($modCore + "_AnkleJntDummy");
			delete `parentConstraint ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleJntDummy")`;
			
			makeIdentity -apply true -r 1 ($modCore + "_HipJnt")
			($modCore + "_KneeJnt") ($modCore + "_AnkleJnt") ($modCore + "_AnkleJntDummy");
			
			parent ($modCore + "_KneeJnt")  ($modCore + "_HipJnt");
			parent ($modCore + "_AnkleJnt") ($modCore + "_KneeJnt");
			parent ($modCore + "_AnkleJntDummy") ($modCore + "_KneeJnt");
		}
		else
		{
			select -cl;
			joint -n ($modCore + "_Knee1Jnt");
			delete `parentConstraint ($modCore + "_Knee1FKCtrl") ($modCore + "_Knee1Jnt")`;
		
			select -cl;
			joint -n ($modCore + "_Knee2Jnt");
			delete `parentConstraint ($modCore + "_Knee2FKCtrl") ($modCore + "_Knee2Jnt")`;
	
			select -cl;
			joint -n ($modCore + "_AnkleJnt");
			delete `parentConstraint ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleJnt")`;
			select -cl;
			joint -n ($modCore + "_AnkleJntDummy");
			delete `parentConstraint ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleJntDummy")`;
			
			makeIdentity -apply true -r 1  ($modCore + "_HipJnt")
			($modCore + "_Knee1Jnt") ($modCore + "_Knee2Jnt") ($modCore + "_AnkleJnt") ($modCore + "_AnkleJntDummy");
	
			parent ($modCore + "_Knee1Jnt")  ($modCore + "_HipJnt");
			parent ($modCore + "_Knee2Jnt") ($modCore + "_Knee1Jnt"); 
			parent ($modCore + "_AnkleJnt") ($modCore + "_Knee2Jnt");
			parent ($modCore + "_AnkleJntDummy") ($modCore + "_Knee2Jnt");
		}
		//HIDE WRIST DUMMY 
		setAttr ($modCore + "_AnkleJntDummy.v") 0;
		
		select -cl;
		joint -n ($modCore + "_BallJnt");
		delete `parentConstraint ($modCore + "_BallFKCtrl") ($modCore + "_BallJnt")`;	
		
		select -cl;
		joint -n ($modCore + "_ToeJnt");
		delete `parentConstraint ($modCore + "_ToeFKCtrl") ($modCore + "_ToeJnt")`;
		
		makeIdentity -apply true -r 1 ($modCore + "_BallJnt") ($modCore + "_ToeJnt");
		
		parent ($modCore + "_BallJnt") ($modCore + "_AnkleJnt");
		parent ($modCore + "_ToeJnt") ($modCore + "_BallJnt");
	
		//KNEE ORIENTATION
		if (`objExists ($modCore + "_KneeJnt")`)
		{
			if ($kneeLocCheck < -0.0001)
			{
				setAttr ($modCore + "_KneeJnt.preferredAngleY") -60;
			}
			else
			{
				setAttr ($modCore + "_KneeJnt.preferredAngleY") 60;
			}
		}
		else
		{
			if ($kneeLocCheck < -0.0001)
			{
				setAttr ($modCore + "_Knee1Jnt.preferredAngleY") -30;
			}
			else
			{
				setAttr ($modCore + "_Knee1Jnt.preferredAngleY") 30;
			}			
		}
		
		////////////////////IK/FK JOINTS////////////////////////////////////	
		//LEG FK
		duplicate -n ($modCore + "_HipJntFK") ($modCore + "_HipJnt");
		select ($modCore + "_HipJntFK");
		pickWalk -d down;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			rename ($modCore + "_KneeJntFK");
			pickWalk -d down;
			rename ($modCore + "_AnkleJntFK");
			pickWalk -d right;
			delete;       
		}
		else
		{
			rename ($modCore + "_Knee1JntFK");
			pickWalk -d down;
			rename ($modCore + "_Knee2JntFK");
			pickWalk -d down;
			rename ($modCore + "_AnkleJntFK");
			pickWalk -d right;
			delete;
		}
		select ($modCore + "_AnkleJntFK");
		pickWalk -d down;
		rename ($modCore + "_BallJntFK");
		pickWalk -d down;
		rename ($modCore + "_ToeJntFK");
		
		//LEG IK
		duplicate -n ($modCore + "_HipJntIK") ($modCore + "_HipJnt");
		select ($modCore + "_HipJntIK");
		pickWalk -d down;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			rename ($modCore + "_KneeJntIK");
			pickWalk -d down;
			rename ($modCore + "_AnkleJntIK");
			pickWalk -d right;
			delete;
		}
		else
		{
			rename ($modCore + "_Knee1JntIK");
			pickWalk -d down;
			rename ($modCore + "_Knee2JntIK");
			pickWalk -d down;
			rename ($modCore + "_AnkleJntIK");
			pickWalk -d right;
			delete;
		}
		
		select ($modCore + "_AnkleJntIK");
		pickWalk -d down;
		rename ($modCore + "_BallJntIK");
		pickWalk -d down;
		rename ($modCore + "_ToeJntIK");
		
		//DETACH FK LEG JOINTS FOR SCALE COMPENSATION
	
		parent -w ($modCore + "_AnkleJntFK");
		group -n ($modCore + "_AnkleJntFKGrp1") ($modCore + "_AnkleJntFK");
		group -n ($modCore + "_AnkleJntFKGrp2") ($modCore + "_AnkleJntFKGrp1");
		$lAnkleLocation = `xform -q -ws -t ($modCore + "_AnkleJnt")`;
		move $lAnkleLocation[0] $lAnkleLocation[1] $lAnkleLocation[2] ($modCore + "_AnkleJntFKGrp1.scalePivot") ($modCore + "_AnkleJntFKGrp1.rotatePivot") ;
	
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			parentConstraint -mo ($modCore + "_KneeJntFK") ($modCore + "_AnkleJntFKGrp2");
		}
		else
		{
			parentConstraint -mo ($modCore + "_Knee2JntFK") ($modCore + "_AnkleJntFKGrp2");
		}
			
		$lKneeLocation = `xform -q -ws -t ($modCore + "_HipJnt")`;
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			$lKneeLocation = `xform -q -ws -t ($modCore + "_KneeJnt")`;
			move $lKneeLocation[0] $lKneeLocation[1] $lKneeLocation[2] ($modCore + "_AnkleJntFKGrp2.scalePivot") ($modCore + "_AnkleJntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleJntFKGrp1");
			parentConstraint -mo ($modCore + "_KneeJntFK") ($modCore + "_AnkleJntFKGrp2");
		
			parent -w ($modCore + "_KneeJntFK");
			group -n ($modCore + "_KneeJntFKGrp1") ($modCore + "_KneeJntFK");
			group -n ($modCore + "_KneeJntFKGrp2") ($modCore + "_KneeJntFKGrp1");
			$lHipLocation = `xform -q -ws -t ($modCore + "_HipJnt")`;
			move $lKneeLocation[0] $lKneeLocation[1] $lKneeLocation[2] ($modCore + "_KneeJntFKGrp1.scalePivot") ($modCore + "_KneeJntFKGrp1.rotatePivot") ;
			move $lHipLocation[0] $lHipLocation[1] $lHipLocation[2] ($modCore + "_KneeJntFKGrp2.scalePivot") ($modCore + "_KneeJntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_KneeFKCtrl") ($modCore + "_KneeJntFKGrp1");
			parentConstraint -mo ($modCore + "_HipJntFK") ($modCore + "_KneeJntFKGrp2");
		}
		else
		{
			$lKnee2Location = `xform -q -ws -t ($modCore + "_Knee2Jnt")`;
			move $lKnee2Location[0] $lKnee2Location[1] $lKnee2Location[2] ($modCore + "_AnkleJntFKGrp2.scalePivot") ($modCore + "_AnkleJntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleJntFKGrp1");
			parentConstraint -mo ($modCore + "_Knee2JntFK") ($modCore + "_AnkleJntFKGrp2");
	
			parent -w ($modCore + "_Knee1JntFK") ($modCore + "_Knee2JntFK");
			
			group -n ($modCore + "_Knee1JntFKGrp1") ($modCore + "_Knee1JntFK");
			group -n ($modCore + "_Knee1JntFKGrp2") ($modCore + "_Knee1JntFKGrp1");
			$lHipLocation = `xform -q -ws -t ($modCore + "_HipJnt")`;
			$lKnee1Location = `xform -q -ws -t ($modCore + "_Knee1Jnt")`;
			$lKnee2Location = `xform -q -ws -t ($modCore + "_Knee2Jnt")`;
			move $lHipLocation[0] $lHipLocation[1] $lHipLocation[2] ($modCore + "_Knee1JntFKGrp1.scalePivot") ($modCore + "_Knee1JntFKGrp1.rotatePivot") ;
			move $lKnee1Location[0] $lKnee1Location[1] $lKnee1Location[2] ($modCore + "_Knee1JntFKGrp2.scalePivot") ($modCore + "_Knee1JntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_Knee1FKCtrl") ($modCore + "_Knee1JntFKGrp1");
			parentConstraint -mo ($modCore + "_HipJntFK") ($modCore + "_Knee1JntFKGrp2");
	
			group -n ($modCore + "_Knee2JntFKGrp1") ($modCore + "_Knee2JntFK");
			group -n ($modCore + "_Knee2JntFKGrp2") ($modCore + "_Knee2JntFKGrp1");
			move $lKnee1Location[0] $lKnee1Location[1] $lKnee1Location[2] ($modCore + "_Knee2JntFKGrp1.scalePivot") ($modCore + "_Knee2JntFKGrp1.rotatePivot") ;
			move $lKnee2Location[0] $lKnee2Location[1] $lKnee2Location[2] ($modCore + "_Knee2JntFKGrp2.scalePivot") ($modCore + "_Knee2JntFKGrp2.rotatePivot") ;
			pointConstraint ($modCore + "_Knee2FKCtrl") ($modCore + "_Knee2JntFKGrp1");
			parentConstraint -mo ($modCore + "_Knee1JntFK") ($modCore + "_Knee2JntFKGrp2");
		}
		
		//CONSTRAIN HIP JOINTS TO ATTACH NODE
		pointConstraint ($modCore + "_HipFKCtrl") ($modCore + "_HipJnt");
		delete `pointConstraint ($modCore + "_HipFKCtrl") ($modCore + "_HipJntFK")`;
		pointConstraint ($modCore + "_HipFKCtrl") ($modCore + "_HipJntIK");
	
		//FOOT IK CONTROL
		circle -n ($modCore + "_FootIKCtrl") -nr 0 1 0 -r 2.5 -s 16 -ch 0;
	
		scale -r 0.4 1 1 ($modCore + "_FootIKCtrl.cv[13]") ($modCore + "_FootIKCtrl.cv[5]");
		scale -r 0.6 1 1 ($modCore + "_FootIKCtrl.cv[14]") ($modCore + "_FootIKCtrl.cv[4]");
		scale -r 0.78 1 1 ($modCore + "_FootIKCtrl.cv[3]") ($modCore + "_FootIKCtrl.cv[15]"); 
		scale -r 0.78 1 1 ($modCore + "_FootIKCtrl.cv[12]") ($modCore + "_FootIKCtrl.cv[6]");
		scale -r 0.89 1 1 ($modCore + "_FootIKCtrl.cv[7]") ($modCore + "_FootIKCtrl.cv[11]");
		move -r -os -wd 0 0.565 0 ($modCore + "_FootIKCtrl.cv[5]") ($modCore + "_FootIKCtrl.cv[13]");
		move -r -os -wd 0 0.1 0 ($modCore + "_FootIKCtrl.cv[4]") ($modCore + "_FootIKCtrl.cv[14]") ($modCore + "_FootIKCtrl.cv[6]") ($modCore + "_FootIKCtrl.cv[12]");
		move -r 0 0 1.5 ($modCore + "_FootIKCtrl.cv[0:15]");
		scale -r ($lFootLength[0]/4.2) ($lFootLength[0]/4.2) ($lFootLength[0]/3.4) ($modCore + "_FootIKCtrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_FootIKCtrl");
		group -n ($modCore + "_FootIKCtrlGrp") ($modCore + "_FootIKCtrl"); xform -os -piv 0 0 0;
		setAttr ($modCore + "_FootIKCtrl.rotateOrder") 1;
		
		//TOE IK CONTROL
		circle -n ($modCore + "_ToeIKCtrl") -nr 0 1 0 -r 1 -ch 0;
		move -r ($multiplier * -0.251) 1.330 2.207($modCore + "_ToeIKCtrl.cv[1]") ;
		move -r 0.254 1.085 1.162($modCore + "_ToeIKCtrl.cv[0]") ;
		move -r 0.051 0.451 -0.205 ($modCore + "_ToeIKCtrl.cv[7]") ;
		move -r 0.188 0.259 -0.109 ($modCore + "_ToeIKCtrl.cv[6]") ;
		move -r -0.277 0.154 0.308 ($modCore + "_ToeIKCtrl.cv[5]") ;
		move -r -0.395 0.259 -0.033 ($modCore + "_ToeIKCtrl.cv[4]") ;
		move -r 0.003 0.474 -0.205 ($modCore + "_ToeIKCtrl.cv[3]") ;
		move -r -0.369 1.190 1.331 ($modCore + "_ToeIKCtrl.cv[2]") ;
		move -r -os -wd 0 0 0.9 ($modCore + "_ToeIKCtrl.cv[0:7]") ;
		scale -r -p 0cm 0cm 0cm $multiplier 1 1 ($modCore + "_ToeIKCtrl.cv[0:7]");
		
		move -r -.001 0 1.85 ($modCore + "_ToeIKCtrl");
		scale -r ($lFootLength[0]/4) ($lFootLength[0]/4) ($lFootLength[0]/4.4) ($modCore + "_ToeIKCtrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_ToeIKCtrl");
		group -n ($modCore + "_ToeIKCtrlGrp") ($modCore + "_ToeIKCtrl");
		parent ($modCore + "_ToeIKCtrlGrp") ($modCore + "_FootIKCtrlGrp");
		
		//HEEL IK CONTROL
		circle -n ($modCore + "_HeelIKCtrl") -nr 0 1 0 -r 1 -ch 0;
		move -r -0.25107 1.330277 2.206782 ($modCore + "_HeelIKCtrl.cv[1]") ;
		move -r 0.254402 1.084741 1.162191 ($modCore + "_HeelIKCtrl.cv[0]") ;
		move -r 0.0513063 0.450871 -0.204969 ($modCore + "_HeelIKCtrl.cv[7]") ;
		move -r 0.187803 0.259426 -0.108661 ($modCore + "_HeelIKCtrl.cv[6]") ;
		move -r -0.276837 0.154413 0.307813 ($modCore + "_HeelIKCtrl.cv[5]") ;
		move -r -0.395115 0.259426 -0.0326967 ($modCore + "_HeelIKCtrl.cv[4]") ;
		move -r 0.00260226 0.47359 -0.204969 ($modCore + "_HeelIKCtrl.cv[3]") ;
		move -r -0.369241 1.189888 1.331089 ($modCore + "_HeelIKCtrl.cv[2]") ;
		move -r -os -wd 0 0 0.8 ($modCore + "_HeelIKCtrl.cv[0:7]") ;
		scale -r -p 0cm 0cm 0cm $multiplier 1 -1 ($modCore + "_HeelIKCtrl.cv[0:7]");
		scale -r ($lFootLength[0]/3.7) ($lFootLength[0]/3.7) ($lFootLength[0]/5.5) ($modCore + "_HeelIKCtrl");
		move -r -.001 0 1.85 ($modCore + "_HeelIKCtrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_HeelIKCtrl");
		group -n ($modCore + "_HeelIKCtrlGrp") ($modCore + "_HeelIKCtrl");
		parent ($modCore + "_HeelIKCtrlGrp") ($modCore + "_FootIKCtrlGrp");
		
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Ground") ($modCore + "_FootIKCtrlGrp")`;
		$lAnklePosition = `xform -ws -q -rp ($modCore + "_AnkleJnt")`;
		$lBallLocation = `xform  -q -t ($modCore + "_BallJnt")`;
		$lToeLocation = `xform -q -t ($modCore + "_ToeJnt")`;
		makeIdentity -apply true -t 0 -s 1 ($modCore + "_FootIKCtrlGrp");
		
		
		//MOVE TOE CTRL PIVOT
		$limbJointLoc = `xform -ws -q -t ($modCore + "_ToeJnt")`;
		$heelLoc = `xform -ws -q -rp ("RRM_" + $prfx + $core + "_HeelPivot")`;
		delete `pointConstraint ($modCore + "_ToeJnt") ($modCore + "_ToeIKCtrl")`;
		delete `pointConstraint ("RRM_" + $prfx + $core + "_HeelPivot") ($modCore + "_HeelIKCtrl")`;
		move $heelLoc[0]  $heelLoc[1] $heelLoc[2] ($modCore + "_HeelIKCtrlGrp.scalePivot") ($modCore + "_HeelIKCtrlGrp.rotatePivot") ;
		move $limbJointLoc[0]  $limbJointLoc[1] $limbJointLoc[2] ($modCore + "_ToeIKCtrlGrp.scalePivot") ($modCore + "_ToeIKCtrlGrp.rotatePivot") ;
		move $lAnklePosition[0] $lAnklePosition[1] $lAnklePosition[2] ($modCore + "_FootIKCtrl.scalePivot") ($modCore + "_FootIKCtrl.rotatePivot") ;
	
		
		//FOOT IK LOCATORS
		spaceLocator -n ($modCore + "_FootBallPivotLctr");
		delete `pointConstraint ($modCore + "_BallJnt") ($modCore + "_FootBallPivotLctr")`;
		delete `aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modCore + "_FootIKCtrl")
		($modCore + "_ToeJnt") ($modCore + "_FootBallPivotLctr")`;
		
		duplicate -rr -n ($modCore + "_FootToePivotLctr") ($modCore + "_FootBallPivotLctr");
		
		duplicate -n ($modCore + "_FootBallPivotLctr2") ($modCore + "_FootBallPivotLctr");
		parent ($modCore + "_FootBallPivotLctr2") ($modCore + "_FootBallPivotLctr");
	
		select ($modCore + "_AnkleJntIK.rotatePivot") ($modCore + "_BallJntIK.rotatePivot") ; 
		ikHandle -n ($modCore + "_BallIKHandle") -sol ikSCsolver;
		parent ($modCore + "_BallIKHandle") ($modCore + "_FootBallPivotLctr2");
		select ($modCore + "_BallJntIK.rotatePivot") ($modCore + "_ToeJntIK.rotatePivot") ; 
		ikHandle -n ($modCore + "_ToeIKHandle") -sol ikSCsolver;
		parent ($modCore + "_ToeIKHandle") ($modCore + "_FootToePivotLctr");
	
		spaceLocator -n ($modCore + "_BallSwivelLctr");
		delete `pointConstraint ($modCore + "_BallJnt") ($modCore + "_BallSwivelLctr")`;
		parent ($modCore + "_BallSwivelLctr") ($modCore + "_ToeIKCtrl");
		makeIdentity -apply false -r 1 ($modCore + "_BallSwivelLctr");
		
		spaceLocator -n ($modCore + "_FootRightTiltLctr");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_FootRightTilt") ($modCore + "_FootRightTiltLctr")`;
		spaceLocator -n ($modCore + "_FootLeftTiltLctr");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_FootLeftTilt") ($modCore + "_FootLeftTiltLctr")`;
		
		spaceLocator -n ($modCore + "_HeelLctr");
		delete `parentConstraint ($modCore + "_HeelIKCtrl") ($modCore + "_HeelLctr")`;
		parent ($modCore + "_HeelLctr") ($modCore + "_HeelIKCtrl");
		setAttr ($modCore + "_HeelLctr.v") 0;
		
		delete `parentConstraint ("RRM_" + $prfx + $core + "_HeelPivot") ($modCore + "_HeelIKCtrlGrp")`;
	
		parent ($modCore + "_HeelIKCtrlGrp") ($modCore + "_ToeIKCtrl");
		parent ($modCore + "_BallSwivelLctr") ($modCore + "_HeelLctr");
		parent ($modCore + "_FootRightTiltLctr") ($modCore + "_BallSwivelLctr");
		parent ($modCore + "_FootLeftTiltLctr")  ($modCore + "_FootRightTiltLctr");
		parent ($modCore + "_FootBallPivotLctr") ($modCore + "_FootToePivotLctr") ($modCore + "_FootLeftTiltLctr");
		
		makeIdentity -apply true -t 1 -r 0 -s 1 ($modCore + "_ToeIKCtrlGrp");
		parentConstraint -mo ($modCore + "_FootIKCtrl") ($modCore + "_ToeIKCtrlGrp");
		
		setAttr -l 0 -k 1 ($modCore + "_HipJntIK.rx");
		setAttr -l 0 -k 1 ($modCore + "_HipJntIK.ry");
		setAttr -l 0 -k 1 ($modCore + "_HipJntIK.rz");
		if (`objExists ($modCore + "_KneeJntIK")`)
		{
			setAttr -l 0 -k 1 ($modCore + "_KneeJntIK.rx");
			setAttr -l 0 -k 1 ($modCore + "_KneeJntIK.ry");
			setAttr -l 0 -k 1 ($modCore + "_KneeJntIK.rz");
		}
		else
		{
			setAttr -l 0 -k 1 ($modCore + "_Knee1JntIK.rx");
			setAttr -l 0 -k 1 ($modCore + "_Knee1JntIK.ry");
			setAttr -l 0 -k 1 ($modCore + "_Knee1JntIK.rz");
			setAttr -l 0 -k 1 ($modCore + "_Knee2JntIK.rx");
			setAttr -l 0 -k 1 ($modCore + "_Knee2JntIK.ry");
			setAttr -l 0 -k 1 ($modCore + "_Knee2JntIK.rz");
		}
	
		//KNEE IK CONTROL
		curve -n ($modCore + "_KneeIKCtrl") -d 1 -p 0 -5 0 -p -2 -3 0 -p -1 -3 0 -p -1 -1 0 -p -3 -1 0 -p -3 -2 0
		-p -5 0 0 -p -3 2 0 -p -3 1 0 -p -1 1 0 -p -1 3 0 -p -2 3 0 -p 0 5 0 -p 2 3 0
		-p 1 3 0 -p 1 1 0 -p 3 1 0 -p 3 2 0 -p 5 0 0 -p 3 -2 0 -p 3 -1 0 -p 1 -1 0	
		-p 1 -3 0 -p 2 -3 0 -p 0 -5 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9
		-k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22
		-k 23 -k 24 ;
		rename `listRelatives -c ($modCore + "_KneeIKCtrl")` ($modCore + "_KneeIKCtrlShape");
		
		move -r 0 0 0.95 ($modCore + "_KneeIKCtrl.cv[12]")  ($modCore + "_KneeIKCtrl.cv[0]") ($modCore + "_KneeIKCtrl.cv[24]") ($modCore + "_KneeIKCtrl.cv[18]") ($modCore + "_KneeIKCtrl.cv[6]") ;
		move -r 0 0 -0.65 ($modCore + "_KneeIKCtrl.cv[3]") ($modCore + "_KneeIKCtrl.cv[9]") ($modCore + "_KneeIKCtrl.cv[15]") ($modCore + "_KneeIKCtrl.cv[21]") ;
		group -n ($modCore + "_KneeIKCtrlGrp") ($modCore + "_KneeIKCtrl"); xform -os -piv 0 0 0;

		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Knee") ($modCore + "_KneeIKCtrlGrp")`;
			setAttr (($modCore + "_KneeIKCtrl.scale"), ($lLegLength / 16), ($lLegLength / 16), ($lLegLength / 16));
			setAttr ($modCore + "_KneeIKCtrl.tz") ($lLegLength * 1.8);
			
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_KneeIKCtrl");
		}
		else
		{
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Knee1") ($modCore + "_KneeIKCtrlGrp")`;
			setAttr (($modCore + "_KneeIKCtrl.scale"), ($lLegLength / 16), ($lLegLength / 16), ($lLegLength / 16));
			setAttr ($modCore + "_KneeIKCtrl.tz") ($lLegLength * 1.8);
			
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_KneeIKCtrl");
		}
		
		//LOWER LEG CONTROL
		if (`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			curve -n ($modCore + "_LowerLegIKCtrl") -d 1 -p -1 0 4 -p -4 0 4 -p -3 0 5 -p -2 0 6 -p -1 0 7 -p 0 0 8 -p 1 0 7 -p 2 0 6 -p 3 0 5 -p 4 0 4 -p 1 0 4 -p 1 0 3 -p 1 0 2 -p 1 0 1 -p 1 0 0 -p 1 0 -1 -p 1 0 -2 -p 1 0 -3 -p 1 0 -4 -p 4 0 -4 -p 3 0 -5 -p 2 0 -6 -p 1 0 -7 -p 0 0 -8 -p -1 0 -7 -p -2 0 -6 -p -3 0 -5 -p -4 0 -4 -p -1 0 -4 -p -1 0 -3 -p -1 0 -2 -p -1 0 -1 -p -1 0 0 -p -1 0 1 -p -1 0 2 -p -1 0 3 -p -1 0 4 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 11 -k 12 -k 13 -k 14 -k 15 -k 16 -k 17 -k 18 -k 19 -k 20 -k 21 -k 22 -k 23 -k 24 -k 25 -k 26 -k 27 -k 28 -k 29 -k 30 -k 31 -k 32 -k 33 -k 34 -k 35 -k 36 ;
			rename `listRelatives -c ($modCore + "_LowerLegIKCtrl")` ($modCore + "_LowerLegIKCtrlShape");
			nonLinear -type bend -lowBound -1 -highBound 1 -curvature 15;
			$bend = `ls -sl`;
			rename $bend ($modCore + "_LowerLegIKCBend");
			rotate -a -os -90 0 -90 ($modCore + "_LowerLegIKCBend");
	
			setAttr (($modCore + "_LowerLegIKCtrl.scale"), ($lLegLength/14), ($lLegLength/14), ($lLegLength/14));
			makeIdentity -apply true -r 1 -s 1 ($modCore + "_LowerLegIKCtrl");
			delete -ch ($modCore + "_LowerLegIKCtrl");
			
			
			group -n ($modCore + "_LowerLegIKCtrlGrp") ($modCore + "_LowerLegIKCtrl");
			group -n ($modCore + "_LowerLegIKCtrlGrp2") ($modCore + "_LowerLegIKCtrlGrp");
			group -n ($modCore + "_LowerLegIKCtrlGrp3") ($modCore + "_LowerLegIKCtrlGrp2");			
			parent ($modCore + "_LowerLegIKCtrlGrp3") ($modCore + "_ScaleGrp");
			setAttr ($modCore + "_LowerLegIKCtrlGrp.rotateOrder") 1;
			setAttr ($modCore + "_LowerLegIKCtrlGrp2.rotateOrder") 1;
			setAttr ($modCore + "_LowerLegIKCtrlGrp3.rotateOrder") 1;
	
			spaceLocator -n ($modCore + "_lowerLegIKLctr");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_lowerLegIKLctr")`;
			parent ($modCore + "_lowerLegIKLctr") ($modCore + "_HipFKCtrl");
			setAttr ($modCore + "_lowerLegIKLctr.v") 0;

			
			//MOVE GROUP 3 TO BALL LOCATION AND ORIENT IT SO IT IS AIMING AT LOWER IK CONTROL
			delete `pointConstraint ($modCore + "_FootIKCtrl") ($modCore + "_LowerLegIKCtrlGrp3")`;
			delete `aimConstraint -offset 0 0 0 -aimVector 0 1 0 -upVector 0 0 1 -worldUpType "objectRotation" -worldUpVector 0 0 1 -worldUpObject ("RRM_" + $prfx + $core + "_Knee2")
			("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_LowerLegIKCtrlGrp3")`;
	
			parentConstraint -mo ($modCore + "_FootBallPivotLctr2") ($modCore + "_LowerLegIKCtrlGrp3");
			
			//LOCATOR FOR UP AXIS ON LOWER FOOT CONTROL USING ROTATE Y ONLY FORM FOOTIKC
			spaceLocator -n ($modCore + "_LowerLegIKCtrl_UpLctr");
			setAttr ($modCore + "_LowerLegIKCtrl_UpLctr.rotateOrder") 1;
			group -n ($modCore + "_LowerLegIKCtrl_UpLctrGrp") ($modCore + "_LowerLegIKCtrl_UpLctr");
			delete `orientConstraint ("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_LowerLegIKCtrl_UpLctrGrp")`;
			pointConstraint ($modCore + "_FootIKCtrl") ($modCore + "_LowerLegIKCtrl_UpLctrGrp");
			parent ($modCore + "_LowerLegIKCtrl_UpLctrGrp") ($modCore + "_ScaleGrp");
			setAttr ($modCore + "_LowerLegIKCtrl_UpLctrGrp.v") 0;
			orientConstraint -mo -skip x -skip z ($modCore + "_FootIKCtrl") ($modCore + "_LowerLegIKCtrl_UpLctr");
			setAttr ($modCore + "_LowerLegIKCtrl_UpLctr_orientConstraint1.interpType") 2;
			
			aimConstraint -mo -aimVector 0 1 0 -upVector 0 0 1 -worldUpType "objectRotation" -worldUpVector 0 0 1 -worldUpObject ($modCore + "_LowerLegIKCtrl_UpLctr")
			($modCore + "_lowerLegIKLctr") ($modCore + "_LowerLegIKCtrlGrp2");
			spaceLocator -n ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset");
			delete `pointConstraint ($modCore + "_FootIKCtrl") ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset")`;
			parent ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset") ($modCore + "_FootBallPivotLctr");
			delete `orientConstraint ($modCore + "_LowerLegIKCtrlGrp2") ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset")`;
			parentConstraint -mo ($modCore + "_FootBallPivotLctr") ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset");

			orientConstraint -mo ($modCore + "_LowerLegIKCtrlGrp2") ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset") ($modCore + "_LowerLegIKCtrlGrp");
			
			delete `pointConstraint ("RRM_" + $prfx + $core + "_Knee2") ($modCore + "_LowerLegIKCtrl")`;
			$AnklePos = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Ankle")`;
			move -a $AnklePos[0] $AnklePos[1] $AnklePos[2] ($modCore + "_LowerLegIKCtrl.scalePivot") ($modCore + "_LowerLegIKCtrl.rotatePivot") ;
			makeIdentity -apply true -t 1 -s 1 ($modCore + "_LowerLegIKCtrl");
			
			//ADD ORIENTATION ATTRIBUTE FOR LOWER LEG IKCtrl ORIENTATION
			addAttr -ln "autoOrient" -at double -min 0 -max 1 -dv 1 ($modCore + "_LowerLegIKCtrl");
			setAttr -e-keyable 1 ($modCore + "_LowerLegIKCtrl.autoOrient");
			connectAttr -f ($modCore + "_LowerLegIKCtrl.autoOrient") ($modCore + "_LowerLegIKCtrlGrp_orientConstraint1." + $modCore + "_LowerLegIKCtrlGrp2W0");
			
			shadingNode -asUtility reverse -n ($modCore + "_LowerLegIKCtrl_Reverse");
			connectAttr -f ($modCore + "_LowerLegIKCtrl.autoOrient") ($modCore + "_LowerLegIKCtrl_Reverse.inputX");
			connectAttr -f ($modCore + "_LowerLegIKCtrl_Reverse.outputX") ($modCore + "_LowerLegIKCtrlGrp_orientConstraint1." + $modCore + "_LowerLegIKCtrlGrp2_LctrOffsetW1");
			setAttr ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset.v") 0;

			spaceLocator -n ($modCore + "_LowerKneeIKOffsetLctr");
			delete `pointConstraint ($modCore + "_Knee2Jnt") ($modCore + "_LowerKneeIKOffsetLctr")`;
		}

		//KNEE AIM LOCATORS
		spaceLocator -n ($modCore + "_KneeIKCtrl_TargetLctr");
		spaceLocator -n ($modCore + "_KneeIKCtrl_HipLctr");
		spaceLocator -n ($modCore + "_KneeIKCtrl_AnkleLctr");
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Hip") ($modCore + "_KneeIKCtrl_HipLctr")`;
		parentConstraint -mo ($modCore + "_ScaleGrp") ($modCore + "_KneeIKCtrl_HipLctr");
		
		delete `pointConstraint ("RRM_" + $prfx + $core + "_Ankle") ($modCore + "_KneeIKCtrl_AnkleLctr")`;
		parentConstraint -mo ($modCore + "_FootBallPivotLctr2")  ($modCore + "_KneeIKCtrl_AnkleLctr");
		
		parent ($modCore + "_KneeIKCtrl_HipLctr") ($modCore + "_KneeIKCtrl_AnkleLctr") ($modCore + "_ScaleGrp");
		setAttr ($modCore + "_KneeIKCtrl_HipLctr.v") 0;
		setAttr ($modCore + "_KneeIKCtrl_AnkleLctr.v") 0;
			
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{	
			delete `pointConstraint ($modCore + "_KneeJnt") ($modCore + "_KneeIKCtrl_TargetLctr")`;
			pointConstraint -mo ($modCore + "_KneeIKCtrl_HipLctr") ($modCore + "_KneeIKCtrl_AnkleLctr") ($modCore + "_KneeIKCtrl_TargetLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			($modCore + "_KneeIKCtrl_TargetLctr") ($modCore + "_KneeIKCtrl");
		}
		else
		{
			pointConstraint ($modCore + "_KneeIKCtrl_HipLctr") ($modCore + "_LowerKneeIKOffsetLctr") ($modCore + "_KneeIKCtrl_TargetLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modName + "_MAINCtrl")
			($modCore + "_KneeIKCtrl_TargetLctr") ($modCore + "_KneeIKCtrl");
		}
			

		//IK SCALE
		
		//NODES
		spaceLocator -n ($modCore + "_LegLengthOriginLctr");
		pointConstraint ($modCore + "_HipJntIK") ($modCore + "_LegLengthOriginLctr");
		
		spaceLocator -n ($modCore + "_LegLengthEndLctr");
		parent ($modCore + "_LegLengthEndLctr") ($modCore + "_LegLengthOriginLctr");
		

		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			delete `pointConstraint ($modCore + "_FootIKCtrl") ($modCore + "_LegLengthEndLctr")`;
			parentConstraint ($modCore + "_KneeIKCtrl_AnkleLctr") ($modCore + "_LegLengthEndLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_KneeIKCtrl_AnkleLctr") ($modCore + "_LegLengthOriginLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_LowerLegIKCLctr");
			setAttr ($modCore + "_LowerLegIKCLctr.v") 0;
			delete `parentConstraint ($modCore + "_Knee2Jnt") ($modCore + "_LowerLegIKCLctr")`;
			parent  ($modCore + "_LowerLegIKCLctr") ($modCore + "_LowerLegIKCtrl");
			pointConstraint ($modCore + "_LowerLegIKCLctr") ($modCore + "_LegLengthEndLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_LowerKneeIKOffsetLctr") ($modCore + "_LegLengthOriginLctr");
		}


		shadingNode -asUtility multiplyDivide -n ($modCore + "_LegLength_MD");
		setAttr ($modCore + "_LegLength_MD.operation") 2;
		connectAttr -f ($modCore + "_LegLengthEndLctr.translateX") ($modCore + "_LegLength_MD.input1X");
		setAttr ($modCore + "_LegLength_MD.input2X") ($lLegLength*2);
		
		shadingNode -asUtility condition -n ($modCore + "_LegLength_Condition");
		connectAttr -f ($modCore + "_LegLength_MD.outputX") ($modCore + "_LegLength_Condition.firstTerm");
		setAttr ($modCore + "_LegLength_Condition.secondTerm") 1;
		setAttr ($modCore + "_LegLength_Condition.operation") 2;
		connectAttr -f ($modCore + "_LegLength_MD.outputX") ($modCore + "_LegLength_Condition.colorIfTrueR");
		
		shadingNode -asUtility blendColors -n ($modCore + "_LegLength_Blnd");
		connectAttr -f ($modCore + "_LegLength_Condition.outColorR") ($modCore + "_LegLength_Blnd.color1R");
		setAttr ($modCore + "_LegLength_Blnd.color2") -type double3 1 0 1 ;
		
		//ADD STRETCH TO IK ANKLE CONTROL
		addAttr -ln "stretch"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_FootIKCtrl");

		//LEG IK LOCK
		
		//LEG IK LOCK LOCATORS
		spaceLocator -n ($modCore + "_HipIKLockLctr");
		spaceLocator -n ($modCore + "_KneeIKLockLctr");
		spaceLocator -n ($modCore + "_AnkleIKLockLctr");
		parent ($modCore + "_KneeIKLockLctr") ($modCore + "_HipIKLockLctr");
		parent ($modCore + "_AnkleIKLockLctr") ($modCore + "_KneeIKLockLctr");
		pointConstraint ($modCore + "_HipJntIK") ($modCore + "_HipIKLockLctr");
		aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_KneeIKCtrl") ($modCore + "_HipIKLockLctr");
		pointConstraint ($modCore + "_KneeIKCtrl") ($modCore + "_KneeIKLockLctr");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_FootIKCtrl") ($modCore + "_KneeIKLockLctr");
			delete `pointConstraint ($modCore + "_FootIKCtrl") ($modCore + "_AnkleIKLockLctr")`;
			parentConstraint -mo ($modCore + "_FootBallPivotLctr2") ($modCore + "_AnkleIKLockLctr");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_HipLockLength_MD");
			setAttr ($modCore + "_HipLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_KneeIKLockLctr.translateX") ($modCore + "_HipLockLength_MD.input1X");
			setAttr ($modCore + "_HipLockLength_MD.input2X") $lKneeLength[0];
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_kneeLockLength_MD");
			setAttr ($modCore + "_kneeLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_AnkleIKLockLctr.translateX") ($modCore + "_kneeLockLength_MD.input1X");
			setAttr ($modCore + "_kneeLockLength_MD.input2X") $lAnkleLength[0];
			
			shadingNode -asUtility blendColors -n ($modCore + "_HipLock_Blnd");
			connectAttr -f ($modCore + "_HipLockLength_MD.outputX") ($modCore + "_HipLock_Blnd.color1R");
			connectAttr -f ($modCore + "_LegLength_Blnd.outputR") ($modCore + "_HipLock_Blnd.color2R");
			
			shadingNode -asUtility blendColors -n ($modCore + "_kneeLock_Blnd");
			connectAttr -f ($modCore + "_kneeLockLength_MD.outputX") ($modCore + "_kneeLock_Blnd.color1R");
			connectAttr -f ($modCore + "_LegLength_Blnd.outputR") ($modCore + "_kneeLock_Blnd.color2R");
		}
		else
		{
			parent ($modCore + "_LowerKneeIKOffsetLctr") ($modCore + "_HipIKLockLctr");
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore + "_LowerLegIKCtrl") ($modCore + "_LowerKneeIKOffsetLctr");
			
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_LowerKneeIKOffsetLctr") ($modCore + "_KneeIKLockLctr");
			pointConstraint ($modCore + "_LowerKneeIKOffsetLctr") ($modCore + "_AnkleIKLockLctr");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_HipLockLength_MD");
			setAttr ($modCore + "_HipLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_KneeIKLockLctr.translateX") ($modCore + "_HipLockLength_MD.input1X");
			setAttr ($modCore + "_HipLockLength_MD.input2X") $lKnee1Length[0];
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_kneeLockLength_MD");
			setAttr ($modCore + "_kneeLockLength_MD.operation") 2;
			connectAttr -f ($modCore + "_AnkleIKLockLctr.translateX") ($modCore + "_kneeLockLength_MD.input1X");
			setAttr ($modCore + "_kneeLockLength_MD.input2X") $lKnee2Length[0];
			
			shadingNode -asUtility blendColors -n ($modCore + "_HipLock_Blnd");
			connectAttr -f ($modCore + "_HipLockLength_MD.outputX") ($modCore + "_HipLock_Blnd.color1R");
			connectAttr -f ($modCore + "_LegLength_Blnd.outputR") ($modCore + "_HipLock_Blnd.color2R");
			
			shadingNode -asUtility blendColors -n ($modCore + "_kneeLock_Blnd");
			connectAttr -f ($modCore + "_kneeLockLength_MD.outputX") ($modCore + "_kneeLock_Blnd.color1R");
			connectAttr -f ($modCore + "_LegLength_Blnd.outputR") ($modCore + "_kneeLock_Blnd.color2R");

			//AUTO STRETCH ON LOWER LEG IK CONTROL
			addAttr -ln "lowerScale" -at double -min 0.01 -dv 1 ($modCore + "_LowerLegIKCtrl");
			setAttr -e-keyable 1 ($modCore + "_LowerLegIKCtrl.lowerScale");
			
			//GET LEG LENGTH
			
			$Knee1Length2 = `getAttr ($modCore + "_Knee1Jnt.tx")`;
			$Knee2Length2 = `getAttr ($modCore + "_Knee2Jnt.tx")`;
			$AnkleLength2 = `getAttr ($modCore + "_AnkleJnt.tx")`;
			$FullLegLength = ($Knee1Length2 + $Knee2Length2 + $AnkleLength2);
			
			//LEG LENGTH LOCATORS
			spaceLocator -n ($modCore + "_FullLegLengthAimLctr");
			spaceLocator -n ($modCore + "_FullLegLengthEndLctr");
			parent ($modCore + "_FullLegLengthEndLctr") ($modCore + "_FullLegLengthAimLctr");
			parent ($modCore + "_FullLegLengthAimLctr") ($modCore + "_ScaleGrp");
			pointConstraint ($modCore + "_HipJntIK") ($modCore + "_FullLegLengthAimLctr");
			pointConstraint ($modCore + "_LowerLegIKCtrlGrp2_LctrOffset") ($modCore + "_FullLegLengthEndLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ($modCore + "_FootIKCtrl") ($modCore + "_FullLegLengthAimLctr");

			shadingNode -asUtility multiplyDivide -n ($modCore + "_FullLegLength_MD");
			setAttr ($modCore + "_FullLegLength_MD.operation") 2;
			connectAttr -force ($modCore + "_FullLegLengthEndLctr.translateX") ($modCore + "_FullLegLength_MD.input1X");
			setAttr ($modCore + "_FullLegLength_MD.input2X") $FullLegLength;
			
			shadingNode -asUtility condition -n ($modCore + "_FullLegLength_Condition");
			connectAttr -force ($modCore + "_FullLegLength_MD.outputX") ($modCore + "_FullLegLength_Condition.firstTerm");
			setAttr ($modCore + "_FullLegLength_Condition.secondTerm") 1;
			setAttr ($modCore + "_FullLegLength_Condition.operation") 2;
			connectAttr -force ($modCore + "_FullLegLength_MD.outputX") ($modCore + "_FullLegLength_Condition.colorIfTrueR");
			
			shadingNode -asUtility blendColors -n ($modCore + "_FullLegLength_Blnd");
			connectAttr -force ($modCore + "_FootIKCtrl.stretch") ($modCore + "_FullLegLength_Blnd.blender");
			connectAttr -force ($modCore + "_FullLegLength_Condition.outColorR") ($modCore + "_FullLegLength_Blnd.color1R");
			setAttr ($modCore + "_FullLegLength_Blnd.color2R") 1;
			
			setAttr ($modCore + "_FullLegLengthAimLctr.v") 0;
			
			//MULTIPLY STRETCH WITH LOWER SCALE
			shadingNode -asUtility multiplyDivide -n ($modCore + "_FullLegLength2_MD");
			connectAttr -force ($modCore + "_LowerLegIKCtrl.lowerScale") ($modCore + "_FullLegLength2_MD.input1X");
			connectAttr -force ($modCore + "_FullLegLength_Blnd.outputR") ($modCore + "_FullLegLength2_MD.input2X");
			connectAttr -force ($modCore + "_FullLegLength2_MD.outputX") ($modCore + "_LowerLegIKCtrl.scaleY");
			
			//CREATE MULTIPLY/DIVIDE TO CONNECT TO THE KNEE2JntIK
			shadingNode -asUtility multiplyDivide -n ($modCore + "_FullLegLength2_Inv_MD");
			setAttr ($modCore + "_FullLegLength2_Inv_MD.operation") 2;
			setAttr ($modCore + "_FullLegLength2_Inv_MD.input1X")  1;
			connectAttr ($modCore + "_FullLegLength2_MD.outputX") ($modCore + "_Knee2JntIK.scaleX");
			connectAttr ($modCore + "_FullLegLength2_MD.outputX") ($modCore + "_FullLegLength2_Inv_MD.input2X");
		}
		
			
		//ADD STRETCH TO IK ANKLE CONTROL
		setAttr -e-k true ($modCore + "_FootIKCtrl.stretch");
		connectAttr -f ($modCore + "_FootIKCtrl.stretch") ($modCore + "_LegLength_Blnd.blender");
		
		//ADD KNEE LOCK TO IK ANKLE CONTROL
		addAttr -ln "kneeLock"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_FootIKCtrl");
		setAttr -e-k true ($modCore + "_FootIKCtrl.kneeLock");
		connectAttr -f ($modCore + "_FootIKCtrl.kneeLock") ($modCore + "_HipLock_Blnd.blender");
		connectAttr -f ($modCore + "_FootIKCtrl.kneeLock") ($modCore + "_kneeLock_Blnd.blender");
		
		//ADD LEG SCALE
		addAttr -ln "legScale"  -at double  -min 0.01 -dv 1 ($modCore + "_FootIKCtrl");
		setAttr -e-k true ($modCore + "_FootIKCtrl.legScale");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_HipScale_MD");
		connectAttr -force ($modCore + "_HipLock_Blnd.outputR") ($modCore + "_HipScale_MD.input1X");
		connectAttr -force ($modCore + "_FootIKCtrl.legScale") ($modCore + "_HipScale_MD.input2X");
		connectAttr -force ($modCore + "_HipScale_MD.outputX") ($modCore + "_HipJntIK.scaleX");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_KneeScale_MD");
		connectAttr -force ($modCore + "_kneeLock_Blnd.outputR") ($modCore + "_KneeScale_MD.input1X");
		connectAttr -force ($modCore + "_FootIKCtrl.legScale") ($modCore + "_KneeScale_MD.input2X");
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			connectAttr -force ($modCore + "_KneeScale_MD.outputX") ($modCore + "_KneeJntIK.scaleX");
		}
		else
		{
			connectAttr -force ($modCore + "_KneeScale_MD.outputX") ($modCore + "_Knee1JntIK.scaleX");
		}
	
		
	
		//////////////////////////////////FOOT IKFK SWITCH CONTROL///////////////////////////////////////////
		curve -n ($modCore + "_SwitchCtrl") -d 1 -p 0 0 0 -p -2 0 -2 -p -1 0 -2 -p -1 0 -5 -p 1 0 -5 -p 1 0 -2
		-p 2 0 -2 -p 0 0 0 -p 0 2 -2 -p 0 1 -2 -p 0 1 -5 -p 0 -1 -5 -p 0 -1 -2
		-p 0 -2 -2 -p 0 0 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10
		-k 11 -k 12 -k 13 -k 14 ;
		rename `listRelatives -c ($modCore + "_SwitchCtrl")` ($modCore + "_SwitchCtrlShape");
		
		move -r -os -wd 0 0 -8 ($modCore + "_SwitchCtrl");
		group -n ($modCore + "_SwitchCtrlGrp") ($modCore + "_SwitchCtrl"); xform -os -piv 0 0 0;
		scale -r 0.2 0.2 0.2 ($modCore + "_SwitchCtrlGrp");
		makeIdentity -apply true -t 0 -r 1 -s 1 ($modCore + "_SwitchCtrlGrp");
		delete `pointConstraint ($modCore + "_AnkleJnt") ($modCore + "_SwitchCtrlGrp")`;
		parent ($modCore + "_SwitchCtrlGrp") ($modCore + "_FootIKCtrlGrp");
		makeIdentity -apply false -r 1 ($modCore + "_SwitchCtrlGrp");
		parent -w ($modCore + "_SwitchCtrlGrp");
		
		setAttr (($modCore + "_SwitchCtrlGrp.scale"), ($lLegLength / 3.5), ($lLegLength / 3.5), ($lLegLength / 3.5));
		
		addAttr -ln "switchIkFk"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_SwitchCtrl");
		setAttr -e-k true ($modCore + "_SwitchCtrl.switchIkFk");
		addAttr -ln "autoVolume"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_SwitchCtrl");
		setAttr -e-k true ($modCore + "_SwitchCtrl.autoVolume");
		setAttr ($modCore + "_SwitchCtrl.autoVolume") 1;
		
		xform -cp ($modCore + "_SwitchCtrl");
		
		parentConstraint -mo ($modCore + "_AnkleJnt") ($modCore + "_SwitchCtrlGrp");
	
		
		//PARENT ORIENT
		$parentOrient = ($modCore + "_SwitchCtrl");
		RRM_ParentOrient_V1($modCore, $modName, $modAttachNode, $parentOrient); 
	
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////CONNECT CONTROLS///////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		
		//LEG
		
		//FK
		$lHipLocation = `xform -q -ws -t ($modCore + "_HipFKCtrlGrp")`;
		move $lHipLocation[0] $lHipLocation[1] $lHipLocation[2] ($modCore + "_HipFKCtrlGrp.scalePivot") ($modCore + "_HipFKCtrlGrp.rotatePivot") ;
		parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z
		($modName + "_" + $modAttachNode + "Jnt") ($modName + "_MAINCtrl") ($modCore + "_HipFKCtrlGrp");
		setAttr ($modCore + "_HipFKCtrlGrp_parentConstraint1.interpType") 2;
		
		//HIP ORIENT
		addAttr -ln "hipOrient"  -at double  -min 0 -max 1 -dv 1 ($modCore + "_HipFKCtrl");
		setAttr -e-k true ($modCore + "_HipFKCtrl.hipOrient");
	
		setAttr ($modCore + "_HipFKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_HipFKCtrl.hipOrient") ($modCore + "_HipFKCtrlGrp_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW0");
		setDrivenKeyframe -currentDriver ($modCore + "_HipFKCtrl.hipOrient") ($modCore + "_HipFKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW1");
		setAttr ($modCore + "_HipFKCtrl.hipOrient") 0;
		setAttr ($modCore + "_HipFKCtrlGrp_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW0") 0;
		setAttr ($modCore + "_HipFKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW1") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_HipFKCtrl.hipOrient") ($modCore + "_HipFKCtrlGrp_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW0");
		setDrivenKeyframe -currentDriver ($modCore + "_HipFKCtrl.hipOrient") ($modCore + "_HipFKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW1");
		setAttr ($modCore + "_HipFKCtrl.hipOrient") 1;
		
		keyTangent -itt spline -ott spline($modCore + "_HipFKCtrlGrp_parentConstraint1_" + $modName + "_" + $modAttachNode + "JntW0")
		($modCore + "_HipFKCtrlGrp_parentConstraint1_" + $modName + "_MAINCtrlW1");

		parentConstraint -mo ($modCore + "_HipFKCtrl") ($modCore + "_HipJntFK");
	
		connectAttr -f ($modCore + "_HipFKCtrl.scaleX") ($modCore + "_HipJntFK.scaleX");
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			parentConstraint -mo ($modCore + "_HipFKCtrl") ($modCore + "_KneeFKCtrlGrp");
			//parent ($modCore + "_KneeFKCtrlGrp") ($modCore + "_HipFKCtrl");
		
			parentConstraint -mo ($modCore + "_KneeFKCtrl") ($modCore + "_KneeJntFK");
			parentConstraint -mo ($modCore + "_KneeFKCtrl") ($modCore + "_AnkleFKCtrlGrp");
			//parent ($modCore + "_AnkleFKCtrlGrp") ($modCore + "_KneeFKCtrl");
	
			connectAttr -f ($modCore + "_HipFKCtrl.scaleX") ($modCore + "_KneeFKCtrl.scaleX");
		}
		else
		{
			parentConstraint -mo ($modCore + "_HipFKCtrl") ($modCore + "_Knee1FKCtrlGrp");
			//parent ($modCore + "_Knee1FKCtrlGrp") ($modCore + "_HipFKCtrl");
		
			parentConstraint -mo ($modCore + "_Knee1FKCtrl") ($modCore + "_Knee1JntFK");
			parentConstraint -mo ($modCore + "_Knee1FKCtrl") ($modCore + "_Knee2FKCtrlGrp");
			//parent ($modCore + "_Knee2FKCtrlGrp") ($modCore + "_Knee1FKCtrl");
	
			parentConstraint -mo ($modCore + "_Knee2FKCtrl") ($modCore + "_Knee2JntFK");
			parentConstraint -mo ($modCore + "_Knee2FKCtrl") ($modCore + "_AnkleFKCtrlGrp");
			//parent ($modCore + "_AnkleFKCtrlGrp") ($modCore + "_Knee2FKCtrl");
	
			connectAttr -f ($modCore + "_HipFKCtrl.scaleX") ($modCore + "_Knee1FKCtrl.scaleX");
			connectAttr -f ($modCore + "_HipFKCtrl.scaleX") ($modCore + "_Knee2FKCtrl.scaleX");
		}
			
		parentConstraint -mo ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleJntFK");
		setAttr ($modCore + "_AnkleJntFK_parentConstraint1.interpType") 2;
		
		parentConstraint -mo ($modCore + "_AnkleFKCtrl") ($modCore + "_BallFKCtrlGrp");
		//parent ($modCore + "_BallFKCtrlGrp") ($modCore + "_AnkleFKCtrl");
		parentConstraint -mo ($modCore + "_BallFKCtrl") ($modCore + "_BallJntFK");
		setAttr ($modCore + "_BallFKCtrlGrp_parentConstraint1.interpType") 2;
		//setAttr ($modCore + "_BallJntFK_parentConstraint1.interpType") 2;
		
		parentConstraint -mo ($modCore + "_BallFKCtrl") ($modCore + "_ToeFKCtrlGrp");
		//parent ($modCore + "_ToeFKCtrlGrp") ($modCore + "_BallFKCtrl");
		parentConstraint -mo ($modCore + "_ToeFKCtrl")  ($modCore + "_ToeJntFK");
		setAttr ($modCore + "_ToeFKCtrlGrp_parentConstraint1.interpType") 2;
		setAttr ($modCore + "_ToeJntFK_parentConstraint1.interpType") 2;
		
		//CONNECT SCALE TO FK CONTROLS
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			connectAttr -f ($modCore + "_HipFKCtrl.scaleX") ($modCore + "_KneeJntFK.scaleX");
		}
		else
		{
			connectAttr -f ($modCore + "_HipFKCtrl.scaleX") ($modCore + "_Knee1JntFK.scaleX");
			connectAttr -f ($modCore + "_HipFKCtrl.scaleX") ($modCore + "_Knee2JntFK.scaleX");
		}
	
		//IK
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			select ($modCore + "_HipJntIK.rotatePivot") ($modCore + "_AnkleJntIK.rotatePivot") ;
			ikHandle -n ($modCore + "_LegIKHandle") -sol ikRPsolver;
			parent ($modCore + "_LegIKHandle") ($modCore + "_FootBallPivotLctr2");
		}
		else
		{
			select ($modCore + "_Knee2JntIK.rotatePivot") ($modCore + "_AnkleJntIK.rotatePivot");
			ikHandle -n ($modCore + "_LowerLegIKHandle") -sol ikSCsolver;
			parent ($modCore + "_LowerLegIKHandle") ($modCore + "_FootBallPivotLctr2");
			parentConstraint -mo ($modCore + "_FootBallPivotLctr2") ($modCore + "_LowerLegIKHandle");
	
			select ($modCore + "_HipJntIK.rotatePivot") ($modCore + "_Knee2JntIK.rotatePivot") ;
			ikHandle -n ($modCore + "_LegIKHandle") -sol ikRPsolver;
			parent ($modCore + "_LegIKHandle") ($modCore + "_LowerLegIKCtrl");
			
		}
		poleVectorConstraint ($modCore + "_KneeIKCtrl") ($modCore + "_LegIKHandle") ;
		parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z -weight 1 ($modCore + "_FootIKCtrl") ($modCore + "_AnkleJntIK");
		setAttr ($modCore + "_AnkleJntIK_parentConstraint1.interpType") 2;	
		
		//CONNECT IK AND FK JOINTS TO ORIGINALS
		//HIP
		shadingNode -asUtility blendColors -n ($modCore + "_HipJntIKFK_BlndScale");
		connectAttr -f ($modCore + "_HipJntFK.scale") ($modCore + "_HipJntIKFK_BlndScale.color1");
		connectAttr -f ($modCore + "_HipJntIK.scale") ($modCore + "_HipJntIKFK_BlndScale.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_HipJntIKFK_BlndScale.blender");
		
		shadingNode -asUtility multiplyDivide -n ($modCore + "_HipVolume_MD");
		setAttr ($modCore + "_HipVolume_MD.input1X") 1;
		setAttr ($modCore + "_HipVolume_MD.operation") 2;
		connectAttr -f ($modCore + "_HipJntIKFK_BlndScale.outputR") ($modCore + "_HipVolume_MD.input2X");
		
		shadingNode -asUtility blendColors -n ($modCore + "_HipJntIKFK_AutoBlnd");
		setAttr ($modCore + "_HipJntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
		connectAttr -f ($modCore + "_HipVolume_MD.outputX") ($modCore + "_HipJntIKFK_AutoBlnd.color1R");
		connectAttr -f ($modCore + "_HipJntIKFK_AutoBlnd.outputR") ($modCore + "_HipJnt.scaleY");
		connectAttr -f ($modCore + "_HipJntIKFK_AutoBlnd.outputR") ($modCore + "_HipJnt.scaleZ");
		connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_HipJntIKFK_AutoBlnd.blender");
		
		shadingNode -asUtility blendColors -n  ($modCore + "_HipJntIKFK_BlndRotate");
		connectAttr -f ($modCore + "_HipJntFK.rotate") ($modCore + "_HipJntIKFK_BlndRotate.color1");
		connectAttr -f ($modCore + "_HipJntIK.rotate") ($modCore + "_HipJntIKFK_BlndRotate.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_HipJntIKFK_BlndRotate.blender");
		
		connectAttr -f ($modCore + "_HipJntIKFK_BlndScale.outputR") ($modCore + "_HipJnt.scaleX");
		connectAttr -f ($modCore + "_HipJntIKFK_BlndRotate.output") ($modCore + "_HipJnt.rotate");
		
		//KNEE
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			shadingNode -asUtility blendColors -n ($modCore + "_KneeJntIKFK_BlndScale");
			connectAttr -f ($modCore + "_KneeJntFK.scale") ($modCore + "_KneeJntIKFK_BlndScale.color1");
			connectAttr -f ($modCore + "_KneeJntIK.scale") ($modCore + "_KneeJntIKFK_BlndScale.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_KneeJntIKFK_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_KneeVolume_MD");
			setAttr ($modCore + "_KneeVolume_MD.input1X") 1;
			setAttr ($modCore + "_KneeVolume_MD.operation") 2;
			connectAttr -f ($modCore + "_KneeJntIKFK_BlndScale.outputR") ($modCore + "_KneeVolume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_KneeJntIKFK_AutoBlnd");
			setAttr ($modCore + "_KneeJntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_KneeVolume_MD.outputX") ($modCore + "_KneeJntIKFK_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_KneeJntIKFK_AutoBlnd.outputR") ($modCore + "_KneeJnt.scaleY");
			connectAttr -f ($modCore + "_KneeJntIKFK_AutoBlnd.outputR") ($modCore + "_KneeJnt.scaleZ");
			connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_KneeJntIKFK_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_KneeJntIKFK_BlndRotate");
			connectAttr -f ($modCore + "_KneeJntFK.rotate") ($modCore + "_KneeJntIKFK_BlndRotate.color1");
			connectAttr -f ($modCore + "_KneeJntIK.rotate") ($modCore + "_KneeJntIKFK_BlndRotate.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_KneeJntIKFK_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_KneeJntIKFK_BlndScale.outputR") ($modCore + "_KneeJnt.scaleX");
			connectAttr -f ($modCore + "_KneeJntIKFK_BlndRotate.output") ($modCore + "_KneeJnt.rotate");
		}
		else
		{
			shadingNode -asUtility blendColors -n ($modCore + "_Knee1JntIKFK_BlndScale");
			connectAttr -f ($modCore + "_Knee1JntFK.scale") ($modCore + "_Knee1JntIKFK_BlndScale.color1");
			connectAttr -f ($modCore + "_Knee1JntIK.scale") ($modCore + "_Knee1JntIKFK_BlndScale.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Knee1JntIKFK_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_Knee1Volume_MD");
			setAttr ($modCore + "_Knee1Volume_MD.input1X") 1;
			setAttr ($modCore + "_Knee1Volume_MD.operation") 2;
			connectAttr -f ($modCore + "_Knee1JntIKFK_BlndScale.outputR") ($modCore + "_Knee1Volume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Knee1JntIKFK_AutoBlnd");
			setAttr ($modCore + "_Knee1JntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_Knee1Volume_MD.outputX") ($modCore + "_Knee1JntIKFK_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_Knee1JntIKFK_AutoBlnd.outputR") ($modCore + "_Knee1Jnt.scaleY");
			connectAttr -f ($modCore + "_Knee1JntIKFK_AutoBlnd.outputR") ($modCore + "_Knee1Jnt.scaleZ");
			connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_Knee1JntIKFK_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Knee1JntIKFK_BlndRotate");
			connectAttr -f ($modCore + "_Knee1JntFK.rotate") ($modCore + "_Knee1JntIKFK_BlndRotate.color1");
			connectAttr -f ($modCore + "_Knee1JntIK.rotate") ($modCore + "_Knee1JntIKFK_BlndRotate.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Knee1JntIKFK_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_Knee1JntIKFK_BlndScale.outputR") ($modCore + "_Knee1Jnt.scaleX");
			connectAttr -f ($modCore + "_Knee1JntIKFK_BlndRotate.output") ($modCore + "_Knee1Jnt.rotate");
	
			shadingNode -asUtility blendColors -n ($modCore + "_Knee2JntIKFK_BlndScale");
			connectAttr -f ($modCore + "_Knee2JntFK.scale") ($modCore + "_Knee2JntIKFK_BlndScale.color1");
			connectAttr -f ($modCore + "_Knee2JntIK.scale") ($modCore + "_Knee2JntIKFK_BlndScale.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Knee2JntIKFK_BlndScale.blender");
			
			shadingNode -asUtility multiplyDivide -n ($modCore + "_Knee2Volume_MD");
			setAttr ($modCore + "_Knee2Volume_MD.input1X") 1;
			setAttr ($modCore + "_Knee2Volume_MD.operation") 2;
			connectAttr -f ($modCore + "_Knee2JntIKFK_BlndScale.outputR") ($modCore + "_Knee2Volume_MD.input2X");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Knee2JntIKFK_AutoBlnd");
			setAttr ($modCore + "_Knee2JntIKFK_AutoBlnd.color2") -type double3 1 1 1 ;
			connectAttr -f ($modCore + "_Knee2Volume_MD.outputX") ($modCore + "_Knee2JntIKFK_AutoBlnd.color1R");
			connectAttr -f ($modCore + "_Knee2JntIKFK_AutoBlnd.outputR") ($modCore + "_Knee2Jnt.scaleY");
			connectAttr -f ($modCore + "_Knee2JntIKFK_AutoBlnd.outputR") ($modCore + "_Knee2Jnt.scaleZ");
			connectAttr -f ($modCore + "_SwitchCtrl.autoVolume") ($modCore + "_Knee2JntIKFK_AutoBlnd.blender");
			
			shadingNode -asUtility blendColors -n ($modCore + "_Knee2JntIKFK_BlndRotate");
			connectAttr -f ($modCore + "_Knee2JntFK.rotate") ($modCore + "_Knee2JntIKFK_BlndRotate.color1");
			connectAttr -f ($modCore + "_Knee2JntIK.rotate") ($modCore + "_Knee2JntIKFK_BlndRotate.color2");
			connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_Knee2JntIKFK_BlndRotate.blender");
			
			connectAttr -f ($modCore + "_Knee2JntIKFK_BlndScale.outputR") ($modCore + "_Knee2Jnt.scaleX");
			connectAttr -f ($modCore + "_Knee2JntIKFK_BlndRotate.output") ($modCore + "_Knee2Jnt.rotate");
		}		
	
		//ANKLE
		shadingNode -asUtility blendColors -n ($modCore + "_AnkleJntIKFK_BlndRotate");
		connectAttr -f ($modCore + "_AnkleJntFK.rotate") ($modCore + "_AnkleJntIKFK_BlndRotate.color1");
		connectAttr -f ($modCore + "_AnkleJntIK.rotate") ($modCore + "_AnkleJntIKFK_BlndRotate.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_AnkleJntIKFK_BlndRotate.blender");
		
		connectAttr -f ($modCore + "_AnkleJntIKFK_BlndRotate.output") ($modCore + "_AnkleJnt.rotate");
		
		//BALL
		shadingNode -asUtility blendColors -n ($modCore + "_BallJntIKFK_BlndRotate");
		connectAttr -f ($modCore + "_BallJntFK.rotate") ($modCore + "_BallJntIKFK_BlndRotate.color1");
		connectAttr -f ($modCore + "_BallJntIK.rotate") ($modCore + "_BallJntIKFK_BlndRotate.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_BallJntIKFK_BlndRotate.blender");
		
		connectAttr -f ($modCore + "_BallJntIKFK_BlndRotate.output") ($modCore + "_BallJnt.rotate");
		
		//TOE
		shadingNode -asUtility blendColors -n ($modCore + "_ToeJntIKFK_BlndRotate");
		connectAttr -f ($modCore + "_ToeJntFK.rotate") ($modCore + "_ToeJntIKFK_BlndRotate.color1");
		connectAttr -f ($modCore + "_ToeJntIK.rotate") ($modCore + "_ToeJntIKFK_BlndRotate.color2");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_ToeJntIKFK_BlndRotate.blender");
		
		connectAttr -f ($modCore + "_ToeJntIKFK_BlndRotate.output") ($modCore + "_ToeJnt.rotate");
		
		//KNEE IKCtrl FOLLOW
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_FootBallPivotLctr2") ($modCore + "_HipFKCtrl") ($modCore + "_KneeIKCtrlGrp");
		addAttr -ln "follow"  -at "enum" -en "Main:Ankle:Hip:Ankle and Hip:" ($modCore + "_KneeIKCtrl");
		setAttr -e-keyable 1 ($modCore + "_KneeIKCtrl.follow");
		setAttr ($modCore + "_KneeIKCtrl.follow") 0;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_HipFKCtrlW2") 0;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_HipFKCtrlW2");
		
		setAttr ($modCore + "_KneeIKCtrl.follow") 1;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0") 0;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_HipFKCtrlW2");
		
		setAttr ($modCore + "_KneeIKCtrl.follow") 2;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_HipFKCtrlW2") 1;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_HipFKCtrlW2");
		
		setAttr ($modCore + "_KneeIKCtrl.follow") 3;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1") 1;
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_HipFKCtrlW2") 1;
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_FootBallPivotLctr2W1");
		setDrivenKeyframe -currentDriver ($modCore + "_KneeIKCtrl.follow") ($modCore + "_KneeIKCtrlGrp_parentConstraint1." + $modCore + "_HipFKCtrlW2");
		
		setAttr ($modCore + "_KneeIKCtrl.follow") 0;
		
		//FOOT
		addAttr -ln "footTilt"  -at double  -min -10 -max 10 -dv 0 ($modCore+ "_FootIKCtrl");
		setAttr -e-k true ($modCore+ "_FootIKCtrl.footTilt");
		addAttr -ln "ballUpDn"  -at double  -min -10 -max 10 -dv 0 ($modCore+ "_FootIKCtrl");
		setAttr -e-k true ($modCore+ "_FootIKCtrl.ballUpDn");
		addAttr -ln "toeUpDn"  -at double  -min -10 -max 10 -dv 0 ($modCore+ "_FootIKCtrl");
		setAttr -e-k true ($modCore+ "_FootIKCtrl.toeUpDn");
		addAttr -ln "ballSwivel"  -at double -dv 0 ($modCore+ "_FootIKCtrl");
		setAttr -e-k true ($modCore+ "_FootIKCtrl.ballSwivel");
		addAttr -ln "heelBall"  -at double -min -10 -max 10 -dv 0 ($modCore+ "_FootIKCtrl");
		setAttr -e-k true ($modCore+ "_FootIKCtrl.heelBall");
		//SDK TILT
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.footTilt") ($modCore + "_FootRightTiltLctr.rotateZ");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.footTilt") ($modCore + "_FootLeftTiltLctr.rotateZ");
		setAttr ($modCore + "_FootIKCtrl.footTilt") -10;
		rotate -r 0 0 90 ($modCore + "_FootRightTiltLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.footTilt") ($modCore + "_FootRightTiltLctr.rotateZ");
		setAttr ($modCore + "_FootIKCtrl.footTilt") 10;
		rotate -r 0 0 -90 ($modCore + "_FootLeftTiltLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.footTilt") ($modCore + "_FootLeftTiltLctr.rotateZ");
		setAttr ($modCore + "_FootIKCtrl.footTilt") 0;
		//SDK HEEL UP DN
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.ballUpDn") ($modCore + "_FootBallPivotLctr.rotateX");
		setAttr ($modCore + "_FootIKCtrl.ballUpDn") -10;
		rotate -r -90 0 0 ($modCore + "_FootBallPivotLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.ballUpDn") ($modCore + "_FootBallPivotLctr.rotateX");
		setAttr ($modCore + "_FootIKCtrl.ballUpDn") 10;
		rotate -r 90 0 0 ($modCore + "_FootBallPivotLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.ballUpDn") ($modCore + "_FootBallPivotLctr.rotateX");
		setAttr ($modCore + "_FootIKCtrl.ballUpDn") 0;
		//SDK TOE UP DN
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.toeUpDn") ($modCore + "_FootToePivotLctr.rotateX");
		setAttr ($modCore + "_FootIKCtrl.toeUpDn") -10;
		rotate -r 90 0 0 ($modCore + "_FootToePivotLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.toeUpDn") ($modCore + "_FootToePivotLctr.rotateX");
		setAttr ($modCore + "_FootIKCtrl.toeUpDn") 10;
		rotate -r -90 0 0 ($modCore + "_FootToePivotLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.toeUpDn") ($modCore + "_FootToePivotLctr.rotateX");
		setAttr ($modCore + "_FootIKCtrl.toeUpDn") 0;
		//SDK BALL SWIVEL		
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.ballSwivel") ($modCore + "_BallSwivelLctr.rotateY");
		setAttr ($modCore + "_FootIKCtrl.ballSwivel") -10;
		rotate -r 0 90 0 ($modCore + "_BallSwivelLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.ballSwivel") ($modCore + "_BallSwivelLctr.rotateY");
		setAttr ($modCore + "_FootIKCtrl.ballSwivel") 10;
		rotate -r 0 -90 0 ($modCore + "_BallSwivelLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.ballSwivel") ($modCore + "_BallSwivelLctr.rotateY");
		setAttr ($modCore + "_FootIKCtrl.ballSwivel") 0;
		//SDK HEEL BALL (LEGACY)
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.heelBall") ($modCore + "_HeelLctr.rotateX");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.heelBall") ($modCore + "_FootBallPivotLctr2.rotateX");
		setAttr ($modCore + "_FootIKCtrl.heelBall") -10;
		rotate -r -90 0 0 ($modCore + "_HeelLctr");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.heelBall") ($modCore + "_HeelLctr.rotateX");
		setAttr ($modCore + "_FootIKCtrl.heelBall") 10;
		rotate -r 90 0 0 ($modCore + "_FootBallPivotLctr2");
		setDrivenKeyframe -currentDriver ($modCore + "_FootIKCtrl.heelBall") ($modCore + "_FootBallPivotLctr2.rotateX");
		setAttr ($modCore + "_FootIKCtrl.heelBall") 0;
		
		keyTangent -itt spline -ott spline
		($modCore + "_KneeIKCtrlGrp_parentConstraint1_" + $modName + "_MAINCtrlW0")
		($modCore + "_KneeIKCtrlGrp_parentConstraint1_" + $modCore + "_FootBallPivotLctr2W1")
		($modCore + "_KneeIKCtrlGrp_parentConstraint1_" + $modCore + "_HipFKCtrlW2")
		($modCore + "_FootRightTiltLctr_rotateZ")
		($modCore + "_FootLeftTiltLctr_rotateZ")
		($modCore + "_FootToePivotLctr_rotateX")
		($modCore + "_FootBallPivotLctr_rotateX")
		($modCore + "_FootBallPivotLctr2_rotateX")
		($modCore + "_BallSwivelLctr_rotateY")
		($modCore + "_HeelLctr_rotateX");
		//keyTangent -itt spline -ott spline ;
	
		setInfinity -pri linear ($modCore + "_BallSwivelLctr.ry");
		setInfinity -poi linear ($modCore + "_BallSwivelLctr.ry");
		
	
		//CONNECTOR LINE
		curve -n ($modCore + "_KneeIKConnectorCtrl") -d 1 -p 0 0 0 -p 0 0 1 -k 0 -k 1 ;
		rename `listRelatives -c ($modCore + "_KneeIKConnectorCtrl")` ($modCore + "_KneeIKConnectorCtrlShape");
		delete `parentConstraint ($modCore + "_KneeIKCtrl") ($modCore + "_KneeIKConnectorCtrl") `;
		parent ($modCore + "_KneeIKConnectorCtrl") ($modCore + "_KneeIKCtrl");
		spaceLocator -n ($modCore + "_KneeIKAimConnectorLctr");
		spaceLocator -n ($modCore + "_KneeIKTargetConnectorLctr");
		parent ($modCore + "_KneeIKTargetConnectorLctr") ($modCore + "_KneeIKAimConnectorLctr");
		delete `parentConstraint ($modCore + "_KneeIKCtrl") ($modCore + "_KneeIKAimConnectorLctr")`;
		parent ($modCore + "_KneeIKAimConnectorLctr") ($modCore + "_KneeIKCtrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_KneeIKAimConnectorLctr");
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			pointConstraint ($modCore + "_KneeJnt") ($modCore + "_KneeIKTargetConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_KneeJnt") ($modCore + "_KneeIKAimConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_KneeJnt") ($modCore + "_KneeIKConnectorCtrl");
		}
		else
		{
			pointConstraint  ($modCore + "_Knee1Jnt") ($modCore + "_KneeIKTargetConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_Knee1Jnt") ($modCore + "_KneeIKAimConnectorLctr");
			aimConstraint -offset 0 0 0 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "none"
			($modCore + "_Knee1Jnt") ($modCore + "_KneeIKConnectorCtrl");
		}
		connectAttr -f ($modCore + "_KneeIKTargetConnectorLctr.tz") ($modCore + "_KneeIKConnectorCtrl.sz");
		setAttr ($modCore + "_KneeIKAimConnectorLctr.v") 0;

		addAttr -ln "nonControl"  -dt "string" ($modCore + "_KneeIKConnectorCtrl");
		setAttr -e-keyable 1 ($modCore + "_KneeIKConnectorCtrl.nonControl");
		setAttr -lock 1 ($modCore + "_KneeIKConnectorCtrl.nonControl");


		//VISIBILITY TOGGLES////////////////////////////////////////////////////////////////////
		
	
		//LEG
		shadingNode -asUtility condition -n ($modCore + "_LegIKViz");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_LegIKViz.firstTerm");
		setAttr ($modCore + "_LegIKViz.secondTerm") 0.7;
		setAttr ($modCore + "_LegIKViz.operation") 3;
			
		connectAttr -f ($modCore + "_LegIKViz.outColorR") ($modCore + "_KneeIKCtrl.v");
		connectAttr -f ($modCore + "_LegIKViz.outColorR") ($modCore + "_FootIKCtrl.v");
		connectAttr -f ($modCore + "_LegIKViz.outColorR") ($modCore + "_ToeIKCtrl.v");
		if (`objExists ($modCore + "_LowerLegIKCtrl")`)
		{
			connectAttr -f ($modCore + "_LegIKViz.outColorR") ($modCore + "_LowerLegIKCtrl.v");
			setAttr -lock 1 -keyable 0 ($modCore + "_LowerLegIKCtrl.v");
		}
		shadingNode -asUtility condition -n ($modCore + "_LegFKViz");
		connectAttr -f ($modCore + "_SwitchCtrl.switchIkFk") ($modCore + "_LegFKViz.firstTerm");
		setAttr ($modCore + "_LegFKViz.secondTerm") 0.3;
		setAttr ($modCore + "_LegFKViz.operation") 5;
		setAttr ($modCore + "_SwitchCtrl.switchIkFk") 0;	
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			connectAttr -f ($modCore + "_LegFKViz.outColorR") ($modCore + "_KneeFKCtrl.v");
		}
		else
		{
			connectAttr -f ($modCore + "_LegFKViz.outColorR") ($modCore + "_Knee1FKCtrl.v");
			connectAttr -f ($modCore + "_LegFKViz.outColorR") ($modCore + "_Knee2FKCtrl.v");
		}
		connectAttr -f ($modCore + "_LegFKViz.outColorR") ($modCore + "_AnkleFKCtrl.v");
		connectAttr -f ($modCore + "_LegFKViz.outColorR") ($modCore + "_BallFKCtrl.v");
		connectAttr -f ($modCore + "_LegFKViz.outColorR") ($modCore + "_ToeFKCtrl.v");
		
		//////////////////////////////////LOCK & HIDE//////////////////////////////////
		//MAKE FEET JOINTS VISIBLE
		setAttr ($modCore + "_AnkleJnt.overrideEnabled") 1;
	
		
		//JOINTS
		setAttr ($modCore + "_HipJntIK.v") 0;
		setAttr ($modCore + "_HipJntFK.v") 0;
		setAttr ($modCore + "_AnkleJntFK.v") 0;
	
	
		setAttr ($modCore + "_LegLengthOriginLctr.v") 0;
		setAttr ($modCore + "_AnkleJntFKGrp2.v") 0;
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			setAttr ($modCore + "_KneeJntFKGrp2.v") 0;
		}
		else
		{
			setAttr ($modCore + "_Knee1JntFKGrp2.v") 0;
			setAttr ($modCore + "_Knee2JntFKGrp2.v") 0;
		}
		
		
		setAttr ($modCore + "_KneeIKCtrl_TargetLctr.v") 0;
		
		//CONTROLS
		setAttr -l 1 -k 0 ($modCore + "_HipFKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_HipFKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_HipFKCtrl.v");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_KneeFKCtrl.v");
		}
		else
		{
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_Knee1FKCtrl.v");
			
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.rx");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.rz");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_Knee2FKCtrl.v");

			setAttr -l 1 -k 0 ($modCore + "_LowerLegIKCtrl.tx");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIKCtrl.ty");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIKCtrl.tz");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIKCtrl.sx");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIKCtrl.sy");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIKCtrl.sz");
			setAttr -l 1 -k 0 ($modCore + "_LowerLegIKCtrl.v");
			transformLimits -sy 0.01 1 -esy 1 0 ($modCore + "_LowerLegIKCtrl");
		}
		
		setAttr -l 1 -k 0 ($modCore + "_AnkleFKCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_AnkleFKCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_AnkleFKCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_AnkleFKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_AnkleFKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_AnkleFKCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_BallFKCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_BallFKCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_BallFKCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_BallFKCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_BallFKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_BallFKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_BallFKCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_ToeFKCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_ToeFKCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_ToeFKCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_ToeFKCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_ToeFKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ToeFKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ToeFKCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_KneeIKCtrl.rx");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKCtrl.ry");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKCtrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_FootIKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_FootIKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_FootIKCtrl.v");
			
		setAttr -l 1 -k 0 ($modCore + "_ToeIKCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_ToeIKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_ToeIKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_ToeIKCtrl.v");
			
		setAttr -l 1 -k 0 ($modCore + "_HeelIKCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_HeelIKCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_HeelIKCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_HeelIKCtrl.v");

		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.rx");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.ry");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_SwitchCtrl.v");
		
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.tx");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.ty");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.tz");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.rx");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.ry");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.rz");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.sx");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.sy");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.sz");
		setAttr -l 1 -k 0 ($modCore + "_KneeIKConnectorCtrl.v");
		setAttr ($modCore + "_KneeIKConnectorCtrl.template") 1;

		setAttr ($modCore + "_LegIKHandle.v") 0;
		
		setAttr ($modCore + "_BallSwivelLctr.v") 0;	
		
		
		//LOCK GROUPS
		
		/////////////////////////////////SNAP ASSETS/////////////////////////////////
		select -cl;
		//ANKLE FK LOCATOR
		spaceLocator -n ($modCore + "_AnkleFKLctr");
		delete `parentConstraint ($modCore + "_FootIKCtrlGrp") ($modCore + "_AnkleFKLctr")`;
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_AnkleFKLctr");
		parent ($modCore + "_AnkleFKLctr") ($modCore + "_FootIKCtrlGrp");
		parentConstraint ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleFKLctr");
		
		//ANKLE IK LOCATOR
		spaceLocator -n ($modCore + "_AnkleIKLctr");
		delete `parentConstraint ($modCore + "_AnkleFKCtrlGrp") ($modCore + "_AnkleIKLctr")`;
		parent ($modCore + "_AnkleIKLctr") ($modCore + "_AnkleFKCtrlGrp");
		orientConstraint -mo ($modCore + "_FootIKCtrl") ($modCore + "_AnkleIKLctr");
		setAttr ($modCore + "_AnkleIKLctr_orientConstraint1.interpType") 2;
		
		//KNEE FK LOCATOR
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			spaceLocator -n ($modCore + "_Knee_FKAimLctr");
			delete `parentConstraint ($modCore + "_KneeIKCtrl") ($modCore + "_Knee_FKAimLctr")`;
			parent ($modCore + "_Knee_FKAimLctr") ($modCore + "_KneeIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Knee_FKAimLctr");
		
			parentConstraint -mo ($modCore + "_KneeFKCtrl") ($modCore + "_HipFKCtrl") ($modCore + "_Knee_FKAimLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_Knee1_FKAimLctr");
			parent ($modCore + "_Knee1_FKAimLctr") ($modCore + "_Knee1FKCtrl");
			makeIdentity -apply false -t 1 -r 1 ($modCore + "_Knee1_FKAimLctr");
			delete `pointConstraint -offset 0 0 0 -skip x -skip y -weight 1 ($modCore + "_KneeIKCtrl") ($modCore + "_Knee1_FKAimLctr")`;
	
			parent ($modCore + "_Knee1_FKAimLctr") ($modCore + "_KneeIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Knee1_FKAimLctr");
		
			parentConstraint -mo ($modCore + "_Knee1FKCtrl") ($modCore + "_HipFKCtrl") ($modCore + "_Knee1_FKAimLctr");
			
			spaceLocator -n ($modCore + "_Knee2_FKAimLctr");
			parent ($modCore + "_Knee2_FKAimLctr") ($modCore + "_Knee2FKCtrl");
			makeIdentity -apply false -t 1 -r 1 ($modCore + "_Knee2_FKAimLctr");
			delete `pointConstraint -offset 0 0 0 -skip x -skip y -weight 1 ($modCore + "_KneeIKCtrl") ($modCore + "_Knee2_FKAimLctr")`;
	
			parent ($modCore + "_Knee2_FKAimLctr") ($modCore + "_KneeIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_Knee2_FKAimLctr");
		
			parentConstraint -mo ($modCore + "_Knee2FKCtrl") ($modCore + "_HipFKCtrl") ($modCore + "_Knee2_FKAimLctr");
		}		
		
		//HIP FK LOCATOR
		spaceLocator -n ($modCore + "_HipFKOrientLctr");
		delete `parentConstraint ($modCore + "_HipJnt") ($modCore + "_HipFKOrientLctr")`;
		parent ($modCore + "_HipFKOrientLctr") ($modCore + "_HipFKCtrlGrp");
		orientConstraint ($modCore + "_HipJntIK") ($modCore + "_HipFKOrientLctr");
		
		//HIDE SNAP LOCATORS
		setAttr ($modCore + "_HipFKOrientLctr.v") 0;
		if (`objExists ($modCore + "_Knee_FKAimLctr.v")`)
		{
			setAttr ($modCore + "_Knee_FKAimLctr.v") 0;
		}
		else
		{
			setAttr ($modCore + "_Knee1_FKAimLctr.v") 0;
			setAttr ($modCore + "_Knee2_FKAimLctr.v") 0;
		}		
		setAttr ($modCore + "_AnkleIKLctr.v") 0;
		setAttr ($modCore + "_AnkleFKLctr.v") 0;
		
		setAttr ($modCore + "_HipIKLockLctr.v") 0;
		
		
		//PARENT TO MAIN CONTROL
		
		//SET ALL CONSTRAINTS TO SHORTEST INTERPOLATION
		string $selectedParentConstraints[] = `ls ($modCore + "*_parentConstraint1")`;
		for ($crntParentConstraint in $selectedParentConstraints)
		{setAttr ($crntParentConstraint + ".interpType") 2;}
		
		setAttr ($modCore + "_KneeIKCtrlGrp_parentConstraint1.interpType") 2;
		
		if (`objExists ($modCore + "_HipCurveJnt")`)
		{
			setAttr ($modCore + "_LowerTwist75Lctr_parentConstraint1.interpType") 2;
			setAttr ($modCore + "_LowerTwist25Lctr_parentConstraint1.interpType") 2;
			setAttr ($modCore + "_LowerTwistHalfLctr_parentConstraint1.interpType") 2;
		}
		
		//HIERARCHY CLEAN-UP
		parent 
		($modCore + "_AnkleJntFKGrp2") 
		($modCore + "_FootIKCtrlGrp") ($modCore + "_KneeIKCtrlGrp") ($modCore + "_KneeIKCtrl_TargetLctr")
		($modCore + "_LegLengthOriginLctr") ($modCore + "_HipIKLockLctr")
		($modCore + "_SwitchCtrlGrp") ($modCore + "_HipFKCtrlGrp")
		
		($modCore + "_AnkleFKCtrlGrp") ($modCore + "_BallFKCtrlGrp") ($modCore + "_ToeFKCtrlGrp")
		($modCore + "_HipJnt") ($modCore + "_HipJntFK") ($modCore + "_HipJntIK")
		($modCore + "_ScaleGrp");
		
		//if (`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		//{
		//	parent ($modCore + "_Knee1JntFKGrp2") ($modCore + "_Knee2JntFKGrp2") ($modCore + "_ScaleGrp");
		//}

		//CREATE CONSTRAINT FOR ANKLE IKCtrlGrp
		//CHECK IF ATTACHED TO ROOT
		if ($modAttachNode == "ROOT")
		{
			parentConstraint -mo ($modName + "_MAINCtrl") ($modName + "_ROOTCtrl") ($modName + "_ROOTSecondaryCtrl") ($modCore + "_FootIKCtrlGrp");
		}
		else
		{
			parentConstraint -mo ($modName + "_MAINCtrl") ($modName + "_ROOTCtrl") ($modName + "_ROOTSecondaryCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_FootIKCtrlGrp");
		}

		//ADD DYNAMIC PARENTING CHANNELS
		addAttr -ln "follow" -at double  -min 1 -max 1 -dv 1 ($modCore + "_FootIKCtrl");
		setAttr -e -keyable 1 ($modCore + "_FootIKCtrl.follow");
		setAttr -lock 1 ($modCore + "_FootIKCtrl.follow");
		if ($modAttachNode != "ROOT")
		{
			addAttr -ln "parent" -at double -min 0 -max 1 -dv 0 ($modCore + "_FootIKCtrl");
			setAttr -e-keyable 1 ($modCore + "_FootIKCtrl.parent");
		}
		addAttr -ln "ROOT"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_FootIKCtrl");
		setAttr -e-keyable 1 ($modCore + "_FootIKCtrl.ROOT");

		addAttr -ln "ROOTType" -at "enum" -en "ROOTC:ROOTsecondaryC:" ($modCore + "_FootIKCtrl");
		setAttr -e-keyable 1 ($modCore + "_FootIKCtrl.ROOTType");


		//IK ANKLE DYNAMIC CONSTRAINTS
		if ($modAttachNode != "ROOT")
		{
			connectAttr -f ($modCore + "_FootIKCtrl.parent") ($modCore + "_FootIKCtrlGrp_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW3");
		}
		
		//ROOT CONNECTIONS
		shadingNode -asUtility multiplyDivide -n ($modCore + "_FootIKROOTInf_MD");
		connectAttr -f ($modCore + "_FootIKCtrl.ROOT") ($modCore + "_FootIKROOTInf_MD.input1X");
		connectAttr -f ($modCore + "_FootIKCtrl.ROOT") ($modCore + "_FootIKROOTInf_MD.input1Y");
		connectAttr -f ($modCore + "_FootIKCtrl.ROOTType") ($modCore + "_FootIKROOTInf_MD.input2Y");
		
		shadingNode -asUtility reverse -n ($modCore + "_FootIKROOTInf_Reverse");
		connectAttr -f ($modCore + "_FootIKCtrl.ROOTType") ($modCore + "_FootIKROOTInf_Reverse.inputX");
		connectAttr -f ($modCore + "_FootIKROOTInf_Reverse.outputX") ($modCore + "_FootIKROOTInf_MD.input2X");

		connectAttr -f ($modCore + "_FootIKROOTInf_MD.outputX") ($modCore + "_FootIKCtrlGrp_parentConstraint1." + $modName + "_ROOTCtrlW1");
		connectAttr -f ($modCore + "_FootIKROOTInf_MD.outputY") ($modCore + "_FootIKCtrlGrp_parentConstraint1." + $modName + "_ROOTSecondaryCtrlW2");
		
		shadingNode -asUtility plusMinusAverage -n ($modCore + "_FootIKParent_PMA");
		if ($modAttachNode != "ROOT")
		{
			connectAttr -f ($modCore + "_FootIKCtrl.parent") ($modCore + "_FootIKParent_PMA.input1D[0]");
		}
		connectAttr -f ($modCore + "_FootIKCtrl.ROOT") ($modCore + "_FootIKParent_PMA.input1D[1]");
		
		shadingNode -asUtility condition -n ($modCore + "_FootIKParent_Condition");
		setAttr ($modCore + "_FootIKParent_Condition.operation") 4;
		setAttr ($modCore + "_FootIKParent_Condition.secondTerm") 1;
		connectAttr -f ($modCore + "_FootIKParent_PMA.output1D") ($modCore + "_FootIKParent_Condition.firstTerm");
		connectAttr -force ($modCore + "_FootIKParent_PMA.output1D") ($modCore + "_FootIKParent_Condition.colorIfTrueR");
		
		shadingNode -asUtility reverse -n ($modCore + "_FootIKParent_Reverse");
		connectAttr -f ($modCore + "_FootIKParent_Condition.outColorR") ($modCore + "_FootIKParent_Reverse.inputX");
		connectAttr -f ($modCore + "_FootIKParent_Reverse.outputX") ($modCore + "_FootIKCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");


		/////////////////////////////////SNAP ASSETS/////////////////////////////////
		
		//SINGLE KNEE
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee1")`)
		{
			//ANKLE IK TO FK LOCATOR
			spaceLocator -n ($modCore + "_AnkleIKtoFKLctr");
			setAttr ($modCore + "_AnkleIKtoFKLctr.rotateOrder") 1;
			group -n ($modCore + "_AnkleIKtoFKLctrGrp") ($modCore + "_AnkleIKtoFKLctr");
			delete `parentConstraint ($modCore + "_FootIKCtrl") ($modCore + "_AnkleIKtoFKLctrGrp")`;
			parentConstraint -mo ($modCore + "_AnkleFKCtrl") ($modCore + "_AnkleIKtoFKLctr");
			parent ($modCore + "_AnkleIKtoFKLctrGrp") ($modCore + "Grp");
			
			//ANKLE FK TO IK LOCATOR
			spaceLocator -n ($modCore + "_AnkleFKtoIKLctr");
			group -n ($modCore + "_AnkleFKtoIKLctrGrp2") ($modCore + "_AnkleFKtoIKLctr");
			group -n ($modCore + "_AnkleFKtoIKLctrGrp") ($modCore + "_AnkleFKtoIKLctrGrp2");
			rotate 0 0 -90 ($modCore + "_AnkleFKtoIKLctrGrp2");
			delete `pointConstraint ($modCore + "_AnkleJnt") ($modCore + "_AnkleFKtoIKLctrGrp")`;
			aimConstraint -offset 0 0 0 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "scene" -skip x -skip z ($modCore + "_BallJnt") ($modCore + "_ToeJnt") ($modCore + "_AnkleFKtoIKLctrGrp");
			delete ($modCore + "_AnkleFKtoIKLctrGrp_aimConstraint1");
			parentConstraint -mo ($modCore + "_AnkleFKCtrlGrp") ($modCore + "_AnkleFKtoIKLctrGrp");
			orientConstraint -mo ($modCore + "_FootIKCtrl") ($modCore + "_AnkleFKtoIKLctr");
			setAttr ($modCore + "_AnkleFKtoIKLctr_orientConstraint1.interpType") 2;
			parent ($modCore + "_AnkleFKtoIKLctrGrp") ($modCore + "_ScaleGrp");
			
			//KNEE IK TO FK LOCATOR
			spaceLocator -n ($modCore + "_KneeIKtoFKAimLctr");
			delete `parentConstraint ($modCore + "_KneeIKCtrl") ($modCore + "_KneeIKtoFKAimLctr")`;
			parent ($modCore + "_KneeIKtoFKAimLctr") ($modCore + "_KneeIKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_KneeIKtoFKAimLctr");
			parentConstraint -mo ($modCore + "_KneeFKCtrl") ($modCore + "_HipFKCtrl") ($modCore + "_KneeIKtoFKAimLctr");
			
			//HIP FK TO IK LOCATOR
			spaceLocator -n ($modCore + "_HipFKtoIKOrientLctr");
			delete `parentConstraint ($modCore + "_HipFKCtrlGrp") ($modCore + "_HipFKtoIKOrientLctr")`;
			parent ($modCore + "_HipFKtoIKOrientLctr") ($modCore + "_HipFKCtrlGrp");
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_HipFKtoIKOrientLctr");
			orientConstraint -mo ($modCore + "_HipJntIK") ($modCore + "_HipFKtoIKOrientLctr");
			
				
			//HIDE SNAP LOCATORS
			setAttr ($modCore + "_KneeIKtoFKAimLctr.v") 0;
			setAttr ($modCore + "_AnkleFKtoIKLctr.v") 0;
			setAttr ($modCore + "_AnkleIKtoFKLctr.v") 0;
			
			setAttr ($modCore + "_HipIKLockLctr.v") 0;
			setAttr ($modCore + "_HipFKtoIKOrientLctr.v") 0;
		}
		//KNEE HIERARCHY CLEANUP		
		if (`objExists ($modCore + "_KneeJntFKGrp2")`)
		{
			parent ($modCore + "_KneeJntFKGrp2")  ($modCore + "_KneeFKCtrlGrp")
			($modCore + "_ScaleGrp");
		}
		else
		{
			parent ($modCore + "_Knee1FKCtrlGrp") ($modCore + "_Knee2FKCtrlGrp")
			($modCore + "_Knee1JntFKGrp2") ($modCore + "_Knee2JntFKGrp2")
			($modCore + "_ScaleGrp");
		}
	
		//CHECK POLE VECTOR
		if (`objExists ($modCore + "_Knee1Jnt")`)
		{
			$lhipOrient = `getAttr ($modCore + "_HipJnt.rotate")`;
			if ($lhipOrient[0] > 90 || $lhipOrient[0] < -90 || $lhipOrient[2] > 90 || $lhipOrient[2] < -90)
			{
				setAttr ($modCore + "_LegIKHandle.twist") 180;
			}
				
		}

		select $topNode;
		
		if (`objExists ("RRM_" + $prfx + $core + "_Lower1")` || `objExists ("RRM_" + $prfx + $core + "_Middle1")` || `objExists ("RRM_" + $prfx + $core + "_Upper1")`)
		{
			RRM_ToonLimbs_V1($modName, "leg", $prfx, $oppPrfx, $crntSide, $oppSide, $modCore, $modOppCore, $multiplier, $inverseFront, ($modName + "_" + $modAttachNode + "Jnt"), $topNode);
		}
	
		//ADD JOINT ANGLE ATTRIBUTES
		addAttr -ln "hipAngleX"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + "hipAngleX");
		addAttr -ln "hipAngleY"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + "hipAngleY");
		addAttr -ln "hipAngleZ"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + "hipAngleZ");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee2")`)
		{
			addAttr -ln "kneeAngleY" -at double ($modCore + "_SwitchCtrl");
			setAttr -e-keyable 1 ($modCore + "_SwitchCtrl.kneeAngleY");
		}
		else
		{
			addAttr -ln "knee1AngleY" -at double ($modCore + "_SwitchCtrl");
			setAttr -e-keyable 1 ($modCore + "_SwitchCtrl.knee1AngleY");
			addAttr -ln "knee2AngleY" -at double ($modCore + "_SwitchCtrl");
			setAttr -e-keyable 1 ($modCore + "_SwitchCtrl.knee2AngleY");
		}
		
		addAttr -ln "ankleAngleX"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + "ankleAngleX");
		addAttr -ln "ankleAngleY"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + "ankleAngleY");
		addAttr -ln "ankleAngleZ"  -at double ($modCore + "_SwitchCtrl");
		setAttr -e-keyable 1 ($modCore + "_SwitchCtrl." + "ankleAngleZ");
		
		//CONNECT JOINT ANGLE ATTRIBUTES
		connectAttr -force ($modCore + "_HipJnt.rotateX") ($modCore + "_SwitchCtrl.hipAngleX");
		connectAttr -force ($modCore + "_HipJnt.rotateY") ($modCore + "_SwitchCtrl.hipAngleY");
		connectAttr -force ($modCore + "_HipJnt.rotateZ") ($modCore + "_SwitchCtrl.hipAngleZ"); 
	
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee2")`)
		{
			connectAttr -force ($modCore + "_KneeJnt.rotateY") ($modCore + "_SwitchCtrl.kneeAngleY");
		}
		else
		{
			connectAttr -force ($modCore + "_Knee1Jnt.rotateY") ($modCore + "_SwitchCtrl.knee1AngleY");
			connectAttr -force ($modCore + "_Knee2Jnt.rotateY") ($modCore + "_SwitchCtrl.knee2AngleY");
		}
			
	
		connectAttr -force ($modCore + "_AnkleJnt.rotateX") ($modCore + "_SwitchCtrl.ankleAngleX");
		connectAttr -force ($modCore + "_AnkleJnt.rotateY") ($modCore + "_SwitchCtrl.ankleAngleY");
		connectAttr -force ($modCore + "_AnkleJnt.rotateZ") ($modCore + "_SwitchCtrl.ankleAngleZ");
		
		setAttr -lock 1 ($modCore + "_SwitchCtrl.hipAngleX");  
		setAttr -lock 1 ($modCore + "_SwitchCtrl.hipAngleY");  
		setAttr -lock 1 ($modCore + "_SwitchCtrl.hipAngleZ");
		
		if (!`objExists ("RRM_" + $prfx + $core + "_Knee2")`)
		{
			setAttr -lock 1 ($modCore + "_SwitchCtrl.kneeAngleY");
		}
		else
		{
			setAttr -lock 1 ($modCore + "_SwitchCtrl.knee1AngleY");
			setAttr -lock 1 ($modCore + "_SwitchCtrl.knee2AngleY");
		}
		
		setAttr -lock 1 ($modCore + "_SwitchCtrl.ankleAngleX");  
		setAttr -lock 1 ($modCore + "_SwitchCtrl.ankleAngleY");  
		setAttr -lock 1 ($modCore + "_SwitchCtrl.ankleAngleZ");


		//ADD CORE NAME
		$modControls = `ls ($modCore + "_*Ctrl")`;
		for ($crntModControl in $modControls)
		{
			if (!`objExists ($crntModControl + ".modCoreName")`)
			{
				addAttr -ln "modCoreName"  -dt "string" $crntModControl;
				setAttr -e-keyable 1 ($crntModControl + ".modCoreName");
				setAttr -type "string" ($crntModControl + ".modCoreName") ("_" + $prfx + $core);
				setAttr -e-lock 1 ($crntModControl + ".modCoreName");

				//ADD MODULE TYPE
				addAttr -ln "moduleType"  -dt "string" ($crntModControl);
				setAttr -e -keyable 1 ($crntModControl + ".moduleType");
				setAttr -type "string" ($crntModControl + ".moduleType") "leg";
				setAttr -l true ($crntModControl + ".moduleType");
			}
		}
	
		//SET UP FOR RIGHT SIDE
		$mirrorInt++;
		$i++;
		$prfx = "r_";
		$posOffset = -2;
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
		$inverseFront = 1;
	
		if (!`objExists ($topNode + ".pair")`)
		{
			$i = 2;
		}
	}
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE FK CHAIN MODULE/////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRig_V1FkChain_V1(string $modName, string $moduleName, string $topNode)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;     

	//INTEGER FOR LOOP
	$mirrorInt = 1;
	$multiplier = 1;
	float $rotOffset = 0;

	
	$core = `getAttr ($topNode + ".core")`;
	string $prfx = "";
	string $oppPrfx = "";

	$crntSide = "";
	$oppSide = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = "l_";
		$oppPrfx = "r_";
		$mirrorInt = 0;
		$crntSide = "left";
		$oppSide = "right";
	}
	
	//CHECK IF IK IS ENABLED
	$enableIK = 1;
	if (`objExists ($topNode + ".ikEnabled")`)
	{
		$enableIK = `getAttr ($topNode + ".ikEnabled")`;
	}
	
	while ($mirrorInt <= 1)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modName + "_" + $prfx + $core);
		$modOppCore = ($modName + "_" + $oppPrfx + $core);
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		delete `orientConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_OffsetLctr");
		
		group -em -n ($modCore);
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modName + "_ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_ROOTJnt") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modName + "_MAINCtrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
						
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "fkChain";
		setAttr -l true ($modCore + "Grp.topNode");	
		
		//CORE NAME
		addAttr -ln "coreName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ("_" + $prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable 1 ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ("_" + $oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable 1 ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");
		}
		
		//NODE-SPECIFIC ATTRIBUTES
		$fkChains = `ls ("RRM_" + $prfx + $core + "_??_01")`;
	
		addAttr -ln "fkChains"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.fkChains") ;
		setAttr -type "string" ($modCore + "Grp.fkChains") `size $fkChains`;
		setAttr -l true ($modCore + "Grp.fkChains");
		
		$fkjointsPerChain = `ls ("RRM_" + $prfx + $core + "_01_??")`;
	
		addAttr -ln "jointsPerChain"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.jointsPerChain") ;
		setAttr -type "string" ($modCore + "Grp.jointsPerChain") `size $fkjointsPerChain`;
		setAttr -l true ($modCore + "Grp.jointsPerChain");
		
		addAttr -ln "ikEnabled" -at bool ($modCore + "Grp");
		setAttr -e-keyable 1 ($modCore + "Grp.ikEnabled");
		setAttr ($modCore + "Grp.ikEnabled") $enableIK;
		setAttr -l true ($modCore + "Grp.ikEnabled");

		//SCALE GROUP
		spaceLocator -n ($modCore + "_AveragePosition_Lctr");
		parentConstraint $fkChains ($modCore + "_AveragePosition_Lctr");
		group -em -n ($modCore + "_ScaleGrp");

		//GROUP FOR NODES
		group -em -n ($modCore + "_curveNodesGrp");
		parent ($modCore + "_curveNodesGrp") ($modCore + "_ScaleGrp");
		group -em -n ($modCore + "_extraCurveNodesGrp");
		setAttr ($modCore + "_extraCurveNodesGrp.inheritsTransform") 0; 
		parent ($modCore + "_extraCurveNodesGrp") ($modCore + "Grp");

		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ($modCore + "_AveragePosition_Lctr") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ($modCore + "_AveragePosition_Lctr") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		delete ($modCore + "_AveragePosition_Lctr");
		
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + "_ScaleGrp.scale");
							
		$allJoints = `ls ("RRM_" + $prfx + $core + "_??_??")`;
		$sizeAllJoints = `size $allJoints`;
		$fKChain = `ls ("RRM_" + $prfx + $core + "_??_01")`;
		$fKChainSize = `size $fKChain`;
		$crntCh = 1;
		$crntJnt = 1;
		
		//MASTER CONTROLLER
		circle -n ($modCore + "_MasterCtrl") -nr 5 0 0 -r 1 -d 1 -s 4 -ch 0;
		rotate -r 45 0 0 ($modCore + "_MasterCtrl");
		makeIdentity -apply true -r 1 ($modCore + "_MasterCtrl");
		group -n ($modCore + "_MasterCtrlGrp") ($modCore + "_MasterCtrl");
		spaceLocator -n ($modCore + "_MasterCtrl_StartAttachLctr");
		spaceLocator -n ($modCore + "_MasterCtrl_EndAttachLctr");
		pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_MasterCtrl_StartAttachLctr");
		aimConstraint -offset 0 0 0 -aimVector $multiplier 0 0 -upVector 0 1 0 -worldUpType "objectRotation" -worldUpObject ("RRM_" + $prfx + $core + "_Parent")
		$fKChain ($modCore + "_MasterCtrl_StartAttachLctr");
		pointConstraint $fKChain ($modCore + "_MasterCtrl_EndAttachLctr");
		delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_MasterCtrl_EndAttachLctr") ($modCore + "_MasterCtrlGrp")`;
		delete `orientConstraint ($modCore + "_MasterCtrl_StartAttachLctr") ($modCore + "_MasterCtrlGrp")`;
		parent ($modCore + "_MasterCtrlGrp") ($modCore + "_ScaleGrp");
		delete ($modCore + "_MasterCtrl_StartAttachLctr") ($modCore + "_MasterCtrl_EndAttachLctr");
		
		if (`size $fKChain` > 1)
		{
			spaceLocator -n ($modCore + "_MasterCtrl_SizeStartLctr");
			spaceLocator -n ($modCore + "_MasterCtrl_SizeEndLctr");
			parent ($modCore + "_MasterCtrl_SizeEndLctr") ($modCore + "_MasterCtrl_SizeStartLctr");
			pointConstraint $fKChain[0] ($modCore + "_MasterCtrl_SizeStartLctr");
			aimConstraint -offset 0 0 0 -aimVector $multiplier 0 0 -upVector 0 1 0 -worldUpType "none" $fKChain[($fKChainSize - 1)] ($modCore + "_MasterCtrl_SizeStartLctr");
			pointConstraint $fKChain[($fKChainSize - 1)] ($modCore + "_MasterCtrl_SizeEndLctr");
			float $chains = `getAttr ($modCore + "_MasterCtrl_SizeEndLctr.tx")`;
			scale -r 1 ($chains * .8) ($chains * .3) ($modCore + "_MasterCtrl");
			makeIdentity -apply true -s 1 ($modCore + "_MasterCtrl");
			delete ($modCore + "_MasterCtrl_SizeStartLctr");
		}
		else
		{
			spaceLocator -n ($modCore + "_MasterCtrl_SizeStartLctr");
			spaceLocator -n ($modCore + "_MasterCtrl_SizeEndLctr");
			parent ($modCore + "_MasterCtrl_SizeEndLctr") ($modCore + "_MasterCtrl_SizeStartLctr");
			pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_MasterCtrl_SizeStartLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" $fKChain[0] ($modCore + "_MasterCtrl_SizeStartLctr");
			pointConstraint $fKChain[0] ($modCore + "_MasterCtrl_SizeEndLctr");
			float $chains = `getAttr ($modCore + "_MasterCtrl_SizeEndLctr.tx")`;
			scale -r 1 ($chains * .8) ($chains * .3) ($modCore + "_MasterCtrl");
			makeIdentity -apply true -s 1 ($modCore + "_MasterCtrl");
			delete ($modCore + "_MasterCtrl_SizeStartLctr");
		}
			
		//PARENT ORIENT
		$parentOrient = ($modCore + "_MasterCtrl");
		RRM_ParentOrient_V1($modCore, $modName, $modAttachNode, $parentOrient); 
		
		//CONTROLLER SIZE
		float $controllerSize = 1;
		float $fKChainDistance = 1;
		spaceLocator -n ($modCore + "_StartLctr");
		spaceLocator -n ($modCore + "_EndLctr");
		parent ($modCore + "_EndLctr") ($modCore + "_StartLctr");					
	
		if ($sizeAllJoints >1)
		{
			pointConstraint $allJoints[0] ($modCore + "_StartLctr");
			aimConstraint -offset 0 $rotOffset 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" $allJoints[($sizeAllJoints - 1)] ($modCore + "_StartLctr");
			pointConstraint $allJoints[($sizeAllJoints - 1)] ($modCore + "_EndLctr");
			$fKChainDistance = `getAttr ($modCore + "_EndLctr.tx")`;
			$controllerSize = ($fKChainDistance/$sizeAllJoints * 2);
		}
		else 
		{				
			pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_StartLctr");
			aimConstraint -offset 0 $rotOffset 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" $allJoints[0] ($modCore + "_StartLctr");
			pointConstraint $allJoints[0] ($modCore + "_EndLctr");
			$fKChainDistance = `getAttr ($modCore + "_EndLctr.tx")`;
			$controllerSize = ($fKChainDistance/$sizeAllJoints * 0.5);
		}
		delete ($modCore + "_StartLctr");
		
		//MAIN GROUP TO ATTACH CHAINS TO PARENT CONTROL
		group -em -n ($modCore + "_MainChainCtrlGrp");
		parent ($modCore + "_MainChainCtrlGrp") ($modCore + "_ScaleGrp");
		
		if ($fKChainSize > 2)
		{
				addAttr -ln "FkAutoSpreadPos"  -at double  -min 0 -max 1 -dv 0  ($modCore + "_MasterCtrl");
				setAttr -e-keyable 1 ($modCore + "_MasterCtrl.FkAutoSpreadPos");
				addAttr -ln "FkAutoSpreadRot"  -at double  -min 0 -max 1 -dv 0  ($modCore + "_MasterCtrl");
				setAttr -e-keyable 1 ($modCore + "_MasterCtrl.FkAutoSpreadRot");
		}
		
		if ($enableIK == 1)
		{
			//ADD SPLINE ATTRIBUTES
			addAttr -ln "splineEffect"  -at "enum" -en "Settings:"  ($modCore + "_MasterCtrl");
			setAttr -e-keyable 1 -l true ($modCore + "_MasterCtrl.splineEffect");
		
			addAttr -ln "blendedAdditive"  -at double  -min 0 -max 1 -dv 0 ($modCore + "_MasterCtrl");
			setAttr -e-keyable 1 ($modCore + "_MasterCtrl.blendedAdditive");
		
			if ($fKChainSize > 2)
			{
				addAttr -ln "splineAutoSpreadPos"  -at double  -min 0 -max 1 -dv 0  ($modCore + "_MasterCtrl");
				setAttr -e-keyable 1 ($modCore + "_MasterCtrl.splineAutoSpreadPos");
		
				addAttr -ln "splineAutoSpreadRot"  -at double  -min 0 -max 1 -dv 0  ($modCore + "_MasterCtrl");
				setAttr -e-keyable 1 ($modCore + "_MasterCtrl.splineAutoSpreadRot");
			}
		}
		$doubleLoop = 0;
		if ($enableIK == 0)
		{
			$doubleLoop = 1;
		}
		$type = "";
		while ($doubleLoop < 2)
		{
			if ($fKChainSize > 2)
			{
				spaceLocator -n ($modCore + "_SpreadTranslate_" + $type + "StartLctr");
				spaceLocator -n ($modCore + "_SpreadTranslate_" + $type + "EndLctr");
				spaceLocator -n ($modCore + "_SpreadRotate_" + $type + "StartLctr");
				spaceLocator -n ($modCore + "_SpreadRotate_" + $type + "EndLctr");
			
				string $nPdCh = "_";
				if ($fKChainSize < 10)
				{
					$nPdCh = "_0";
				}
				
				delete `parentConstraint ("RRM_" + $prfx + $core + "_01_01") ($modCore + "_SpreadTranslate_" + $type + "StartLctr")`;
				delete `parentConstraint ("RRM_" + $prfx + $core + "_01_01") ($modCore + "_SpreadRotate_" + $type + "StartLctr")`;
				delete `parentConstraint ("RRM_" + $prfx + $core + $nPdCh + $fKChainSize + "_01")($modCore + "_SpreadTranslate_" + $type + "EndLctr")`;
				delete `parentConstraint ("RRM_" + $prfx + $core + $nPdCh + $fKChainSize + "_01")($modCore + "_SpreadRotate_" + $type + "EndLctr")`;
	
				if ($type == "")
				{
					//CREATE REVERSE NODE TO TURN OFF INFLUENCE OF MASTER CONTROL
					shadingNode -asUtility reverse -n ($modCore + "_MasterCtrl_SpreadPos_Reverse");
					connectAttr -force ($modCore + "_MasterCtrl.FkAutoSpreadPos") ($modCore + "_MasterCtrl_SpreadPos_Reverse.inputX");

					shadingNode -asUtility reverse -n ($modCore + "_MasterCtrl_SpreadRot_Reverse");
					connectAttr -force ($modCore + "_MasterCtrl.FkAutoSpreadRot") ($modCore + "_MasterCtrl_SpreadRot_Reverse.inputX");

					if ($enableIK == 1)
					{
						shadingNode -asUtility reverse -n ($modCore + "_MasterCtrl_SplineSpreadPos_Reverse");
						connectAttr -force ($modCore + "_MasterCtrl.splineAutoSpreadPos") ($modCore + "_MasterCtrl_SplineSpreadPos_Reverse.inputX");
	
						shadingNode -asUtility reverse -n ($modCore + "_MasterCtrl_SplineSpreadRot_Reverse");
						connectAttr -force ($modCore + "_MasterCtrl.splineAutoSpreadRot") ($modCore + "_MasterCtrl_SplineSpreadRot_Reverse.inputX");
					}
				}
				
				parent  ($modCore + "_SpreadTranslate_" + $type + "StartLctr") ($modCore + "_ScaleGrp");
				parent  ($modCore + "_SpreadTranslate_" + $type + "EndLctr") ($modCore + "_ScaleGrp");
				parent  ($modCore + "_SpreadRotate_" + $type + "StartLctr") ($modCore + "_ScaleGrp");
				parent  ($modCore + "_SpreadRotate_" + $type + "EndLctr") ($modCore + "_ScaleGrp");
				
				setAttr ($modCore + "_SpreadTranslate_" + $type + "StartLctr.v") 0;
				setAttr ($modCore + "_SpreadTranslate_" + $type + "EndLctr.v") 0;
				setAttr ($modCore + "_SpreadRotate_" + $type + "StartLctr.v") 0;
				setAttr ($modCore + "_SpreadRotate_" + $type + "EndLctr.v") 0;
			}
			$type = "Spline";
			$doubleLoop++;
		}
		
	
		for ($crntFKChain in $fKChain)                                    
		{
			string $nPdCh = "_";
			if ($crntCh < 10)
			{
				$nPdCh = "_0";
			}
	
			$fKJoints = `ls ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + "??")`;
			$fKJointSize = `size $fKJoints`;
			string $crntFKJoint;
			int $crntJnt = 1;
			for ($crntFKJoint in $fKJoints)
			{
				string $nPd = "";
				if ($crntJnt < 10)
				{
					$nPd = "0";
				}
				$nextJnt = ($crntJnt + 1);
				$nPdNext = "";
				if ($nextJnt <10)
				{
					$nPdNext = "0";
				}
				$previousJnt = ($crntJnt - 1);
				$nPdPrev = "";
				if ($previousJnt <10)
				{
					$nPdPrev = "0";
				}
				select -cl;
				joint -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt");
				select -cl;
				joint -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK");
				setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.v") 0;
				if ($enableIK == 1)
				{
					select -cl;
					joint -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK");
					setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK.v") 0;
				}
				
				if ($crntJnt == 1)
				{
					//GET JOINT DIRECTION
					$upPos = `xform -q -ws -t  ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "DShape.cv[7]")`;
					$aimPos = `xform -q -ws -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Shape.cv[7]")`;
					spaceLocator -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr");
					spaceLocator -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr");
					setAttr (($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr.translate"), $upPos[0], $upPos[1], $upPos[2]);
					setAttr (($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr.translate"), $aimPos[0], $aimPos[1], $aimPos[2]);


					group -n ($modCore + $nPdCh + $crntCh + "JntGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt");
					group -n ($modCore + $nPdCh + $crntCh + "JntGrp2") ($modCore + $nPdCh + $crntCh + "JntGrp");
					group -n ($modCore + $nPdCh + $crntCh + "JntFKGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK");
					group -n ($modCore + $nPdCh + $crntCh + "JntFKGrp2") ($modCore + $nPdCh + $crntCh + "JntFKGrp");
					parent ($modCore + $nPdCh + $crntCh + "JntGrp2") ($modCore + $nPdCh + $crntCh + "JntFKGrp2") ($modCore + "_ScaleGrp");

					delete `pointConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "JntFKGrp2")`;
					delete `pointConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "JntGrp2")`;
					
					delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr")
					($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr") ($modCore + $nPdCh + $crntCh + "JntFKGrp2")`;
					delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr")
					($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr") ($modCore + $nPdCh + $crntCh + "JntGrp2")`;
					//parent ($modCore + $nPdCh + $crntCh + "JntIKGrp2") ($modCore + "_ScaleGrp");
	

					makeIdentity -apply true -t 1 ($modCore + $nPdCh + $crntCh + "JntGrp2") ($modCore + $nPdCh + $crntCh + "JntFKGrp2");
					setAttr ($modCore + $nPdCh + $crntCh + "JntFKGrp2.v") 0;

					if ($enableIK == 1)
					{
						group -n ($modCore + $nPdCh + $crntCh + "JntIKGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK");
						group -n ($modCore + $nPdCh + $crntCh + "JntIKGrp2") ($modCore + $nPdCh + $crntCh + "JntIKGrp");
						delete `pointConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "JntIKGrp2")`;

						delete `aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr")
						($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr") ($modCore + $nPdCh + $crntCh + "JntIKGrp2")`;
						parent ($modCore + $nPdCh + $crntCh + "JntIKGrp2") ($modCore + "_ScaleGrp");
						
						makeIdentity -apply true -t 1 ($modCore + $nPdCh + $crntCh + "JntIKGrp2");
						setAttr ($modCore + $nPdCh + $crntCh + "JntIKGrp2.v") 0;

						//CREATE BLEND
						addAttr -ln ("splineIK" + $nPdCh + $crntCh + "Inf") -at double  -min 0 -max 1 -dv 0 ($modCore + "_MasterCtrl");
						setAttr -e-keyable 1 ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf");
					}
					
					delete ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "UpLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "AimLctr");
				
				}
				else
				{
					parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK")
					($modCore + "_ScaleGrp");
					if ($enableIK == 1)
					{
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK") ($modCore + "_ScaleGrp");
					}
				}					
				
				
				if ($crntSide == "right" && $fKJointSize > 1 && $enableIK == 1)
				{
					select -cl;
					joint -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide");
					setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide.v") 0;
					parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide") ($modCore + "_ScaleGrp");
				}

				//MAIN CONTROL
				circle -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") -nr 1 0 0 -r 1 -ch 0;
				scale -r 1 1 0.667 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl.cv[3]") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl.cv[7]") ;
	
				scale -r 1 ($controllerSize * 2) ($controllerSize * 1) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl");
				makeIdentity -apply true -s 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl");
					
				group -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl");
				delete `pointConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp")`;
				
				if ($enableIK == 1)
				{
					if ($fKJointSize > 1)
					{
						if ($crntFKJoint == 1)
						{
							if ($crntSide == "left" || $crntSide == "")
							{
								parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK") ($modCore + "_extraCurveNodesGrp");
							}
							else
							{
								parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide") ($modCore + "_extraCurveNodesGrp");
							}
						}
		
						//SPLINE CONTROL
						circle -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl") -nr 0 0 1 -r 1 -ch 0;
						scale -r 0.25 0.9 0.9 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.cv[3]") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.cv[7]") ;
						
						
						move -r -os -wd 0 3 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.cv[0:7]");
						curve -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl1") -d 1 -p 0 0 0 -p 0 2 0 -k 0 -k 1 ;
						rename `listRelatives -c ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl1")` ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl1Shape");
						parent -r -s ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl1Shape") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
						setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl1Shape.template") 1;
						delete ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl1");

						scale -r ($controllerSize * $multiplier) ($controllerSize * $multiplier) 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
						makeIdentity -apply true -s 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
						
						group -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp2") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl"); xform -os -piv 0 0 0;
						group -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp2"); xform -os -piv 0 0 0;
						delete `pointConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp")`;
					}
				}
				
				//PARENT CONSTRAIN GROUPS FOR SPREADING
				if ($fKChainSize > 2 && $crntJnt == 1 && $crntCh != 1 && $crntCh != $fKChainSize)
				{
					//ONCE FOR FK AND ONCE FOR SPLINE
					$type = "";
					$spreadPos = ".FkAutoSpreadPos";
					$spreadRot = ".FkAutoSpreadRot";
					int $doubleLoop = 0;
					if ($enableIK == 0)
					{
						$doubleLoop = 1;
					}
					while ($doubleLoop < 2)
					{
						//CREATE GROUP AND CONSTRAINT
						group -em -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp");
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp") ($modCore + "_MainChainCtrlGrp");
						delete `parentConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp")`;
						parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modCore + "_MainChainCtrlGrp") ($modCore + "_SpreadTranslate_" + $type + "StartLctr") ($modCore + "_SpreadTranslate_" + $type + "EndLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp");
						parentConstraint -mo -skipTranslate x -skipTranslate y -skipTranslate z ($modCore + "_MainChainCtrlGrp") ($modCore + "_SpreadRotate_" + $type + "StartLctr") ($modCore + "_SpreadRotate_" + $type + "EndLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp");
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp");
						
						//ADD ATTRIBUTES AND SET WEIGHTS
						float $crntChFloat = ($crntCh - 1);
						float $fKChainSizeFloat = ($fKChainSize - 1);
						float $spreadVal = ($crntChFloat/$fKChainSizeFloat);
	
						addAttr -ln "translateSpreadVal" -at double -min 0 -max 1 -dv $spreadVal ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl");
						setAttr -e -keyable 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl.translateSpreadVal");
						addAttr -ln "rotateSpreadVal" -at double -min 0 -max 1 -dv $spreadVal ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl");
						setAttr -e -keyable 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl.rotateSpreadVal");
						
						//CREATE MD NODE FOR TRANSLATE START AND END LOCATOR WEIGHTS
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_Translate" + $type + "Spread_MD");
						connectAttr -force ($modCore + "_MasterCtrl" + $spreadPos) ($modCore + $nPdCh + $crntCh + "_Translate" + $type + "Spread_MD.input1X");
						connectAttr -force ($modCore + "_MasterCtrl" + $spreadPos) ($modCore + $nPdCh + $crntCh + "_Translate" + $type + "Spread_MD.input1Y");
	
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_Rotate" + $type + "Spread_MD");
						connectAttr -force ($modCore + "_MasterCtrl" + $spreadRot) ($modCore + $nPdCh + $crntCh + "_Rotate" + $type + "Spread_MD.input1X");
						connectAttr -force ($modCore + "_MasterCtrl" + $spreadRot) ($modCore + $nPdCh + $crntCh + "_Rotate" + $type + "Spread_MD.input1Y");

						//CONNECT REVERSE NODE TO TURN OFF INFLUENCE OF MASTER CONTROL
						connectAttr -force ($modCore + "_MasterCtrl_" + $type + "SpreadPos_Reverse.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp_parentConstraint1." + $modCore + "_MainChainCtrlGrpW0");
						connectAttr -force ($modCore + "_MasterCtrl_" + $type + "SpreadRot_Reverse.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp_parentConstraint2." + $modCore + "_MainChainCtrlGrpW0");
						
						//CONNECT CONSTRAINT WEIGHTS TO MD NODE
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl.translateSpreadVal") ($modCore + $nPdCh + $crntCh + "_Translate" + $type + "Spread_MD.input2X");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl.rotateSpreadVal") ($modCore + $nPdCh + $crntCh + "_Rotate" + $type + "Spread_MD.input2X");
						//REVERSE NODE FOR INVERTED VALUE
						shadingNode -asUtility reverse -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Translate" + $type + "Spread_Reverse");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl.translateSpreadVal") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Translate" + $type + "Spread_Reverse.inputX");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Translate" + $type + "Spread_Reverse.outputX") ($modCore + $nPdCh + $crntCh + "_Translate" + $type + "Spread_MD.input2Y");
						
						shadingNode -asUtility reverse -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Rotate" + $type + "Spread_Reverse");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "Ctrl.translateSpreadVal") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Rotate" + $type + "Spread_Reverse.inputX");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_Rotate" + $type + "Spread_Reverse.outputX") ($modCore + $nPdCh + $crntCh + "_Rotate" + $type + "Spread_MD.input2Y");
	
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_Translate" + $type + "Spread_MD.outputY") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp_parentConstraint1." + $modCore + "_SpreadTranslate_" + $type + "StartLctrW1");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_Rotate" + $type + "Spread_MD.outputY") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp_parentConstraint2." + $modCore + "_SpreadRotate_" + $type + "StartLctrW1");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_Translate" + $type + "Spread_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp_parentConstraint1." + $modCore + "_SpreadTranslate_" + $type + "EndLctrW2");
						connectAttr -force ($modCore + $nPdCh + $crntCh + "_Rotate" + $type + "Spread_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $type + "_SpreadCtrlGrp_parentConstraint2." + $modCore + "_SpreadRotate_" + $type + "EndLctrW2");
						
						if ($fKJointSize == 1)
						{//DON'T LOOP IF THERE IS ONLY ONE JOINT PER CHAIN
							$doubleLoop = 2;
						}
						$type = "Spline";
						$spreadPos = ".splineAutoSpreadPos";
						$spreadRot = ".splineAutoSpreadRot";
						$doubleLoop++;
					}
				}
				else if ($fKJointSize > 1)
				{
					parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp") ($modCore + "_MainChainCtrlGrp");
					if ($enableIK == 1)
					{
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp") ($modCore + "_MainChainCtrlGrp");
					}
				}
				else
				{
					parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp") ($modCore + "_MainChainCtrlGrp");
				}
					
				//ORIENT JOINT
				if (`objExists ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPdNext + $nextJnt)`)
				{
					//GET LOCATION OF TOP CV
					$proxyAim = `xform -ws -q -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Shape.cv[7]")`;
					$proxyUp = `xform -ws -q -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "DShape.cv[1]")`;
					//CREATE LOCATOR
					spaceLocator -n ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					spaceLocator -n ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
					move -r $proxyAim[0] $proxyAim[1] $proxyAim[2] ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					move -r $proxyUp[0] $proxyUp[1] $proxyUp[2] ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
					
					delete `aimConstraint -offset 0 $rotOffset 0 -aimVector ($multiplier * 1) 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr")
					("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp")`;

					scale -r 1 0.667 0.9 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl");
					makeIdentity -apply true -s 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl");

					delete ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					delete ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
				}
				else
				{
					delete `parentConstraint ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp")`;
					//GET ORIENTATION USING THE END POINT OF THE END CONTROL
					$proxyAim = `xform -ws -q -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "DShape.cv[1]")`;
					$ProxyUp = `xform -ws -q -t ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Shape.cv[3]")`;
					spaceLocator -n ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					spaceLocator -n ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
					move -r $proxyAim[0] $proxyAim[1] $proxyAim[2] ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					move -r $ProxyUp[0] $ProxyUp[1] $ProxyUp[2] ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
					
					delete `aimConstraint -offset 0 $rotOffset 0 -aimVector 1 0 0 -upVector 0 ($multiplier * 1) 0 -worldUpType "object" -worldUpObject ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr")
					("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp")`;

					scale -r 1 0.667 0.9 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl");
					makeIdentity -apply true -s 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl");

					delete ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_AimLctr");
					delete ("RRM_" + $prfx + $core + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_UpLctr");
				}
				
				if ($fKJointSize > 1)
				{
					//ORIENT SPLINE CONTROLS
					if ($crntJnt == 1)
					{
						parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "JntFKGrp");
						
						if ($enableIK == 1)
						{
							//CONNECT BLEND
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Blnd");
							connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntIKGrp.translate") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntFKGrp.translate") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Blnd.color2");
							
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Blnd");
							connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntIKGrp.rotate") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntFKGrp.rotate") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Blnd.color2");
							
	
							//CREATE ADD
							
							//CREATE BLENDS TO DISABLE ADD
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Add_Blnd");
							connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Add_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntIKGrp.translate") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Add_Blnd.color1");
							$JntIK_Pos = `getAttr ($modCore + $nPdCh + $crntCh + "JntIKGrp.translate")`;
							setAttr (($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Add_Blnd.color2"), $JntIK_Pos[0], $JntIK_Pos[1], $JntIK_Pos[2]);
		
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Add_Blnd");
							connectAttr -f ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Add_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntIKGrp.rotate") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Add_Blnd.color1");
							$JntIK_Rot = `getAttr ($modCore + $nPdCh + $crntCh + "JntIKGrp.rotate")`;
							setAttr (($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Add_Blnd.color2"), $JntIK_Rot[0], $JntIK_Rot[1], $JntIK_Rot[2]);
							
							shadingNode -asUtility plusMinusAverage -n ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Pma");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Add_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Pma.input3D[0]");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntFKGrp.translate") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Pma.input3D[1]");
		
							shadingNode -asUtility plusMinusAverage -n ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Pma");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Add_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Pma.input3D[0]");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntFKGrp.rotate") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Pma.input3D[1]");
							
							//CREATE MASTER BLEND FOR BLEND AND ADD
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Master_Blnd");
							connectAttr ($modCore + "_MasterCtrl.blendedAdditive") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Master_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Pma.output3D") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Master_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Master_Blnd.color2");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Pos_Master_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp.translate");
		
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Master_Blnd");
							connectAttr ($modCore + "_MasterCtrl.blendedAdditive") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Master_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Pma.output3D") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Master_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Master_Blnd.color2");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "JntGrp_Rot_Master_Blnd.output") ($modCore + $nPdCh + $crntCh + "JntGrp.rotate");
						}
					}
					else
					{
						delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK")`;
						delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt")`;
						makeIdentity -apply true -r 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK");
						if ($enableIK == 1)
						{
							delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK")`;
							makeIdentity -apply true -r 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK");
						}
					}
						
					parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK");
					
					if ($crntSide == "right" && $fKJointSize > 1 && $enableIK == 1)
					{
						delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide")`;
						//rotate -r -os 0 180 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide");
						makeIdentity -apply true -r 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide");
					}
					
					
					//SCALE CONSTRAINT FK JOINTS TO CONTROLS
					if ($crntJnt == 1)
					{
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.scale");
					}
					else
					{
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFK_Scale_MD");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFK.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFK_Scale_MD.input1");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFK_Scale_MD.input2");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFK_Scale_MD.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.scale");
					}
						
					if ($crntJnt != 1)
					{
						//parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp");
						//connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "Ctrl.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp.scale");
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "Ctrl");
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "Jnt");
						parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntFK");
						if ($enableIK == 1)
						{
							parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntIK");
						
							if ($crntSide == "right")
							{
								parent ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "JntIKGuide");
							}
						}
	
						if ($fKJointSize > 1 && $enableIK == 1)
						{
							//ORIENT SPLINE CONTROLS
							delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp")`;
							parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_ScaleGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp");
	
							if ($crntJnt != 1)
							{
								//ADD ATTRIBUTES TO THE CONTROLS
								addAttr -ln "followAmount" -at double -min 0 -max 1 -dv 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
								setAttr -e-keyable 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.followAmount");
		
								addAttr -ln "parentInfluence" -at double -min 0 -max 1 -dv 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
								setAttr -e-keyable 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.parentInfluence");
								
								//ATTRIBUTE CONNECTIONS
								shadingNode -asUtility reverse -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineCtrl_Follow_Rev");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.followAmount") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineCtrl_Follow_Rev.inputX");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineCtrl_Follow_Rev.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");
								shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineCtrl_Follow_MD");
								shadingNode -asUtility reverse -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_ParentInf_Rev");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.followAmount") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineCtrl_Follow_MD.input1X");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.followAmount") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineCtrl_Follow_MD.input1Y");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.parentInfluence") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineCtrl_Follow_MD.input2X");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.parentInfluence") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_ParentInf_Rev.inputX");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl_ParentInf_Rev.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineCtrl_Follow_MD.input2Y");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineCtrl_Follow_MD.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp_parentConstraint1." + $modCore + $nPdCh + $crntCh + "_" + $nPdPrev + $previousJnt + "SplineCtrlW2");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineCtrl_Follow_MD.outputY") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp_parentConstraint1." + $modCore + "_ScaleGrpW1");
							}
						}
					}
					else if ($crntJnt == 1 && $fKJointSize > 1)
					{
						if ($enableIK == 1)
						{
							//ORIENT SPLINE CONTROLS
							delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "CtrlGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp")`;
							if ($crntCh == 1 || $crntCh == $fKChainSize)
							{
								parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_ScaleGrp") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp");
							}
							parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "JntIKGrp");
		
							//ADD ATTRIBUTES TO THE FIRST CONTROL
							addAttr -ln "followAmount" -at double -min 0 -max 1 -dv 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
							setAttr -e-keyable 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.followAmount");
							
							addAttr -ln "stretch" -at double -min 0 -max 1 -dv 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
							setAttr -e-keyable 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.stretch");
							
							addAttr -ln "autoVolume" -at double -min 0 -max 1 -dv 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl");
							setAttr -e-keyable 1 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.autoVolume");
		
							//ATTRIBUTE CONNECTIONS
							if ($crntCh == 1 || $crntCh == $fKChainSize)
							{
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.followAmount") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp_parentConstraint1." + $modCore + "_ScaleGrpW1");
								shadingNode -asUtility reverse -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineCtrl_Follow_Rev");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.followAmount") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineCtrl_Follow_Rev.inputX");
								connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineCtrl_Follow_Rev.outputX") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW0");
							}
	
							//CONNECT SPLINE ATTRIBUTE TO CONDITIONALS FOR THE VISIBILITY OF THE CONTROLS
							shadingNode -asUtility condition -n ($modCore + $nPdCh + $crntCh + "_SplineCtrl_Vis_Condition");
							connectAttr -f ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_SplineCtrl_Vis_Condition.firstTerm");
							setAttr ($modCore + $nPdCh + $crntCh + "_SplineCtrl_Vis_Condition.secondTerm") 0;
							setAttr ($modCore + $nPdCh + $crntCh + "_SplineCtrl_Vis_Condition.operation") 0;
							
							shadingNode -asUtility condition -n ($modCore + $nPdCh + $crntCh + "_FKCtrl_Vis_Condition");
							connectAttr -f ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_FKCtrl_Vis_Condition.firstTerm");
							setAttr ($modCore + $nPdCh + $crntCh + "_FKCtrl_Vis_Condition.secondTerm") 1;
							setAttr ($modCore + $nPdCh + $crntCh + "_FKCtrl_Vis_Condition.operation") 0;
							
							//CREATE CONDITIONAL TO OVERRIDE VISIBILITY IF ADDITIVE IS ON.
							shadingNode -asUtility condition -n ($modCore + $nPdCh + $crntCh + "_VisAdditiveOverride_Condition");
							connectAttr -f ($modCore + "_MasterCtrl.blendedAdditive") ($modCore + $nPdCh + $crntCh + "_VisAdditiveOverride_Condition.firstTerm");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_FKCtrl_Vis_Condition.outColorR") ($modCore + $nPdCh + $crntCh + "_VisAdditiveOverride_Condition.colorIfTrueR");
						}
					}
					
					if ($fKJointSize > 1)
					{
						//CREATE BLEND FOR THE STARTING GROUP IF IT DOESN'T ALREADY EXIST
						//CONNECT SPLINE ATTRIBUTE TO BLEND THE SKINNING JOINTS
						//BLENDS
						if ($enableIK == 1)
						{
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Blnd");
							connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK.translate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.translate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Blnd.color2");
							
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Blnd");
							connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK.rotate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.rotate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Blnd.color2");
							
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Scale_Blnd");
							connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Scale_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Scale_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Scale_Blnd.color2");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Scale_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.scale");
						
							//ADDS
							//CREATE BLENDS TO DISABLE ADD
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Add_Blnd");
							connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Add_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK.translate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Add_Blnd.color1");
							$JntFK_Pos = `getAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.translate")`;
							setAttr (($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Add_Blnd.color2"), $JntFK_Pos[0], $JntFK_Pos[1], $JntFK_Pos[2]);
		
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Add_Blnd");
							connectAttr ($modCore + "_MasterCtrl.splineIK" + $nPdCh + $crntCh + "Inf") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Add_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK.rotate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Add_Blnd.color1");
							$JntFK_Rot = `getAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.rotate")`;
							setAttr (($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Add_Blnd.color2"), $JntFK_Rot[0], $JntFK_Rot[1], $JntFK_Rot[2]);
		
							shadingNode -asUtility plusMinusAverage -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Pma");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Add_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Pma.input3D[0]");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.translate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Pma.input3D[1]");
		
							shadingNode -asUtility plusMinusAverage -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Pma");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Add_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Pma.input3D[0]");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntFK.rotate") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Pma.input3D[1]");
						
							//CREATE SUBTRACT TO ZERO OUT JOINTS
							$jointTranslate = `getAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.translate")`;
							shadingNode -asUtility plusMinusAverage -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_PosSubtract_Pma");
							setAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_PosSubtract_Pma.operation") 2;
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Pma.output3D") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_PosSubtract_Pma.input3D[0]");
							setAttr (($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_PosSubtract_Pma.input3D[1]"), ($jointTranslate[0]*1), ($jointTranslate[1]*1), ($jointTranslate[2]*1));
							
							//CREATE MASTER BLEND FOR BLEND AND ADD
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Master_Blnd");
							connectAttr ($modCore + "_MasterCtrl.blendedAdditive") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Master_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_PosSubtract_Pma.output3D") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Master_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Blnd.output")  ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Master_Blnd.color2");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Pos_Master_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.translate");
		
							shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Master_Blnd");
							connectAttr ($modCore + "_MasterCtrl.blendedAdditive") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Master_Blnd.blender");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Pma.output3D") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Master_Blnd.color1");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Blnd.output")  ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Master_Blnd.color2");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "_SplineIK_Rot_Master_Blnd.output") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.rotate");
					
							//CONNECT SPLINE ATTRIBUTE TO THE VISIBILITY OF THE CONTROLS
							connectAttr -f  ($modCore + $nPdCh + $crntCh + "_VisAdditiveOverride_Condition.outColorR") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl.v");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_SplineCtrl_Vis_Condition.outColorR") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.v");
							setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl.v");
							setAttr -l 1 -k 0 ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl.v");
						}
					}
					//ORIENT CONSTRAINT RIGHT IK JOINTS TO GUIDE JOINTS
					if ($crntSide == "right" && $fKJointSize > 1 && $enableIK == 1)
					{
						parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK");
						connectAttr ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIKGuide.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "JntIK.scale");
					}
						
					//CREATE SPLINE IK
					if (($crntJnt == $fKJointSize) && ($fKJointSize > 2) && $enableIK == 1)
					{
						$JntIK = "JntIK";
						if ($crntSide == "right")
						{
							$JntIK = "JntIKGuide";
						}
						
						select ($modCore + $nPdCh + $crntCh + "_01" + $JntIK) ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $JntIK);
						ikHandle -n ($modCore + $nPdCh + $crntCh + "_IKHandle") -sol ikSplineSolver -scv false;
						$SplineCurve = `listConnections -type "nurbsCurve" ($modCore + $nPdCh + $crntCh + "_IKHandle")`;
						rename $SplineCurve ($modCore + $nPdCh + $crntCh + "_SplineCurve");
						arclen -ch 1 ($modCore + $nPdCh + $crntCh + "_SplineCurve");
						$curveInfoNode = `listConnections -t curveInfo -d 1 -s 0 ($modCore + $nPdCh + $crntCh + "_SplineCurveShape")`;
						rename $curveInfoNode[0] ($modCore + $nPdCh + $crntCh + "_SplineLengthInfo");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_SplineCtrl_Vis_Condition.outColorR") ($modCore + $nPdCh + $crntCh + "_SplineCurve.v");
						setAttr ($modCore + $nPdCh + $crntCh + "_SplineCurve.template") 1;

						addAttr -ln "nonControl"  -dt "string" ($modCore + $nPdCh + $crntCh + "_SplineCurve");
						setAttr -e-keyable 1 ($modCore + $nPdCh + $crntCh + "_SplineCurve.nonControl");
						setAttr -lock 1 ($modCore + $nPdCh + $crntCh + "_SplineCurve.nonControl");

						parent ($modCore + $nPdCh + $crntCh + "_SplineCurve") ($modCore + "_extraCurveNodesGrp");
						
						parent ($modCore + $nPdCh + $crntCh + "_IKHandle") ($modCore + "_curveNodesGrp");
						setAttr ($modCore + $nPdCh + $crntCh + "_IKHandle.v") 0;
						
						//CONNECT SCALE
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_HierarchyCompensate_MD");
						setAttr ($modCore + $nPdCh + $crntCh + "_HierarchyCompensate_MD.operation") 2;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_SplineLengthInfo.arcLength") ($modCore + $nPdCh + $crntCh + "_HierarchyCompensate_MD.input1X");
						connectAttr -f ($modName + "_MAINCtrl.scaleY") ($modCore + $nPdCh + $crntCh + "_HierarchyCompensate_MD.input2X");
						
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_HierarchyCompensate_MD.outputX") ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.input1X");
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.operation") 2;
						
						float $splineLengthValue = `getAttr ($modCore + $nPdCh + $crntCh + "_SplineLengthInfo.arcLength")`;
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.input2X") $splineLengthValue;
						
						//BLEND SCALE
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd");
						connectAttr ($modCore + $nPdCh + $crntCh + "_01SplineCtrl.stretch") ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.blender");
						setAttr ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.color2") -type double3 1 1 1 ;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.outputX") ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.color1R");
						
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIK + ".scaleX");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $JntIK + ".scaleX");
						
						//INVERSE SCALE
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD");
						setAttr ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.input1X") 1;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.input2X");
						setAttr ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.operation") 2;
						
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd");
						connectAttr ($modCore + $nPdCh + $crntCh + "_01SplineCtrl.autoVolume") ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.blender");
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.color2") -type double3 1 1 1 ;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.outputX") ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.color1R");
						
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIK + ".scaleY");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIK + ".scaleZ");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $JntIK + ".scaleY");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + $JntIK + ".scaleZ");
	
						//ADVANCED TWIST
						spaceLocator -n ($modCore + $nPdCh + $crntCh + "_IKTwistStartLctr");
						spaceLocator -n ($modCore + $nPdCh + $crntCh + "_IKTwistEndLctr");
						parentConstraint ($modCore + $nPdCh + $crntCh + "_01SplineCtrl") ($modCore + $nPdCh + $crntCh + "_IKTwistStartLctr");
						parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_IKTwistEndLctr");
	
						parent ($modCore + $nPdCh + $crntCh + "_IKTwistStartLctr") ($modCore + $nPdCh + $crntCh + "_IKTwistEndLctr") ($modCore + "Grp");
						setAttr ($modCore + $nPdCh + $crntCh + "_IKTwistStartLctr.v") 0;
						setAttr ($modCore + $nPdCh + $crntCh + "_IKTwistEndLctr.v") 0;
						
						setAttr ($modCore + $nPdCh + $crntCh + "_IKHandle.dTwistControlEnable") 1;
						setAttr ($modCore + $nPdCh + $crntCh + "_IKHandle.dWorldUpType")  4;
						
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_IKTwistStartLctr.xformMatrix") ($modCore + $nPdCh + $crntCh + "_IKHandle.dWorldUpMatrix");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_IKTwistEndLctr.xformMatrix")   ($modCore + $nPdCh + $crntCh + "_IKHandle.dWorldUpMatrixEnd");
	
						
						////////////CREATE CLUSTERS////////////
						//START CLUSTER
						select ($modCore + $nPdCh + $crntCh + "_SplineCurve.cv[0:1]");
						newCluster " -envelope 1";
						rename ($modCore + $nPdCh + $crntCh + "_SplineCurveStartClstr");
						parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_01SplineCtrl") ($modCore + $nPdCh + $crntCh + "_SplineCurveStartClstr");
						setAttr ($modCore + $nPdCh + $crntCh + "_SplineCurveStartClstr.v") 0;
						parent ($modCore + $nPdCh + $crntCh + "_SplineCurveStartClstr") ($modCore + "_curveNodesGrp");
						
						//MIDDLE CLUSTERS
						int $midClstrInt = 2;
						int $prevMidClstrInt = 1;
						string $prevMidControlnPd;
						while ($midClstrInt < $crntJnt)
						{
							$midControlnPd = "0";
							if ($midClstrInt > 9)
							{
								$midControlnPd = "";
							}
							$prevMidControlnPd = "0";
							if ($midClstrInt > 9)
							{
								$prevMidControlnPd = "";
							}
	
							select ($modCore + $nPdCh + $crntCh + "_SplineCurve.cv[" + $midClstrInt + "]");
							newCluster " -envelope 1";
							rename ($modCore + $nPdCh + $crntCh + "_SplineCurve" + $midClstrInt + "Clstr");
							parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $midControlnPd + $midClstrInt + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_SplineCurve" + $midClstrInt + "Clstr");
							setAttr ($modCore + $nPdCh + $crntCh + "_SplineCurve" + $midClstrInt + "Clstr.v") 0;
							parent ($modCore + $nPdCh + $crntCh + "_SplineCurve" + $midClstrInt + "Clstr") ($modCore + "_curveNodesGrp");
							
							//CONNECT STRETCH TO MIDDLE JOINTS
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $midControlnPd + $midClstrInt + $JntIK + ".scaleX");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $midControlnPd + $midClstrInt + $JntIK + ".scaleY");
							connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_" + $midControlnPd + $midClstrInt + $JntIK + ".scaleZ");
							$midClstrInt++;
							$prevMidClstrInt++;
						}
						//END CLUSTER
						select ($modCore + $nPdCh + $crntCh + "_SplineCurve.cv[" + $crntJnt + ":" + ($crntJnt + 1) + "]");
						newCluster " -envelope 1";
						rename ($modCore + $nPdCh + $crntCh + "_SplineCurveEndClstr");
						parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_SplineCurveEndClstr");
						setAttr ($modCore + $nPdCh + $crntCh + "_SplineCurveEndClstr.v") 0;
						parent ($modCore + $nPdCh + $crntCh + "_SplineCurveEndClstr") ($modCore + "_curveNodesGrp");
					}
					else if (($crntJnt == $fKJointSize) && ($fKJointSize == 2) && $enableIK == 1)
					{
						$JntIK = "JntIK";
						if ($crntSide == "right")
						{
							$JntIK = "JntIKGuide";
							$multiplier = -1;
						}
						//USE AIM CONSTRAINTS IF ONLY TWO JOINTS PER CHAIN
						aimConstraint -mo -aimVector $multiplier 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject ($modCore + $nPdCh + $crntCh + "_01" + "SplineCtrl")
						($modCore + $nPdCh + $crntCh + "_02" + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_01" + $JntIK);
						if ($crntSide == "right")
						{
							pointConstraint ($modCore + $nPdCh + $crntCh + "_01" + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_01" + $JntIK);
							delete `parentConstraint ($modCore + $nPdCh + $crntCh + "_02" + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_02" + $JntIK)`;
							rotate -r 0 -180 0 ($modCore + $nPdCh + $crntCh + "_02" + $JntIK);
							parentConstraint -mo ($modCore + $nPdCh + $crntCh + "_02" + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_02" + $JntIK);
						}
						else
						{
							parentConstraint ($modCore + $nPdCh + $crntCh + "_02" + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_02" + $JntIK);
						}
						
						//STRETCH
						spaceLocator -n ($modCore + $nPdCh + $crntCh + "_IKStretch_AimLctr");
						spaceLocator -n ($modCore + $nPdCh + $crntCh + "_IKStretch_TargetLctr");
						parent ($modCore + $nPdCh + $crntCh + "_IKStretch_TargetLctr") ($modCore + $nPdCh + $crntCh + "_IKStretch_AimLctr");
						setAttr ($modCore + $nPdCh + $crntCh + "_IKStretch_AimLctr.v") 0;
						parent ($modCore + $nPdCh + $crntCh + "_IKStretch_AimLctr") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SplineCtrlGrp");
						pointConstraint ($modCore + $nPdCh + $crntCh + "_01" + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_IKStretch_AimLctr");
						aimConstraint -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none"
						($modCore + $nPdCh + $crntCh + "_02" + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_IKStretch_AimLctr");
						pointConstraint ($modCore + $nPdCh + $crntCh + "_02" + "SplineCtrl") ($modCore + $nPdCh + $crntCh + "_IKStretch_TargetLctr");
						$targetLctrPos = `getAttr ($modCore + $nPdCh + $crntCh + "_IKStretch_TargetLctr.tx")`;
						
						//SCALE
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD");
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.operation") 2;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_IKStretch_TargetLctr.tx") ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.input1X");
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.input2X") $targetLctrPos;
						
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd");
						connectAttr ($modCore + $nPdCh + $crntCh + "_01SplineCtrl.stretch") ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.blender");
						setAttr ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.color2") -type double3 1 1 1 ;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatio_MD.outputX") ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.color1R");
						
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIK + ".scaleX");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_02" + $JntIK + ".scaleX");
						
						//INVERSE SCALE
						shadingNode -asUtility multiplyDivide -n ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD");
						setAttr ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.operation") 2;
						setAttr ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.input1X") 1;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_Stretch_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.input2X");
						
						shadingNode -asUtility blendColors -n ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd");
						connectAttr ($modCore + $nPdCh + $crntCh + "_01SplineCtrl.autoVolume") ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.blender");
						setAttr ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.color2") -type double3 1 1 1 ;
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_StretchInverse_MD.outputX") ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.color1R");
						                                                                                                                                         
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIK + ".scaleY");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_01" + $JntIK + ".scaleZ");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_02" + $JntIK + ".scaleY");
						connectAttr -f ($modCore + $nPdCh + $crntCh + "_LengthRatioInverse_Blnd.outputR") ($modCore + $nPdCh + $crntCh + "_02" + $JntIK + ".scaleZ");
					}
				}
				else
				{
					parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "JntGrp");
				}
				
				if ($enableIK == 0)
				{
					parentConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt");
					connectAttr -f ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl.scale") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.scale");
					//scaleConstraint ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Ctrl") ($modCore + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt");
				}
				$crntJnt++;
			}
			$crntCh++;
		}
		//ATTACH LOCATORS TO FIRST JOINT OF START AND END JOINT
		if ($fKChainSize > 2)
		{
			string $nPdCh = "_";
			if ($fKChainSize < 10)
			{
				$nPdCh = "_0";
			}
			$doubleLoop = 0;
			if ($enableIK == 0)
			{
				$doubleLoop = 1;
			}
			$type = "";
			$jointType = "FK";
			while ($doubleLoop < 2)
			{
				pointConstraint -mo  ($modCore + "_01_01Jnt" + $jointType) ($modCore + "_SpreadTranslate_" + $type + "StartLctr");
				pointConstraint -mo  ($modCore + $nPdCh + $fKChainSize + "_01Jnt" + $jointType) ($modCore + "_SpreadTranslate_" + $type + "EndLctr");
				parentConstraint -mo ($modCore + "_01_01Jnt" + $jointType) ($modCore + "_SpreadRotate_" + $type + "StartLctr");
				parentConstraint -mo ($modCore + $nPdCh + $fKChainSize + "_01Jnt" + $jointType)($modCore + "_SpreadRotate_" + $type + "EndLctr");
				$jointType = "IK";
				$type = "Spline";
				$doubleLoop++;
			}
		}
		
		
		//ADD CORE NAME
		$modControls = `ls ($modCore + "_*Ctrl")`;
		for ($crntModControl in $modControls)
		{
			addAttr -ln "modCoreName"  -dt "string" $crntModControl;
			setAttr -e-keyable 1 ($crntModControl + ".modCoreName");
			setAttr -type "string" ($crntModControl + ".modCoreName") ("_" + $prfx + $core);
			setAttr -e-lock 1 ($crntModControl + ".modCoreName");
			
			//ADD MODULE TYPE
			addAttr -ln "moduleType"  -dt "string" ($crntModControl);
			setAttr -e -keyable 1 ($crntModControl + ".moduleType");
			setAttr -type "string" ($crntModControl + ".moduleType") "fkChain";
			setAttr -l true ($crntModControl + ".moduleType");
			
			//ADD DIRECTION
			$direction = `getAttr ($topNode + ".direction")`;
			addAttr -ln "direction"  -at long ($crntModControl);
			setAttr -e-keyable 1 ($crntModControl + ".direction");
			setAttr ($crntModControl + ".direction") $direction;
			setAttr -l true ($crntModControl + ".direction");
		}
		
		//LOCK MAIN CONTROL ATTRIBUTES
		setAttr -lock 1 -keyable 0 ($modCore + "_MasterCtrl.tx");
		setAttr -lock 1 -keyable 0 ($modCore + "_MasterCtrl.ty");
		setAttr -lock 1 -keyable 0 ($modCore + "_MasterCtrl.tz");
		setAttr -lock 1 -keyable 0 ($modCore + "_MasterCtrl.rx");
		setAttr -lock 1 -keyable 0 ($modCore + "_MasterCtrl.ry");
		setAttr -lock 1 -keyable 0 ($modCore + "_MasterCtrl.rz");
		setAttr -lock 1 -keyable 0 ($modCore + "_MasterCtrl.sx");
		setAttr -lock 1 -keyable 0 ($modCore + "_MasterCtrl.sy");
		setAttr -lock 1 -keyable 0 ($modCore + "_MasterCtrl.sz");
		setAttr -lock 1 -keyable 0 ($modCore + "_MasterCtrl.v");
		
		select -cl;
		
		//SETUP FOR RIGHT SIDE
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$mirrorInt++;
		$multiplier = -1;
		$rotOffset = 180;
	}
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE HEAD MODULE////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRig_V1Head_V1(string $modName, string $moduleName, string $topNode)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;     

	//INTEGER FOR LOOP
	$mirrorInt = 2;
	$multiplier = 1;
	
	$core = `getAttr ($topNode + ".core")`;
	string $prfx = "";
	string $oppPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = "l_";
		$oppPrfx = "r_";
		$mirrorInt = 1;
	}
	$crntSide = "left";
	$oppSide = "right";
	
	while ($mirrorInt <= 2)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modName + "_" + $prfx + $core);
		
		$modOppCore = ($modName + "_" + $oppPrfx + $core);
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		delete `orientConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_OffsetLctr");
		
		group -em -n ($modCore);
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modName + "_ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_ROOTJnt") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modName + "_MAINCtrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "head";
		setAttr -l true ($modCore + "Grp.topNode");	
		
		//CORE NAME
		addAttr -ln "coreName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ("_" + $prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable 1 ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ("_" + $oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable 1 ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");
		}
		
		//NODE-SPECIFICtrl ATTRIBUTES
		//JAW
		if (`objExists ("RRM_" + $prfx + $core + "_Jaw")`)
		{
			addAttr -ln "jaw"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable 1 ($modCore + "Grp.jaw");
			setAttr -l true ($modCore + "Grp.jaw");
		}
	
	
		//SCALE GROUP
		group -em -n ($modCore + "_ScaleGrp");
		delete `aimConstraint -offset 0 0 0 -aimVector 0 1 0 -upVector 1 0 0 -worldUpType "objectrotation" -worldUpVector 1 0 0 -worldUpObject ("RRM_" + $prfx + $core + "_Parent")
		("RRM_" + $prfx + $core + "_Top") ($modCore + "_ScaleGrp")`;
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + "_ScaleGrp.scale");
		
		//MASTER SCALE GROUP
		group -em -n ($modCore + "_MasterCtrlScaleGrp");
	
		//HEAD CONTROL
		curve -n ($modCore + "_MasterCtrl") -d 1 -p -1 0 -1 -p 1 0 -1 -p 1 0 1 -p -1 0 1 -p -1 0 -1 -k 0 -k 1 -k 2 -k 3 -k 4 ;
		rename `listRelatives -c ($modCore + "_MasterCtrl")` ($modCore + "_MasterCtrlShape");
		
		//GET SIZE
		spaceLocator -n ($modCore + "_HeadStartLctr");
		spaceLocator -n ($modCore + "_HeadEndLctr");
		parent ($modCore + "_HeadEndLctr") ($modCore + "_HeadStartLctr");
		pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_HeadStartLctr");
		aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "none" ("RRM_" + $prfx + $core + "_Top") ($modCore + "_HeadStartLctr");
		pointConstraint ("RRM_" + $prfx + $core + "_Top") ($modCore + "_HeadEndLctr");
		$scale = `getAttr ($modCore + "_HeadEndLctr.tx")`;
		scale -r ($scale /5) ($scale /5) ($scale /5) ($modCore + "_MasterCtrl");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_MasterCtrl");
	
		group -n ($modCore + "_MasterCtrlGrp") ($modCore + "_MasterCtrl");
		parent ($modCore + "_MasterCtrlGrp") ($modCore + "_ScaleGrp");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Parent") ($modCore + "_MasterCtrlGrp")`;
		//makeIdentity -apply false -t 1 -r 1 ($modCore + "_MasterCtrlGrp");
		move -r -os -wd 0 ($scale * 1.3) 0 ($modCore + "_MasterCtrl.cv[0:24]");
		makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_MasterCtrl");
		parentConstraint -mo ($modCore) ($modCore + "_MasterCtrlGrp");
		 
		//PARENT ORIENT
		$parentOrient = ($modCore + "_MasterCtrl");
		RRM_ParentOrient_V1($modCore, $modName, $modAttachNode, $parentOrient);
		
	
		if (`objExists ("RRM_" + $prfx + $core + "_Jaw")`)
		{
		//JAW CONTROL
			circle -n ($modCore + "_JawCtrl")  -ch 0;
			scale -r 1 0.5 1 ($modCore + "_JawCtrl");
			move -r -os -wd 0 0 1.2 ($modCore + "_JawCtrl.cv[1]") ($modCore + "_JawCtrl.cv[5]");
			move -r -os -wd 0 0 0.58 ($modCore + "_JawCtrl.cv[0]") ($modCore + "_JawCtrl.cv[2]") ($modCore + "_JawCtrl.cv[4]") ($modCore + "_JawCtrl.cv[6]");
			select ($modCore + "_JawCtrl") ;
			rotate -r -os 35 0 0 ($modCore + "_JawCtrl");
			scale -r ($scale /3) ($scale /3) ($scale /3);
			makeIdentity -apply true -t 1 -r 1 -s 1 ($modCore + "_JawCtrl");
			group -n ($modCore + "_JawCtrlGrp");
			parent ($modCore + "_JawCtrlGrp") ($modCore + "_MasterCtrlScaleGrp");
			
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Jaw") ($modCore + "_JawCtrlGrp")`;
			delete `pointConstraint ("RRM_" + $prfx + $core + "_JawEnd") ($modCore + "_JawCtrl")`;
			$jawCOffset = `getAttr ($modCore + "_JawCtrl.translate")`;
			move -r ($jawCOffset[0] * 1.2) ($jawCOffset[1] * 1.2) ($jawCOffset[2] * 1.2) ($modCore + "_JawCtrl.translate");
			makeIdentity -apply true ($modCore + "_JawCtrl");
			$jawPivot = `xform -q -ws -rp ("RRM_" + $prfx + $core + "_Jaw")`;
			move -a $jawPivot[0] $jawPivot[1] $jawPivot[2] ($modCore + "_JawCtrl.scalePivot") ($modCore + "_JawCtrl.rotatePivot") ;
			
		
			//JOINTS
			select -cl;
			joint -n ($modCore + "_JawJnt");
			joint -n ($modCore + "_JawEndJnt");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_Jaw") ($modCore + "_JawJnt")`;
			parentConstraint -mo ($modCore + "_JawCtrl") ($modCore + "_JawJnt");
			delete `parentConstraint ("RRM_" + $prfx + $core + "_JawEnd") ($modCore + "_JawEndJnt")`;
			//parentConstraint -mo ($modCore + "_MasterCtrl") ($modCore + "_JawCtrlGrp");
			
			parent ($modCore + "_JawJnt") ($modCore + "_MasterCtrlScaleGrp");
		}
		
		parent ($modCore + "_MasterCtrlScaleGrp") ($modCore + "_ScaleGrp");
			
		
		select -cl;
		joint -n ($modCore + "_TopJnt");
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Top") ($modCore + "_TopJnt")`;
		//parentConstraint -mo ($modCore + "_MasterCtrl") ($modCore + "_TopJnt");
		
		parent ($modCore + "_TopJnt") ($modCore + "_MasterCtrlScaleGrp");
		
		//SET JAW AND END NODES TO SCALE WITH MASTER CTRL
		scaleConstraint ($modCore + "_MasterCtrl") ($modCore + "_MasterCtrlScaleGrp");
		parentConstraint -mo ($modCore + "_MasterCtrl") ($modCore + "_MasterCtrlScaleGrp");
		
		delete ($modCore + "_HeadStartLctr") ($modCore + "_HeadEndLctr");
	
		//ADD CORE NAME
		select ($modCore + "_MasterCtrl");
		if (`objExists ($modCore + "_JawCtrl")`)
		{
			select -add ($modCore + "_JawCtrl");
		}
		$modControls = `ls -sl`;
		for ($crntModControl in $modControls)
		{
			addAttr -ln "modCoreName"  -dt "string" $crntModControl;
			setAttr -e-keyable 1 ($crntModControl + ".modCoreName");
			setAttr -type "string" ($crntModControl + ".modCoreName") ("_" + $prfx + $core);
			setAttr -e-lock 1 ($crntModControl + ".modCoreName");

			//ADD MODULE TYPE
			addAttr -ln "moduleType"  -dt "string" ($crntModControl);
			setAttr -e -keyable 1 ($crntModControl + ".moduleType");
			setAttr -type "string" ($crntModControl + ".moduleType") "head";
			setAttr -l true ($crntModControl + ".moduleType");
		}
		
		//SETUP FOR RIGHT SIDE
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$mirrorInt++;
		$multiplier = -1;
	}
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE LOOK AT MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EyeControl_V1()
{
	circle -n "RRM_EyeControl_V1" -nr 0 1 0 -r 1 -ch 0;
	curve -n "RRM_EyeControl_V11" -d 1 -p 0 0 -1 -p 0 0 1 -k 0 -k 1 ;
	rename `listRelatives -c "RRM_EyeControl_V11"` "RRM_EyeControl_V11Shape";
	curve -n "RRM_EyeControl_V12" -d 1 -p -1 0 0 -p 1 0 0 -k 0 -k 1 ;
	rename `listRelatives -c "RRM_EyeControl_V12"` "RRM_EyeControl_V12Shape";
		
	parent -r -s "RRM_EyeControl_V11Shape" "RRM_EyeControl_V12Shape" "RRM_EyeControl_V1";
	delete "RRM_EyeControl_V11" "RRM_EyeControl_V12";
}

global proc RRM_GenerateRig_V1LookAt_V1(string $modName, string $moduleName, string $topNode)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	$mirrorInt = 1;
	float $rotOffset = 0;
	float $lookAtSize;
	string $modAttachNode;
	string $modCore;
	
	string $prfx = "";
	string $oppPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = "l_";
		$oppPrfx = "r_";
		$mirrorInt = 0;
	}
	$crntSide = "left";
	$oppSide = "right";
	
	while ($mirrorInt <= 1)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Parent.attachNode")`;
		
		$modCore = ($modName + "_" + $prfx + $core);
		$modOppCore = ($modName + "_" + $oppPrfx + $core);
		
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		delete `orientConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_OffsetLctr");
		
		group -em -n ($modCore);
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modName + "_ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_ROOTJnt") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modName + "_MAINCtrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
	
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "lookAt";
		setAttr -l true ($modCore + "Grp.topNode");	
		
		//CORE NAME
		addAttr -ln "coreName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ("_" + $prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable 1 ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ("_" + $oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable 1 ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");
		}
		
		//NODE-SPECIFIC ATTRIBUTES
		$lookAts = `ls ("RRM_" + $prfx + $core + "_??")`;
	
		addAttr -ln "lookAts"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.lookAts") ;
		setAttr -type "string" ($modCore + "Grp.lookAts") `size $lookAts`;
		setAttr -l true ($modCore + "Grp.lookAts");
	
		//SCALE GROUP
		spaceLocator -n ($modCore + "_AveragePosition_Lctr");
		parentConstraint $lookAts ($modCore + "_AveragePosition_Lctr");

		group -em -n ($modCore + "_ScaleGrp");
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		delete ($modCore + "_AveragePosition_Lctr");
		
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + "_ScaleGrp.scale");
	
	
		//MASTER CONTROLLER
		circle -n ($modCore + "_MasterCtrl") -nr 1 0 0 -r 1 -d 1 -s 4 -ch 0;
		rotate -r 45 90 0 ($modCore + "_MasterCtrl");
		makeIdentity -apply true -r 1 ($modCore + "_MasterCtrl");
		group -n ($modCore + "_MasterCtrlGrp") ($modCore + "_MasterCtrl");
		parent ($modCore + "_MasterCtrlGrp") ($modCore + "_ScaleGrp");
	
		//SCALE MASTER CONTROLLER
		$lookAts = `ls ("RRM_" + $prfx + $core + "_??")`;
		
		if (`size $lookAts` == 1)
		{
			$lookAtSize = `getAttr "RRM_MAIN.scaleY"`;
			scale -a ($lookAtSize * 1) ($lookAtSize * 1) $lookAtSize ($modCore + "_MasterCtrlGrp");
			delete `parentConstraint $lookAts ($modCore + "_MasterCtrlGrp")`;
		}
		else
		{
			spaceLocator -n ($modCore + "_MasterCtrl_StartAttachLctr");
			spaceLocator -n ($modCore + "_MasterCtrl_EndAttachLctr");
			parent ($modCore + "_MasterCtrl_EndAttachLctr") ($modCore + "_MasterCtrl_StartAttachLctr");
			pointConstraint $lookAts[0] ($modCore + "_MasterCtrl_StartAttachLctr");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($modCore + "Grp")
			$lookAts ($modCore + "_MasterCtrl_StartAttachLctr");
			pointConstraint $lookAts ($modCore + "_MasterCtrl_EndAttachLctr");
			$lookAtSize = `getAttr ($modCore + "_MasterCtrl_EndAttachLctr.tx")`;
			scale -a ($lookAtSize * 2.5) ($lookAtSize * 1.25) $lookAtSize ($modCore + "_MasterCtrlGrp");
			
			//POSITION
			delete `parentConstraint $lookAts ($modCore + "_MasterCtrlGrp")`;
			delete ($modCore + "_MasterCtrl_StartAttachLctr") ($modCore + "_MasterCtrl_EndAttachLctr");
		}
	
		parentConstraint -mo ($modCore) ($modCore + "_MasterCtrlGrp");
		
		//PARENT ORIENT
		$parentOrient = ($modCore + "_MasterCtrl");
		RRM_ParentOrient_V1($modCore, $modName, $modAttachNode, $parentOrient); 
		
		
		//EYE CONTROLS
		$lookAts = `ls ("RRM_" + $prfx + $core + "_??")`;
		string $crntLookAt;
		$crntNum = 1;
		for ($crntLookAt in $lookAts)
		{
			string $nPd = "";
			if ($crntNum < 10)
			{
				$nPd = "0";
			}
			RRM_EyeControl_V1;
			rename "RRM_EyeControl_V1" ($modCore + "_" + $nPd + $crntNum + "Ctrl");
			rotate -r 90 90 0 ($modCore + "_" + $nPd + $crntNum + "Ctrl");
			makeIdentity -apply true -r 1 ($modCore + "_" + $nPd + $crntNum + "Ctrl");
			group -n ($modCore + "_" + $nPd + $crntNum + "Grp1") ($modCore + "_" + $nPd + $crntNum + "Ctrl");
			group -n ($modCore + "_" + $nPd + $crntNum + "Grp2") ($modCore + "_" + $nPd + $crntNum + "Grp1");
			parent ($modCore + "_" + $nPd + $crntNum + "Grp2") ($modCore + "_ScaleGrp");
			delete `pointConstraint $crntLookAt ($modCore + "_" + $nPd + $crntNum + "Grp2")`;
			
			//GET END LOCATION OF EYE CONTROL
			$lookAtUpLoc = `xform -q -ws -t ($crntLookAt + "EShape.cv[0]")`;
			$lookAtAimLoc = `xform -q -ws -t ($crntLookAt + "DShape.cv[1]")`;
			spaceLocator -n ($modCore + "_" + $nPd + $crntNum + "AimLctr");
			spaceLocator -n ($modCore + "_" + $nPd + $crntNum + "UpLctr");
			move -a $lookAtAimLoc[0] $lookAtAimLoc[1] $lookAtAimLoc[2] ($modCore + "_" + $nPd + $crntNum + "AimLctr");
			move -a $lookAtUpLoc[0] $lookAtUpLoc[1] $lookAtUpLoc[2] ($modCore + "_" + $nPd + $crntNum + "UpLctr");
			
			delete `aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($modCore + "_" + $nPd + $crntNum + "UpLctr")
			($modCore + "_" + $nPd + $crntNum + "AimLctr") ($modCore + "_" + $nPd + $crntNum + "Grp2")`;
			
			delete `pointConstraint ($modCore + "_" + $nPd + $crntNum + "AimLctr") ($modCore + "_" + $nPd + $crntNum + "Grp1")`;
			
			select -cl;
			joint -n ($modCore + "_" + $nPd + $crntNum + "Jnt");
			parent ($modCore + "_" + $nPd + $crntNum + "Jnt") ($modCore + "_ScaleGrp");		
			pointConstraint ($modCore + "_MasterCtrl") ($modCore + "_" + $nPd + $crntNum + "Jnt");
			aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ($modCore + "_" + $nPd + $crntNum + "Grp2")
			($modCore + "_" + $nPd + $crntNum + "Ctrl") ($modCore + "_" + $nPd + $crntNum + "Jnt");
	
			//AIM EYE CONTROL AT JOINT
			aimConstraint -offset 0 0 0 -aimVector -1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpObject ($modCore + "_" + $nPd + $crntNum + "Grp2")
			($modCore + "_" + $nPd + $crntNum + "Grp2") ($modCore + "_" + $nPd + $crntNum + "Ctrl");
			
			//SCALE EACH CONTROLLER
			if (`size $lookAts` == 1)
			{
				$lookAtSize = `getAttr "RRM_MAIN.scaleY"`;
				scale -a ($lookAtSize * .75) ($lookAtSize * .75) ($lookAtSize * .75) ($modCore + "_" + $nPd + $crntNum + "Ctrl");
			}
			else
			{
				spaceLocator -n ($modCore + "_" + $nPd + $crntNum + "StartLctr");
				spaceLocator -n ($modCore + "_" + $nPd + $crntNum + "EndLctr");
				parent ($modCore + "_" + $nPd + $crntNum + "EndLctr") ($modCore + "_" + $nPd + $crntNum + "StartLctr");
				pointConstraint $lookAts[0] ($modCore + "_" + $nPd + $crntNum + "StartLctr");
				aimConstraint -offset 0 0 0 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject ($modCore + "_" + $nPd + $crntNum + "UpLctr")
				$lookAts ($modCore + "_" + $nPd + $crntNum + "StartLctr");
				pointConstraint $lookAts ($modCore + "_" + $nPd + $crntNum + "EndLctr");
				$lookAtSize = `getAttr ($modCore + "_" + $nPd + $crntNum + "EndLctr.tx")`;
				scale -a ($lookAtSize * .75) ($lookAtSize * .75) ($lookAtSize * .75) ($modCore + "_" + $nPd + $crntNum + "Ctrl");
				delete ($modCore + "_" + $nPd + $crntNum + "StartLctr") ($modCore + "_" + $nPd + $crntNum + "EndLctr");
			}
			makeIdentity -apply true -t 1 -s 1 ($modCore + "_" + $nPd + $crntNum + "Ctrl");
			
			
			//CREATE CONNECTOR
			curve -n ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl") -d 1 -p 0 0 0 -p 0 0 -1 -k 0 -k 1 ;
			rename `listRelatives -c ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl")` ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrlShape");
			parent ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl") ($modCore + "Grp");
		
			select ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrlShape.cv[0]");
			newCluster " -envelope 1";
			rename ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster1");
			pointConstraint ($modCore + "_" + $nPd + $crntNum + "Ctrl") ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster1");
			
			select ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrlShape.cv[1]");
			newCluster " -envelope 1";
			rename ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster2");
			pointConstraint ($modCore + "_" + $nPd + $crntNum + "Grp2") ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster2");
	
			parent ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster1")	($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster2") ($modCore + "Grp");
			setAttr ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster1.visibility") 0;
			setAttr ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl_Cluster2.visibility") 0;
			
			toggle -state on -template ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl");
			
			delete ($modCore + "_" + $nPd + $crntNum + "AimLctr") ($modCore + "_" + $nPd + $crntNum + "UpLctr");
			
			addAttr -ln "nonControl"  -dt "string" ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl");
			setAttr -e-keyable 1 ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl.nonControl");
			setAttr -lock 1 ($modCore + "_" + $nPd + $crntNum + "ConnectorCtrl.nonControl");

			$crntNum++;
		}
	
		//ADD CORE NAME AND LOCK CHANNELS
		$modControls = `ls ($modCore + "_*Ctrl")`;
		for ($crntModControl in $modControls)
		{
			addAttr -ln "modCoreName"  -dt "string" $crntModControl;
			setAttr -e-keyable 1 ($crntModControl + ".modCoreName");
			setAttr -type "string" ($crntModControl + ".modCoreName") ("_" + $prfx + $core);
			setAttr -e-lock 1 ($crntModControl + ".modCoreName");
			
			//ADD MODULE TYPE
			addAttr -ln "moduleType"  -dt "string" ($crntModControl);
			setAttr -e -keyable 1 ($crntModControl + ".moduleType");
			setAttr -type "string" ($crntModControl + ".moduleType") "lookAt";
			setAttr -l true ($crntModControl + ".moduleType");

			setAttr -lock 1 -keyable 0 ($crntModControl + ".rx");
			setAttr -lock 1 -keyable 0 ($crntModControl + ".ry");
			setAttr -lock 1 -keyable 0 ($crntModControl + ".rz");
		}
		
		//SETUP FOR RIGHT SIDE
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$mirrorInt++;
		$multiplier = -1;
		$rotOffset = 180;
	}
	//ADD MASTER CONTROL FOR ALL EYES
	
	//CONTROL
	circle -n ($modName + "_" + $core + "_LookAtCtrl1") -nr 0 1 0 -sw 75 -r 1 -s 3 -ch 0;
	rotate -r -os 0 7.5 0 ($modName + "_" + $core + "_LookAtCtrl1");
	makeIdentity -apply  true -r 1 ($modName + "_" + $core + "_LookAtCtrl1");
	
	curve -n ($modName + "_" + $core + "_LookAtCtrl") -d 1 -p -0.130526 0 -0.991445 -p -0.130526 0 -0.130526 -p -0.991445 0 -0.130526 -k 0 -k 1 -k 2 ;
	rename `listRelatives -c ($modName + "_" + $core + "_LookAtCtrl")` ($modName + "_" + $core + "_LookAtCtrlShape");
	parent -r -s ($modName + "_" + $core + "_LookAtCtrl1Shape") ($modName + "_" + $core + "_LookAtCtrl");
	delete ($modName + "_" + $core + "_LookAtCtrl1");
	select ($modName + "_" + $core + "_LookAtCtrl");
	duplicate -rr; rotate -r 0 90 0; for ($i=1; $i<3; ++$i) duplicate -rr -st; select ($modName + "_" + $core + "_LookAtCtrl2") ($modName + "_" + $core + "_LookAtCtrl22") ($modName + "_" + $core + "_LookAtCtrl222");
	makeIdentity -apply true -r 1 ($modName + "_" + $core + "_LookAtCtrl2") ($modName + "_" + $core + "_LookAtCtrl22") ($modName + "_" + $core + "_LookAtCtrl222");
	select -hi ($modName + "_" + $core + "_LookAtCtrl2") ($modName + "_" + $core + "_LookAtCtrl22") ($modName + "_" + $core + "_LookAtCtrl222");
	select -d ($modName + "_" + $core + "_LookAtCtrl2") ($modName + "_" + $core + "_LookAtCtrl22") ($modName + "_" + $core + "_LookAtCtrl222");
	select -add ($modName + "_" + $core + "_LookAtCtrl");
	parent -r -s;
	delete ($modName + "_" + $core + "_LookAtCtrl2") ($modName + "_" + $core + "_LookAtCtrl22") ($modName + "_" + $core + "_LookAtCtrl222");
	group -n ($modName + "_" + $core + "_LookAtCtrlGrp") ($modName + "_" + $core + "_LookAtCtrl");
	parent ($modName + "_" + $core + "_LookAtCtrlGrp") ($modName + "_MAINCtrl");
	rotate -r 90 0 0 ($modName + "_" + $core + "_LookAtCtrlGrp") ;
	scale -r ($lookAtSize/.75) ($lookAtSize/.75) ($lookAtSize/.75) ($modName + "_" + $core + "_LookAtCtrlGrp");
	makeIdentity -apply true -r 1 -s 1 ($modName + "_" + $core + "_LookAtCtrlGrp") ;
	
	//MOVE INTO POSITION
	select ($modName + "*" + $core + "_??Ctrl");
	select -d ($modName + "_" + $core + "_LookAtCtrl");
	$eyeControls = `ls -sl`;
	$eyeControlsGrp = `listRelatives -p $eyeControls`;
	
	delete `pointConstraint $eyeControls ($modName + "_" + $core + "_LookAtCtrlGrp")`;
	makeIdentity -apply true -t 1 ($modName + "_" + $core + "_LookAtCtrlGrp");
	
	//AIM CONSTRAINT
	$eyeControlsGrp2 = `ls ($modName + "*" + $core + "_??Grp2")`;
	
	aimConstraint -offset 0 0 0 -aimVector 0 0 -1 -upVector 0 1 0 -worldUpType "none"
	$eyeControlsGrp2 ($modName + "_" + $core + "_LookAtCtrl");
	
	setAttr -lock 1 -keyable 0 ($modName + "_" + $core + "_LookAtCtrl.rx");
	setAttr -lock 1 -keyable 0 ($modName + "_" + $core + "_LookAtCtrl.ry");
	setAttr -lock 1 -keyable 0 ($modName + "_" + $core + "_LookAtCtrl.rz");
	setAttr -lock 1 -keyable 0 ($modName + "_" + $core + "_LookAtCtrl.v");	
	
	string $each;
	for ($each in $eyeControlsGrp)
	{
		parentConstraint -mo ($modName + "_" + $core + "_LookAtCtrl") $each;
	}
	
	//ADD ATTRIBUTE FOR PARENT ORIENT
	addAttr -ln "localSpace"  -at double  -min 0 -max 1 -dv 1 ($modName + "_" + $core + "_LookAtCtrl");
	setAttr -e-keyable 1 ($modName + "_" + $core + "_LookAtCtrl.localSpace");
	
	parentConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_MAINCtrl") ($modName + "_" + $core + "_LookAtCtrlGrp");
	connectAttr -f ($modName + "_" + $core + "_LookAtCtrl.localSpace") ($modName + "_" + $core + "_LookAtCtrlGrp_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW0");
	
	shadingNode -asUtility reverse -n ($modName + "_" + $core + "_LookAtCtrlGrp_Rev");
	connectAttr -f ($modName + "_" + $core + "_LookAtCtrl.localSpace") ($modName + "_" + $core + "_LookAtCtrlGrp_Rev.inputX");
	connectAttr -f ($modName + "_" + $core + "_LookAtCtrlGrp_Rev.outputX") ($modName + "_" + $core + "_LookAtCtrlGrp_parentConstraint1." + $modName + "_MAINCtrlW1");

	
	addAttr -ln "modCoreName"  -dt "string" ($modName + "_" + $core + "_LookAtCtrl");
	setAttr -e-keyable 1 ($modName + "_" + $core + "_LookAtCtrl.modCoreName");
	setAttr -type "string" ($modName + "_" + $core + "_LookAtCtrl.modCoreName") $modCore;
	setAttr -e-lock 1 ($modName + "_" + $core + "_LookAtCtrl.modCoreName");
	
	if (`objExists ("RRM_l_" + $modName + "_Parent")`)
		{select ("RRM_l_" + $modName + "_Parent");}
	if (`objExists ("RRM_r_" + $modName + "_Parent")`)
		{select -add ("RRM_r_" + $modName + "_Parent");}
	else if (`objExists ("RRM_" + $modName + "_Parent")`)
		{select ("RRM_" + $modName + "_Parent");}
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE AUXILIARY MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////

global proc RRM_GenerateRig_V1Auxiliary_V1(string $modName, string $moduleName, string $topNode)
{
	$core = `getAttr ($topNode + ".core")`;
	$mirrorInt = 1;
	string $modAttachNode;
	string $modCore;
	
	string $prfx = "";
	string $oppPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$prfx = "l_";
		$oppPrfx = "r_";
		$mirrorInt = 0;
	}
	$crntSide = "left";
	$oppSide = "right";
	
	while ($mirrorInt <= 1)
	{
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $prfx + $core + "_Aux.attachNode")`;
		
		$modCore = ($modName + "_" + $prfx + $core + "_Aux");
		$modOppCore = ($modName + "_" + $oppPrfx + $core + "_Aux");
		
	
		//MOD GROUP
		spaceLocator -n ($modCore + "_OffsetLctr");
		delete `orientConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_OffsetLctr")`;
		parentConstraint -mo ($modName + "_MAINCtrl") ($modCore + "_OffsetLctr");
		
		group -em -n ($modCore);
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore)`;
	
		if ($modAttachNode != "ROOT")
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore);
		}
		else
		{
			pointConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modName + "_ROOTLocLctr") ($modCore);
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_ROOTJnt") ($modCore);
		}
		setAttr ($modCore + "_orientConstraint1.interpType") 2;
		
		
		group -em -n ($modCore + "Grp");
		parent ($modCore + "Grp") ($modName + "_MAINCtrl");
		setAttr ($modCore + "Grp.inheritsTransform") 0;
		
		parent ($modCore + "_OffsetLctr") ($modCore + "Grp");
		setAttr ($modCore + "_OffsetLctr.visibility") 0;
		
		//ADD TOP GROUP NODE ATTRIBUTES
		//TOP NODE
		addAttr -ln "topNode"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.topNode");
		setAttr -type "string" ($modCore + "Grp.topNode") "auxiliary";
		setAttr -l true ($modCore + "Grp.topNode");	
		
		//CORE NAME
		addAttr -ln "coreName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.coreName") ;
		setAttr -type "string" ($modCore + "Grp.coreName") ("_" + $prfx + $core);
		setAttr -l true ($modCore + "Grp.coreName");
		
		//MODULE NAME
		addAttr -ln "moduleName"  -dt "string" ($modCore + "Grp");
		setAttr -e -keyable 1 ($modCore + "Grp.moduleName") ;
		setAttr -type "string" ($modCore + "Grp.moduleName") $moduleName;
		setAttr -l true ($modCore + "Grp.moduleName");
		
		//PAIRED
		if (`objExists ($topNode + ".pair")`)
		{
			addAttr -ln "pair"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable 1 ($modCore + "Grp.pair");
			setAttr -type "string" ($modCore + "Grp.pair") ("_" + $oppPrfx + $core);
			setAttr -l true ($modCore + "Grp.pair");
	
			addAttr -ln "side"  -dt "string" ($modCore + "Grp");
			setAttr -e -keyable 1 ($modCore + "Grp.side");
			setAttr -type "string" ($modCore + "Grp.side") $crntSide;
			setAttr -l true ($modCore + "Grp.side");
		}

		//SCALE GROUP
		group -em -n ($modCore + "_ScaleGrp");
		if ($modAttachNode != "ROOT")
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		else
		{
			delete `pointConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp")`;
			parentConstraint -mo -skipRotate x -skipRotate y -skipRotate z ($modName + "_" + $modAttachNode + "Jnt") ($modName + "_ROOTCtrl") ($modCore + "_ScaleGrp");
			orientConstraint ($modCore + "_OffsetLctr") ($modName + "_ROOTCtrl") ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "_ScaleGrp");
		}
		
		parent ($modCore) ($modCore + "_ScaleGrp");
		parent ($modCore + "_ScaleGrp") ($modCore + "Grp");
		connectAttr -f ($modName + "_MAINCtrl.scale") ($modCore + "_ScaleGrp.scale");

		//CONTROL
		//GET SCALE OF THE PROXY
		
		//LOCATOR FOR CONSTRAINTS
		spaceLocator -n ($modCore + "CtrlGrp2Lctr");
		parent ($modCore + "CtrlGrp2Lctr") ($modCore + "Grp");
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "CtrlGrp2Lctr")`;
		delete `scaleConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "CtrlGrp2Lctr")`;

		circle -n ($modCore + "Ctrl")  -nr 0 1 0 -r .375 -ch 0;
		circle -n ($modCore + "Ctrl2") -nr 1 0 0 -r .375 -ch 0;
		circle -n ($modCore + "Ctrl3") -nr 0 0 1 -r .375 -ch 0;
		parent -r -s ($modCore + "Ctrl2Shape") ($modCore + "Ctrl3Shape") ($modCore + "Ctrl");
		delete ($modCore + "Ctrl2") ($modCore + "Ctrl3");
		delete `scaleConstraint ("RRM_" + $prfx + $core + "_Aux") ($modCore + "Ctrl")`;
		makeIdentity -apply 1 ($modCore + "Ctrl");
		group -n ($modCore + "CtrlGrp") ($modCore + "Ctrl");
		group -n ($modCore + "CtrlGrp2") ($modCore + "CtrlGrp");
		parent ($modCore + "CtrlGrp2") ($modCore);
		
		setAttr ($modCore + "CtrlGrp2Lctr.v") 0;
		setAttr -lock 1 -keyable 0 ($modCore + "CtrlGrp2Lctr.v");
		setAttr -lock 1 -keyable 0 ($modCore + "Ctrl.v");

		
		delete `parentConstraint ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "CtrlGrp2")`;
		delete `parentConstraint ("RRM_" + $prfx + $core + "_Aux") ($modCore + "CtrlGrp")`;
		parentConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "CtrlGrp2Lctr") ($modCore + "CtrlGrp2");
		orientConstraint -mo ($modName + "_" + $modAttachNode + "Jnt") ($modCore + "CtrlGrp2Lctr") ($modCore + "CtrlGrp");
		
		addAttr -ln "followParentOrient"  -at double  -min 0 -max 1 -dv 1 ($modCore + "Ctrl");
		setAttr -e-keyable 1 ($modCore + "Ctrl.followParentOrient");
		addAttr -ln "followParentPosition"  -at double  -min 0 -max 1 -dv 1 ($modCore + "Ctrl");
		setAttr -e-keyable 1 ($modCore + "Ctrl.followParentPosition");
		connectAttr -f ($modCore + "Ctrl.followParentOrient") ($modCore + "CtrlGrp_orientConstraint1." + $modName + "_" + $modAttachNode + "JntW0");
		setAttr ($modCore + "Ctrl.followParentOrient") 0;
		setDrivenKeyframe -currentDriver ($modCore + "Ctrl.followParentOrient") ($modCore + "CtrlGrp_orientConstraint1." + $modCore + "CtrlGrp2LctrW1");
		setAttr ($modCore + "Ctrl.followParentOrient") 0;
		setAttr ($modCore + "Ctrl.followParentOrient") 1;
		setAttr ($modCore + "CtrlGrp_orientConstraint1." + $modCore + "CtrlGrp2LctrW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "Ctrl.followParentOrient") ($modCore + "CtrlGrp_orientConstraint1." + $modCore + "CtrlGrp2LctrW1");

		connectAttr -f ($modCore + "Ctrl.followParentPosition") ($modCore + "CtrlGrp2_parentConstraint1." + $modName + "_" + $modAttachNode + "JntW0");
		setAttr ($modCore + "Ctrl.followParentPosition") 0;
		setDrivenKeyframe -currentDriver ($modCore + "Ctrl.followParentPosition") ($modCore + "CtrlGrp2_parentConstraint1." + $modCore + "CtrlGrp2LctrW1");
		setAttr ($modCore + "Ctrl.followParentPosition") 0;
		setAttr ($modCore + "Ctrl.followParentPosition") 1;
		setAttr ($modCore + "CtrlGrp2_parentConstraint1." + $modCore + "CtrlGrp2LctrW1") 0;
		setDrivenKeyframe -currentDriver ($modCore + "Ctrl.followParentPosition") ($modCore + "CtrlGrp2_parentConstraint1." + $modCore + "CtrlGrp2LctrW1");

		//selectKey -k ($modCore + "CtrlGrp_orientConstraint1." + $modCore + "CtrlGrp2LctrW1") ($modCore + "CtrlGrp2_parentConstraint1." + $modCore + "CtrlGrp2LctrW1");
		keyTangent -itt spline -ott spline
		($modCore + "CtrlGrp_orientConstraint1_" + $modCore + "CtrlGrp2LctrW1")
		($modCore + "CtrlGrp2_parentConstraint1_" + $modCore + "CtrlGrp2LctrW1");
		

		//ADD MODULE CORE NAME
		addAttr -ln "modCoreName"  -dt "string" ($modCore + "Ctrl");
		setAttr -e-keyable 1 ($modCore + "Ctrl.modCoreName");
		setAttr -type "string" ($modCore + "Ctrl.modCoreName") ("_" + $prfx + $core);
		setAttr -e-lock 1 ($modCore + "Ctrl.modCoreName");
		
		//ADD MODULE TYPE
		addAttr -ln "moduleType"  -dt "string" (($modCore + "Ctrl"));
		setAttr -e -keyable 1 ($modCore + "Ctrl.moduleType");
		setAttr -type "string" ($modCore + "Ctrl.moduleType") "auxiliary";
		setAttr -l true ($modCore + "Ctrl.moduleType");
				
		//JOINT
		joint -n ($modCore + "Jnt");
		parent ($modCore + "Jnt") ($modCore + "_ScaleGrp");
		parentConstraint ($modCore + "Ctrl") ($modCore + "Jnt");
		//scaleConstraint ($modCore + "Ctrl")  ($modCore + "Jnt");
		connectAttr ($modCore + "Ctrl.scale")  ($modCore + "Jnt.scale");
		
		//SETUP FOR RIGHT SIDE
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$mirrorInt++;
		$multiplier = -1;
		$rotOffset = 180;
	}
	if (`objExists ("RRM_l_" + $modName + "_Aux")`)
		{select ("RRM_l_" + $modName + "_Aux");}
	if (`objExists ("RRM_r_" + $modName + "_Aux")`)
		{select -add ("RRM_r_" + $modName + "_Aux");}
	else if (`objExists ("RRM_" + $modName + "_Aux")`)
		{select ("RRM_" + $modName + "_Aux");}
}
	

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////TAB 2 FUNCTIONALITY///////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditLoadParent_V1(string $parent)
{
	$crnt = `ls -sl`;
	if (`size $crnt` == 1)
	{
		$each = $crnt[0];
		if (`objExists ($each + ".modName")`)
		{
			string $modName = `getAttr ($each + ".modName")`;
			string $modType = `getAttr ("RRM_" + $modName + ".top")`;
			if ($modType == $parent)
			{
				textFieldButtonGrp -e -text $modName ("RRM_EditLoad" + $parent + "TextField");
				select $crnt[0];
			}
			else
			{
				warning ("SELECTED PROXY NODE IS NOT A \"" + $parent + "\"");
			}
		}
		else
		{
			warning "PLEASE SELECT A VALID PROXY NODE TO LOAD";
		}
	}
	else if (`size $crnt` == 0)
	{
		warning "PLEASE SELECT A PROXY NODE TO LOAD";
	}
	else
	{
		warning "PLEASE SELECT ONLY ONE NODE. MIRRORED PARENTS WILL AUTOMATICALLY BE CONNECTED PROPERLY";
	}
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY SPLINE MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditSpline_V1()
{
	string $crntUnit = `currentUnit -query -linear`;


	//VERIFY VALID PARENT NODE
	$modName = `textFieldButtonGrp -q -text RRM_EditLoadsplineTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "INVALID MODULE NAME IN TEXT FIELD";
	}
		
	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;

	int $splineNum = `intSliderGrp -q -v RRM_SplineEditNum`;
	int $twistAxis = `radioButtonGrp -q -select RRM_SplineEditTwistAxis`;
	$twistAxis = ($twistAxis - 1);
	$mirrorMod = 0;
	$prfx = "";
	$oppPrfx = "";
	$i = 0;
	
	
	
	//CHECK FOR PAIRING
	if (`objExists ("RRM_" + $modName + ".pair")`)
	{
		$mirrorMod = 1;
		$prfx = "l_";
		$oppPrfx = "r_";

		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_l_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_l_" + $modName + "_Parent_AimLctr")
		("RRM_*_RRM_r_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_r_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;
		
		select -hi ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp");
		select -d ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;
		
		select $connectors ("RRM_?_" + $modName + "_??Grp");
	}
	else
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;

		select -hi ("RRM_" + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;
		
		select $connectors ("RRM_" + $modName + "_??Grp");
	}
	
	//GET TRANSFORMS OF PRE-MODIFY PROXIES
	float $tmpPos[];
	float $tmpRot[];
	vector $tmpPosVec;
	vector $tmpRotVec;
	
	vector $lPos[];
	vector $lRot[];
	vector $rPos[];
	vector $rRot[];
	int $proxCount = 1;
	for ($prox in `ls ("RRM_" + $prfx + $modName + "_??")`)
	{
		$tmpPos = `getAttr ($prox + ".translate")`;
		$tmpRot = `getAttr ($prox + ".rotate")`;
		$lPos[$proxCount] = <<$tmpPos[0], $tmpPos[1], $tmpPos[2]>>;
		$lRot[$proxCount] = <<$tmpRot[0], $tmpRot[1], $tmpRot[2]>>;
		$proxCount++;
	}
	
	$mirrorProxCount = 1;
	if ($mirrorMod == 1)
	{
		for ($prox in `ls ("RRM_" + $oppPrfx + $modName + "_??")`)
		{
			$tmpPos = `getAttr ($prox + ".translate")`;
			$tmpRot = `getAttr ($prox + ".rotate")`;
			$rPos[$mirrorProxCount] = <<$tmpPos[0], $tmpPos[1], $tmpPos[2]>>;
			$rRot[$mirrorProxCount] = <<$tmpRot[0], $tmpRot[1], $tmpRot[2]>>;
			$mirrorProxCount++;
		}
	}

	//DELETE OLD SPLINE NODES
	$splineJntGrp = `ls -sl`;
	select -hi $splineJntGrp;
	$allSplineJntGrp = `ls -sl`;
	lockNode -lock off $allSplineJntGrp;
	delete $splineJntGrp;
	
	//REBUILD SPLINE NODES
	while ($i <= $mirrorMod)
	{
		RRM_CreateProxySpline_V12_V1($modName, $mirrorMod, $prfx, $oppPrfx, $splineNum, $twistAxis, $crntUnit);
		
		
		//REAPPLY TRANSFORMS TO NEW PROXIES
		$proxCount2 = 1;
		$nPad = "_0";
		while ($proxCount2 <= $proxCount)
		{
			if ($proxCount2 == 10)
			{
				$nPad = "_";
			}
			if (`objExists ("RRM_" + $prfx + $modName + $nPad + $proxCount2)`)
			{
				$tmpPosVec = $lPos[$proxCount2];
				$tmpRotVec = $lRot[$proxCount2];
				if ($mirrorMod == 1 && $i == 1)
				{
					$tmpPosVec = $rPos[$proxCount2];
					$tmpRotVec = $rRot[$proxCount2];
				}
				
				setAttr (("RRM_" + $prfx + $modName + $nPad + $proxCount2 + ".translate"), $tmpPosVec.x, $tmpPosVec.y, $tmpPosVec.z);
				setAttr (("RRM_" + $prfx + $modName + $nPad + $proxCount2 + ".rotate"), $tmpRotVec.x, $tmpRotVec.y, $tmpRotVec.z); 
			}
			$proxCount2++;
		}
		
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$i++;
	}

	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -lock off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock on $lockNodes;

	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if (`size $crntSelection` > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				$finalSelect = `ls $finalSelect $each`;
			}
			$i2++;
		}
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY ARM MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditArm_V1()
{
	string $crntUnit = `currentUnit -query -linear`;


	//VERIFY VALID PARENT NODE
	string $modName = `textFieldButtonGrp -q -text RRM_EditLoadarmTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "INVALID MODULE NAME IN TEXT FIELD";
	}

	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;

	int $upperArmNum = `intSliderGrp -q -v upperArmModEditNum`;
	int $lowerArmNum = `intSliderGrp -q -v forearmModEditNum`;
	int $elbowNum = `intSliderGrp -q -v RRM_ElbowEditNum`;
	int $elbowJoints = `radioButtonGrp -q -select RRM_ElbowEditJoints`;
	int $toon = `checkBox -q -v RRM_ToonArmEditCheckBox`;
	int $mirrorMod = 1;
	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	//CHANGE ATTRIBUTES
	lockNode -lock 0 ("RRM_" + $modName);
	setAttr -l 0 ("RRM_" + $modName + ".upperArmNum");
	setAttr ("RRM_" + $modName + ".upperArmNum") $upperArmNum;
	setAttr -l 1 ("RRM_" + $modName + ".upperArmNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".lowerArmNum");
	setAttr ("RRM_" + $modName + ".lowerArmNum") $lowerArmNum;
	setAttr -l 1 ("RRM_" + $modName + ".lowerArmNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".elbowNum");
	setAttr ("RRM_" + $modName + ".elbowNum") $elbowNum;
	setAttr -l 1 ("RRM_" + $modName + ".elbowNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".elbowJoints");
	setAttr ("RRM_" + $modName + ".elbowJoints") $elbowJoints;
	setAttr -l 1 ("RRM_" + $modName + ".elbowJoints");
	
	setAttr -l 0 ("RRM_" + $modName + ".toonArms");
	setAttr ("RRM_" + $modName + ".toonArms") $toon;
	setAttr -l 1 ("RRM_" + $modName + ".toonArms");
	
	lockNode -lock 1 ("RRM_" + $modName);

	$i = 1;
	
	$attachMod = `ls -sl`;
	$attachModCore = `getAttr ($attachMod[0] + ".core")`;

	
	//CHECK FOR PAIRING
	if (`objExists ("RRM_" + $modName + ".pair")`)
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_l_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_l_" + $modName + "_Parent_AimLctr")
		("RRM_*_RRM_r_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_r_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;
		
		select -hi ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp");
		select -d ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		if (`objExists ("RRM_l_" + $modName + "_ElbowGrp")`)
		{
			select ("RRM_l_" + $modName + "_ElbowGrp") ("RRM_r_" + $modName + "_ElbowGrp")
			("RRM_l_" + $modName + "_AimLctr") ("RRM_r_" + $modName + "_AimLctr");
		}
		else
		{
			select ("RRM_l_" + $modName + "_Elbow1Grp") ("RRM_l_" + $modName + "_Elbow2Grp")
			("RRM_l_" + $modName + "_Elbow2AimLctr") ("RRM_l_" + $modName + "_AimLctr")
			("RRM_r_" + $modName + "_Elbow1Grp") ("RRM_r_" + $modName + "_Elbow2Grp")
			("RRM_r_" + $modName + "_Elbow2AimLctr") ("RRM_r_" + $modName + "_AimLctr");
		}
		//ROLL JOINTS
		if (`objExists ("RRM_l_" + $modName + "_Upper1")`)
		{
			select -add ("RRM_l_" + $modName + "_Upper*") ("RRM_r_" + $modName + "_Upper*");
		}
		if (`objExists ("RRM_l_" + $modName + "_Middle1")`)
		{
			select -add ("RRM_l_" + $modName + "_Middle*") ("RRM_r_" + $modName + "_Middle*");
		}
		if (`objExists ("RRM_l_" + $modName + "_Lower1")`)
		{
			select -add ("RRM_l_" + $modName + "_Lower*") ("RRM_r_" + $modName + "_Lower*");
		}
		select -add $connectors;		
		$mirrorMod = 2;
	}
	else
	{
		$prfx = "";
		$oppPrfx = "";

		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;

		select -hi ("RRM_" + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		if (`objExists ("RRM_" + $modName + "_ElbowGrp")`)
		{
			select ("RRM_" + $modName + "_ElbowGrp") ("RRM_" + $modName + "_AimLctr");
		}
		else
		{
			select ("RRM_" + $modName + "_Elbow1Grp") ("RRM_" + $modName + "_Elbow2Grp")
			("RRM_" + $modName + "_Elbow2AimLctr") ("RRM_" + $modName + "_AimLctr");
		}
		//ROLL JOINTS
		if (`objExists ("RRM_" + $modName + "_Upper1")`)
		{
			select -add ("RRM_" + $modName + "_Upper*");
		}
		if (`objExists ("RRM_" + $modName + "_Middle1")`)
		{
			select -add ("RRM_" + $modName + "_Middle*");
		}
		if (`objExists ("RRM_" + $modName + "_Lower1")`)
		{
			select -add ("RRM_" + $modName + "_Lower*");
		}
		select -add $connectors;
	}
	
	//GET TRANSFORMS OF PRE-MODIFY PROXIES
	//ELBOW
	float $lElbowPos[];
	float $rElbowPos[];
	
	float $lElbow1Pos[];
	float $lElbow2Pos[];
	
	float $rElbow1Pos[];
	float $rElbow2Pos[];
	
	print ("RRM_" + $prfx + $modName + "_Elbow");
	if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
	{
		$lElbowPos = `getAttr ("RRM_" + $prfx + $modName + "_Elbow.translate")`;
	}
	else
	{
		$lElbow1Pos = `getAttr ("RRM_" + $prfx + $modName + "_Elbow1.translate")`;
		$lElbow2Pos = `getAttr ("RRM_" + $prfx + $modName + "_Elbow2.translate")`;
	}
	if ($mirrorMod == 2)
	{
		if (`objExists ("RRM_" + $oppPrfx + $modName + "_Elbow")`)
		{
			$rElbowPos = `getAttr ("RRM_" + $oppPrfx + $modName + "_Elbow.translate")`;
		}
		else
		{
			$rElbow1Pos = `getAttr ("RRM_" + $oppPrfx + $modName + "_Elbow1.translate")`;
			$rElbow2Pos = `getAttr ("RRM_" + $oppPrfx + $modName + "_Elbow2.translate")`;
		}
	}
	

	//DELETE OLD ARM NODES
	$elbowNodes = `ls -sl`;
	select -hi $elbowNodes;
	$allElbowNodes = `ls -sl`;
	lockNode -lock off $allElbowNodes;
	delete $allElbowNodes;
	
	//REBUILD ARM NODES	
	while ($i <= $mirrorMod)
	{
		RRM_CreateProxyArm2_V1($modName, $upperArmNum, $lowerArmNum, $elbowNum, $elbowJoints, $toon, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit);
		
		//REAPPLY TRANSFORMS TO NEW PROXIES
		if ($i == 1)
		{
			if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
			{
				setAttr (("RRM_" + $prfx + $modName + "_Elbow.translate"), $lElbowPos[0], $lElbowPos[1], $lElbowPos[2]);
			}
			else
			{
				setAttr (("RRM_" + $prfx + $modName + "_Elbow1.translate"), $lElbow1Pos[0], $lElbow1Pos[1], $lElbow1Pos[2]);
				setAttr (("RRM_" + $prfx + $modName + "_Elbow2.translate"), $lElbow2Pos[0], $lElbow2Pos[1], $lElbow2Pos[2]);
			}
		}
		else if ($mirrorMod == 2 && $i == 2)
		{
			print "test\n";
			if (`objExists ("RRM_" + $prfx + $modName + "_Elbow")`)
			{
				print "test2\n";
				setAttr (("RRM_" + $prfx + $modName + "_Elbow.translate"), $rElbowPos[0], $rElbowPos[1], $rElbowPos[2]);
			}
			else
			{
				setAttr (("RRM_" + $prfx + $modName + "_Elbow1.translate"), $rElbow1Pos[0], $rElbow1Pos[1], $rElbow1Pos[2]);
				setAttr (("RRM_" + $prfx + $modName + "_Elbow2.translate"), $rElbow2Pos[0], $rElbow2Pos[1], $rElbow2Pos[2]);
			}		
		}
		

		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
		$i++;
	}
	
	
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -lock off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock on $lockNodes;
	
	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if (`size $crntSelection` > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				$finalSelect = `ls $finalSelect $each`;
			}
			$i2++;
		}
	}
	else
	{
		select -cl;
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY LEG MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditLeg_V1()
{
	string $crntUnit = `currentUnit -query -linear`;


	//VERIFY VALID PARENT NODE
	string $modName = `textFieldButtonGrp -q -text RRM_EditLoadlegTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "INVALID MODULE NAME IN TEXT FIELD";
	}

	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;

	int $upperLegNum = `intSliderGrp -q -v upperLegModEditNum`;
	int $lowerLegNum = `intSliderGrp -q -v lowerLegModEditNum`;
	int $kneeNum = `intSliderGrp -q -v RRM_KneeEditNum`;
	int $kneeJoints = `radioButtonGrp -q -select RRM_KneeEditJoints`;
	int $toon = `checkBox -q -v RRM_ToonLegEditCheckBox`;
	int $mirrorMod = 1;
	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$posOffset = 2;
	
	$i = 1;
	
	//CHANGE ATTRIBUTES
	lockNode -lock 0 ("RRM_" + $modName);
	setAttr -l 0 ("RRM_" + $modName + ".upperLegNum");
	setAttr ("RRM_" + $modName + ".upperLegNum") $upperLegNum;
	setAttr -l 1 ("RRM_" + $modName + ".upperLegNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".lowerLegNum");
	setAttr ("RRM_" + $modName + ".lowerLegNum") $lowerLegNum;
	setAttr -l 1 ("RRM_" + $modName + ".lowerLegNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".kneeNum");
	setAttr ("RRM_" + $modName + ".kneeNum") $kneeNum;
	setAttr -l 1 ("RRM_" + $modName + ".kneeNum");
	
	setAttr -l 0 ("RRM_" + $modName + ".kneeJoints");
	setAttr ("RRM_" + $modName + ".kneeJoints") $kneeJoints;
	setAttr -l 1 ("RRM_" + $modName + ".kneeJoints");
	lockNode -lock 1 ("RRM_" + $modName);
	
	//CHECK FOR PAIRING
	if (`objExists ("RRM_" + $modName + ".pair")`)
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_l_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_l_" + $modName + "_Parent_AimLctr")
		("RRM_*_RRM_r_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_r_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;
		
		select -hi ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp");
		select -d ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		if (`objExists ("RRM_l_" + $modName + "_KneeGrp")`)
		{
			select ("RRM_l_" + $modName + "_KneeGrp") ("RRM_r_" + $modName + "_KneeGrp")
			("RRM_l_" + $modName + "_AimLctr") ("RRM_r_" + $modName + "_AimLctr");
		}
		else
		{
			select ("RRM_l_" + $modName + "_Knee1Grp") ("RRM_l_" + $modName + "_Knee2Grp")
			("RRM_l_" + $modName + "_Knee2AimLctr") ("RRM_l_" + $modName + "_AimLctr")
			("RRM_r_" + $modName + "_Knee1Grp") ("RRM_r_" + $modName + "_Knee2Grp")
			("RRM_r_" + $modName + "_Knee2AimLctr") ("RRM_r_" + $modName + "_AimLctr");
		}
		//ROLL JOINTS
		if (`objExists ("RRM_l_" + $modName + "_Upper1")`)
		{
			select -add ("RRM_l_" + $modName + "_Upper*") ("RRM_r_" + $modName + "_Upper*");
		}
		if (`objExists ("RRM_l_" + $modName + "_Middle1")`)
		{
			select -add ("RRM_l_" + $modName + "_Middle*") ("RRM_r_" + $modName + "_Middle*");
		}
		if (`objExists ("RRM_l_" + $modName + "_Lower1")`)
		{
			select -add ("RRM_l_" + $modName + "_Lower*") ("RRM_r_" + $modName + "_Lower*");
		}
		select -add $connectors;
		$mirrorMod = 2;
	}
	else
	{
		$prfx = "";
		$oppPrfx = "";

		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;

		select -hi ("RRM_" + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		if (`objExists ("RRM_" + $modName + "_KneeGrp")`)
		{
			select ("RRM_" + $modName + "_KneeGrp") ("RRM_" + $modName + "_AimLctr");
		}
		else
		{
			select ("RRM_" + $modName + "_Knee1Grp") ("RRM_" + $modName + "_Knee2Grp")
			("RRM_" + $modName + "_Knee2AimLctr") ("RRM_" + $modName + "_AimLctr");
		}
		//ROLL JOINTS
		if (`objExists ("RRM_" + $modName + "_Upper1")`)
		{
			select -add ("RRM_" + $modName + "_Upper*");
		}
		if (`objExists ("RRM_" + $modName + "_Middle1")`)
		{
			select -add ("RRM_" + $modName + "_Middle*");
		}
		if (`objExists ("RRM_" + $modName + "_Lower1")`)
		{
			select -add ("RRM_" + $modName + "_Lower*");
		}
		select -add $connectors;
	}
	//GET TRANSFORMS OF PRE-MODIFY PROXIES
	//KNEE
	float $lKneePos[];
	float $rKneePos[];
	
	float $lKnee1Pos[];
	float $lKnee2Pos[];
	
	float $rKnee1Pos[];
	float $rKnee2Pos[];
	
	print ("RRM_" + $prfx + $modName + "_Knee");
	if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
	{
		$lKneePos = `getAttr ("RRM_" + $prfx + $modName + "_Knee.translate")`;
	}
	else
	{
		$lKnee1Pos = `getAttr ("RRM_" + $prfx + $modName + "_Knee1.translate")`;
		$lKnee2Pos = `getAttr ("RRM_" + $prfx + $modName + "_Knee2.translate")`;
	}
	if ($mirrorMod == 2)
	{
		if (`objExists ("RRM_" + $oppPrfx + $modName + "_Knee")`)
		{
			$rKneePos = `getAttr ("RRM_" + $oppPrfx + $modName + "_Knee.translate")`;
		}
		else
		{
			$rKnee1Pos = `getAttr ("RRM_" + $oppPrfx + $modName + "_Knee1.translate")`;
			$rKnee2Pos = `getAttr ("RRM_" + $oppPrfx + $modName + "_Knee2.translate")`;
		}
	}

	//DELETE OLD LEG NODES
	$kneeNodes = `ls -sl`;
	select -hi $kneeNodes;
	$allKneeNodes = `ls -sl`;
	lockNode -lock off $allKneeNodes;
	delete $kneeNodes;
		
	//REBUILD LEG NODES	
	while ($i <= $mirrorMod)
	{
		RRM_CreateProxyLeg_V12_V1($modName, $upperLegNum, $lowerLegNum, $kneeNum, $kneeJoints, $toon, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $posOffset, $crntUnit);
		
		//REAPPLY TRANSFORMS TO NEW PROXIES
		if ($i == 1)
		{
			if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
			{
				setAttr (("RRM_" + $prfx + $modName + "_Knee.translate"), $lKneePos[0], $lKneePos[1], $lKneePos[2]);
			}
			else
			{
				setAttr (("RRM_" + $prfx + $modName + "_Knee1.translate"), $lKnee1Pos[0], $lKnee1Pos[1], $lKnee1Pos[2]);
				setAttr (("RRM_" + $prfx + $modName + "_Knee2.translate"), $lKnee2Pos[0], $lKnee2Pos[1], $lKnee2Pos[2]);
			}
		}
		else if ($mirrorMod == 2 && $i == 2)
		{
			print "test\n";
			if (`objExists ("RRM_" + $prfx + $modName + "_Knee")`)
			{
				print "test2\n";
				setAttr (("RRM_" + $prfx + $modName + "_Knee.translate"), $rKneePos[0], $rKneePos[1], $rKneePos[2]);
			}
			else
			{
				setAttr (("RRM_" + $prfx + $modName + "_Knee1.translate"), $rKnee1Pos[0], $rKnee1Pos[1], $rKnee1Pos[2]);
				setAttr (("RRM_" + $prfx + $modName + "_Knee2.translate"), $rKnee2Pos[0], $rKnee2Pos[1], $rKnee2Pos[2]);
			}		
		}


		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$posOffset = -2;
		$i++;
	}
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -lock off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -lock off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock on $lockNodes;
	
	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if (`size $crntSelection` > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				select $finalSelect $each;
				$finalSelect = `ls -sl`;
			}
			$i2++;
		}
	}
	else
	{
		select -cl;
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY FK CHAIN MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditFkChain_V1()
{
	string $crntUnit = `currentUnit -query -linear`;


	//VERIFY VALID PARENT NODE
	string $modName = `textFieldButtonGrp -q -text RRM_EditLoadfkChainTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "INVALID MODULE NAME IN TEXT FIELD";
	}

	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;

	int $chainsNum = `intSliderGrp -q -v fkChainModEditChains`;
	int $jointsNum = `intSliderGrp -q -v fkChainModEditJointsPerChain`;
	int $direction = `getAttr ("RRM_" + $modName + ".direction")`;
	int $mirrorMod = 0;
	int $enableIK = `checkBox -q -v fkChainModEditIK`;
	
	
	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$rotOffset = 0;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	$i=0;
	int $create = 0;

	
	//CHECK FOR PAIRING
	if (`objExists ("RRM_" + $modName + ".pair")`)
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_l_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_l_" + $modName + "_Parent_AimLctr")
		("RRM_*_RRM_r_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_r_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;
		
		select -hi ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp");
		select -d ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		select `listRelatives -ad ("RRM_l_" + $modName + "_Grp") ("RRM_r_" + $modName + "_Grp")` $connectors;
		$mirrorMod = 1;
	}
	else
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;

		select -hi ("RRM_" + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		$prfx = "";
		$oppPrfx = "";
		select `listRelatives -ad ("RRM_" + $modName + "_Grp")` $connectors;
	}
	//GET TRANSFORMS OF PRE-MODIFY PROXIES
	string $fkProx[];
	float $tmpPos[];
	float $tmpRot[];
	float $tmpScl[];
	vector $tmpPosVec;
	vector $tmpRotVec;
	vector $tmpSclVec;
	
	vector $pos[];
	vector $rot[];
	vector $scl[];
	int $proxCount = 0;
	for ($prox in `ls ("RRM_" + $prfx + $modName + "_??_??")`)
	{
		$fkProx[$proxCount] = $prox;
		$tmpPos = `getAttr ($prox + ".translate")`;
		$tmpRot = `getAttr ($prox + ".rotate")`;
		$tmpScl = `getAttr ($prox + ".scale")`;
		$pos[$proxCount] = <<$tmpPos[0], $tmpPos[1], $tmpPos[2]>>;
		$rot[$proxCount] = <<$tmpRot[0], $tmpRot[1], $tmpRot[2]>>;
		$scl[$proxCount] = <<$tmpScl[0], $tmpScl[1], $tmpScl[2]>>;
		
		$proxCount++;
	}
	
	if ($mirrorMod == 1)
	{
		for ($prox in `ls ("RRM_" + $oppPrfx + $modName + "_??_??")`)
		{
			$fkProx[$proxCount] = $prox;
			$tmpPos = `getAttr ($prox + ".translate")`;
			$tmpRot = `getAttr ($prox + ".rotate")`;
			$tmpScl = `getAttr ($prox + ".scale")`;
			$pos[$proxCount] = <<$tmpPos[0], $tmpPos[1], $tmpPos[2]>>;
			$rot[$proxCount] = <<$tmpRot[0], $tmpRot[1], $tmpRot[2]>>;
			$scl[$proxCount] = <<$tmpScl[0], $tmpScl[1], $tmpScl[2]>>;
			$proxCount++;
		}
	}
	
	
	//DELETE OLD FK NODES
	$fkNodes = `ls -sl`;
	select -hi $fkNodes;
	$allFkNodes = `ls -sl`;
	lockNode -lock off $allFkNodes;
	delete $allFkNodes;
	
	//UNLOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock off $lockNodes;

	//REBUILD FK NODES
	while ($i <= $mirrorMod)
	{
		RRM_CreateProxyFKChain_V12_V1($modName, $chainsNum, $jointsNum, $direction, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $enableIK, $crntUnit, $create);
		
		$i++;
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}
	
	//REAPPLY TRANSFORMS TO NEW PROXIES
	$proxCount2 = 0;
	for ($prox in $fkProx)
	{
		if (`objExists $prox`)
		{
			print "exists\n";
			$tmpPosVec = $pos[$proxCount2];
			$tmpRotVec = $rot[$proxCount2];
			$tmpSclVec = $scl[$proxCount2];
			
			setAttr (($prox + ".translate"), $tmpPosVec.x, $tmpPosVec.y, $tmpPosVec.z);
			setAttr (($prox + ".rotate"), $tmpRotVec.x, $tmpRotVec.y, $tmpRotVec.z);
			setAttr (($prox + ".scale"), $tmpSclVec.x, $tmpSclVec.y, $tmpSclVec.z);
		}
		$proxCount2++;
	}
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -lock off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock on $lockNodes;
	
	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if (`size $crntSelection` > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				$finalSelect = `ls $finalSelect $each`;
			}
			$i2++;
		}
	}
	else
	{
		select -cl;
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY HEAD MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditHead_V1()
{
	string $crntUnit = `currentUnit -query -linear`;

	//VERIFY VALID PARENT NODE
	string $modName = `textFieldButtonGrp -q -text RRM_EditLoadheadTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "INVALID MODULE NAME IN TEXT FIELD";
	}

	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;

	int $mirrorMod = 1;
	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	int $i;
	
	//CHECK FOR PAIRING
	if (!`objExists ("RRM_" + $modName + ".pair")`)
	{
		$prfx = "";
		$oppPrfx = "";
		$mirrorMod = 0;
	}
	while ($i <= $mirrorMod)
	{
		if (`objExists ("RRM_" + $prfx + $modName + "_Jaw")`)
		{
			//SET JAW ON IN PARENT NODE
			lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");
		
			setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.jaw");
			setAttr ("RRM_" + $prfx + $modName + "_Parent.jaw") 0;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.jaw");
			lockNode -lock on ("RRM_" + $prfx + $modName + "_Parent");
		
			lockNode -lock off ("RRM_" + $modName);
			setAttr -l false ("RRM_" + $modName + ".jaw");
			setAttr ("RRM_" + $modName + ".jaw") 0;
			setAttr -l true ("RRM_" + $modName + ".jaw");
			lockNode -lock on ("RRM_" + $modName);
		

			select -hi ("RRM_*_RRM_" + $prfx + $modName + "_JawCtrl")  ("RRM_*_RRM_" + $prfx + $modName + "_Jaw_AimLctr")
			("RRM_*_RRM_" + $prfx + $modName + "_JawEndCtrl")  ("RRM_*_RRM_" + $prfx + $modName + "_JawEnd_AimLctr");
			$connectors = `ls -sl`;
			
			select -hi ("RRM_" + $prfx + $modName + "_Jaw");
			select -add $connectors;
			$jawHierarchy = `ls -sl`;
			lockNode -lock off $jawHierarchy;
			delete $jawHierarchy;
		}
		else
		{
			//SET JAW ON IN PARENT NODE
			lockNode -lock off ("RRM_" + $prfx + $modName + "_Parent");
		
			setAttr -l false ("RRM_" + $prfx + $modName + "_Parent.jaw");
			setAttr ("RRM_" + $prfx + $modName + "_Parent.jaw") 1;
			setAttr -l true ("RRM_" + $prfx + $modName + "_Parent.jaw");
			lockNode -lock on ("RRM_" + $prfx + $modName + "_Parent");

			lockNode -lock off ("RRM_" + $modName);
			setAttr -l false ("RRM_" + $modName + ".jaw");
			setAttr ("RRM_" + $modName + ".jaw") 1;
			setAttr -l true ("RRM_" + $modName + ".jaw");
			lockNode -lock on ("RRM_" + $modName);

			RRM_CreateProxyModuleProxy_V1($crntUnit);
			rename RRM_Base	 ("RRM_" + $prfx + $modName + "_Jaw");
			delete `parentConstraint ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Jaw")`;
			parent ("RRM_" + $prfx + $modName + "_Jaw") ("RRM_" + $prfx + $modName + "_Parent");
			makeIdentity -apply false -s 1 ("RRM_" + $prfx + $modName + "_Jaw");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Jaw");
			delete `pointConstraint ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_Top") ("RRM_" + $prfx + $modName + "_Jaw")`;
			$jawLoc = `getAttr  ("RRM_" + $prfx + $modName + "_Jaw.ty")`;
			move -r -ls 0 0 ($jawLoc/6) ("RRM_" + $prfx + $modName + "_Jaw");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_Jaw");
			
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_Jaw.core") ($prfx + $modName + "_Jaw");
			setAttr -l true ("RRM_" + $prfx + $modName + "_Jaw.core");
		
			RRM_CreateProxyEndProxy_V1($crntUnit);
			rename RRM_End ("RRM_" + $prfx + $modName + "_JawEnd");
			rotate -r 90 0 0 ("RRM_" + $prfx + $modName + "_JawEnd");
			makeIdentity -apply true -r 1 ("RRM_" + $prfx + $modName + "_JawEnd");
			delete `parentConstraint ("RRM_" + $prfx + $modName + "_Parent") ("RRM_" + $prfx + $modName + "_JawEnd")`;
			parent  ("RRM_" + $prfx + $modName + "_JawEnd")  ("RRM_" + $prfx + $modName + "_Jaw");
			makeIdentity -apply false -s 1  ("RRM_" + $prfx + $modName + "_JawEnd");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_JawEnd");
			move -r -ls 0 (($jawLoc/3)*2) $jawLoc ("RRM_" + $prfx + $modName + "_JawEnd");
			makeIdentity -apply true -t 1 -r 1 -s 1 ("RRM_" + $prfx + $modName + "_JawEnd");
			
			setAttr -type "string" ("RRM_" + $prfx + $modName + "_JawEnd.core") ($prfx + $modName + "_JawEnd");
			setAttr -l true ("RRM_" + $prfx + $modName + "_JawEnd.core");
        
			lockNode -lock on ("RRM_" + $prfx + $modName + "_Jaw") ("RRM_" + $prfx + $modName + "_JawEnd");
			
			//CONNECTORS
			RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Parent"), ("RRM_" + $prfx + $modName + "_Jaw"));
			RRM_ProxyConnectors_V1($modName, $prfx, ("RRM_" + $prfx + $modName + "_Jaw"), ("RRM_" + $prfx + $modName + "_JawEnd"));
		}
		$i++;
		$prfx = "r_";
		$oppPrfx = "l_";
	}
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -lock off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock on $lockNodes;
	
	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if (`size $crntSelection` > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				$finalSelect = `ls $finalSelect $each`;
			}
			$i2++;
		}
	}
	else
	{
		select -cl;
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////MODIFY LOOK AT MODULE/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_EditLookAt_V1()
{
	string $crntUnit = `currentUnit -query -linear`;

	//VERIFY VALID PARENT NODE
	string $modName = `textFieldButtonGrp -q -text RRM_EditLoadlookAtTextField`;
	if (!`objExists ("RRM_" + $modName + ".top")`)
	{
		error "INVALID MODULE NAME IN TEXT FIELD";
	}

	//GET INFO ON SELECTION
	$crntSelection = `ls -sl`;

	int $jointsNum = `intSliderGrp -q -v lookAtModEditJoints`;
	int $mirrorMod = 0;

	string $prfx = "l_";
	string $oppPrfx = "r_";
	$posOffset = 2;
	$crntSide = "left";
	$oppSide = "right";
	$multiplier = 1;
	
	$i = 0;
	
	//CHECK FOR PAIRING
	if (`objExists ("RRM_" + $modName + ".pair")`)
	{
		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_l_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_l_" + $modName + "_Parent_AimLctr")
		("RRM_*_RRM_r_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_r_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;
		
		select -hi ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp");
		select -d ("RRM_l_" + $modName + "_ConnectorGrp") ("RRM_r_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		select ("RRM_l_" + $modName + "_Grp") ("RRM_r_" + $modName + "_Grp") $connectors;
		$mirrorMod = 1;
	}
	else
	{
		$prfx = "";
		$oppPrfx = "";

		//SELECT CONNECTORS
		select -hi ("RRM_*_RRM_" + $modName + "_ParentCtrl")  ("RRM_*_RRM_" + $modName + "_Parent_AimLctr");
		$parentConnectorNodes = `ls -sl`;

		select -hi ("RRM_" + $modName + "_ConnectorGrp");
		select -d ("RRM_" + $modName + "_ConnectorGrp") $parentConnectorNodes;
		$connectors = `ls -sl -type "transform"`;

		select ("RRM_" + $modName + "_Grp") $connectors;
	}

	//DELETE OLD LOOK AT NODES
	$fkNodes = `ls -sl`;
	select -hi $fkNodes;
	$allFkNodes = `ls -sl`;
	lockNode -lock off $allFkNodes;
	delete $allFkNodes;
	
	//UNLOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock off $lockNodes;
	
	//REBUILD LOOK AT NODES	
	while ($i <= $mirrorMod)
	{
		RRM_CreateProxyLookAt_V12_V1($modName, $jointsNum, $mirrorMod, $prfx, $oppPrfx, $crntSide, $oppSide, $multiplier, $crntUnit);
		
		$i++;
		$prfx = "r_";
		$oppPrfx = "l_";
		$crntSide = "right";
		$oppSide = "left";
		$multiplier = -1;
	}
	
	//ADD MOD NAME ATTRIBUTE
	select -hi ("RRM_" + $modName);
	$nodes = `ls -sl -type "transform"`;
	string $each;
	for ($each in $nodes)
	{
		if (`objExists ($each + ".modName")`)
		{
			//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
			$modNameCheck = `getAttr ($each + ".modName")`;
			if ($modNameCheck == "")
			{
				lockNode -lock off $each;
				setAttr -l false ($each + ".modName");
				setAttr -type "string" ($each + ".modName") $modName;
				setAttr -l true ($each + ".modName");
			}
		}
	}

	//LOCK NODES
	select -hi ("RRM_" + $modName);
	$lockNodes = `ls -sl`;
	lockNode -lock on $lockNodes;
	
	//LOAD PRE-SELECTION
	int $i2 = 0;
	string $finalSelect[];
	if (`size $crntSelection` > 0)
	{
		for ($each in $crntSelection)
		{
			if (`objExists $crntSelection[$i2]`)
			{
				//MAKE SURE MOD NAME DOES NOT STOMP OVER EXISTING MOD NAMES
				$modNameCheck = `getAttr ($each + ".modName")`;
				if ($modNameCheck == "")
				{
					lockNode -lock off $each;
					setAttr -l false ($each + ".modName");
					setAttr -type "string" ($each + ".modName") $modName;
					setAttr -l true ($each + ".modName");
				}
			}
			$i2++;
		}
	}
	else
	{
		select -cl;
	}
	select $finalSelect;
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//	changeLinearUnit $crntUnit;
}

//////////////////////////////////////SINGLE HIERARCHY////////////////////////////////


////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE ROOT SH MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRig_V1Root_V1SH_V1(string $modName)
{
	//CREATE LAYERS
	//LAYER
	createDisplayLayer -n ($modName + "_SHJointsLayer") -number 1 -empty;
	select -cl;	
	joint -n ($modName + "_ROOTSHJnt");
	delete `parentConstraint ($modName + "_ROOTJnt") ($modName + "_ROOTSHJnt")`;
	makeIdentity -apply 1 -r 1 ($modName + "_ROOTSHJnt");
	parentConstraint ($modName + "_ROOTJnt") ($modName + "_ROOTSHJnt");
	group -n ($modName + "_SHJntGrp") ($modName + "_ROOTSHJnt"); xform -os -piv 0 0 0;
	parent ($modName + "_SHJntGrp") $modName;
	connectAttr -f ($modName + "_MAINCtrl.scaleY") ($modName + "_SHJntGrp.scaleX");
	connectAttr -f ($modName + "_MAINCtrl.scaleY") ($modName + "_SHJntGrp.scaleY");
	connectAttr -f ($modName + "_MAINCtrl.scaleY") ($modName + "_SHJntGrp.scaleZ");
	
	editDisplayLayerMembers -noRecurse ($modName + "_SHJointsLayer") `ls ($modName + "_SHJntGrp")`;
}


////////////////////////////////////////////////////////////////////////////////
///////////////////////GENERATE ROOT AND MAIN SH MODULE/////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRig_V1Root_V1MainSH_V1(string $modName)
{
	//CREATE LAYERS
	//LAYER
	createDisplayLayer -n ($modName + "_SHJointsLayer") -number 1 -empty;

	select -cl;	
	joint -n ($modName + "_MAINSHJnt");
	delete `parentConstraint ($modName + "_MAINCtrl") ($modName + "_MAINSHJnt")`;
	makeIdentity -apply 1 -r 1 ($modName + "_MAINSHJnt");
	parentConstraint ($modName + "_MAINCtrl") ($modName + "_MAINSHJnt");
	group -n ($modName + "_SHJntGrp") ($modName + "_MAINSHJnt"); xform -os -piv 0 0 0;
	parent ($modName + "_SHJntGrp") $modName;
	select -cl;	
	joint -n ($modName + "_ROOTSHJnt");
	addAttr -ln "hips"  -at bool ($modName + "_ROOTSHJnt");
	setAttr -e-keyable 1 ($modName + "_ROOTSHJnt.hips");

	delete `parentConstraint ($modName + "_ROOTJnt") ($modName + "_ROOTSHJnt")`;
	makeIdentity -apply 1 -r 1 ($modName + "_ROOTSHJnt");
	parentConstraint ($modName + "_ROOTJnt") ($modName + "_ROOTSHJnt");
	parent ($modName + "_ROOTSHJnt") ($modName + "_MAINSHJnt");
	//$JointOrient = `getAttr  ($modName + "_ROOTJnt.jointOrient")`;
	//setAttr (($modName + "_ROOTSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	
	editDisplayLayerMembers -noRecurse ($modName + "_SHJointsLayer") `ls ($modName + "_SHJntGrp")`;
}


////////////////////////////////////////////////////////////////////////////////
//////////////////////////GENERATE SPLINE SH MODULE/////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRig_V1Spline_V1SH_V1(string $modName, string $topNode)
{
	//GET MOD TYPE
	$modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}
	
	//GET ATTACH NODE
	$modAttachNode = `getAttr ("RRM_" + $lPrfx + $core + "_Parent.attachNode")`;
	
	$mod_lCore = ($modName + "_" + $lPrfx + $core);
	$mod_rCore = ($modName + "_" + $rPrfx + $core);

	//GENERATE JOINTS
	$splineProxies = `ls ("RRM_" + $lPrfx + $core + "_??")`;
	int $crntNum = 0;
	$numPadding = "_0";
	$prevPadding = "_0";
	float $splineLoc[];
	for ($crntProxy in $splineProxies)
	{
		$crntNum++;
		if ($crntNum >= 10)
		{$numPadding = "_";}
			
		select -cl;
		joint -n ($mod_lCore + $numPadding + $crntNum + "SHJnt");
		delete `parentConstraint ($mod_lCore + $numPadding + $crntNum + "Jnt") ($mod_lCore + $numPadding + $crntNum + "SHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_lCore + $numPadding + $crntNum + "SHJnt");
		parentConstraint ($mod_lCore + $numPadding + $crntNum + "Jnt") ($mod_lCore + $numPadding + $crntNum + "SHJnt");

		if ($crntNum == 1)
		{
			parent ($mod_lCore + $numPadding + $crntNum + "SHJnt") ($modName + "_" + $modAttachNode + "SHJnt");
			addAttr -ln "splineStart"  -at bool ($mod_lCore + $numPadding + $crntNum + "SHJnt");
			setAttr -e-keyable 1 ($mod_lCore + $numPadding + $crntNum + "SHJnt.splineStart");
		}
		else
		{
			int $previousNum = ($crntNum - 1);
			if ($previousNum >=10)
			{$prevPadding = "_";}
			parent ($mod_lCore + $numPadding + $crntNum + "SHJnt")  ($mod_lCore + $prevPadding + $previousNum + "SHJnt");
		}
		//$JointOrient = `getAttr  ($mod_lCore + $numPadding + $crntNum + "Jnt.jointOrient")`;
		//setAttr (($mod_lCore + $numPadding + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	}
	
	select -cl;
	joint -n ($mod_lCore + "_TopSHJnt");
	addAttr -ln "splineEnd"  -at bool ($mod_lCore + "_TopSHJnt");
	setAttr -e-keyable 1 ($mod_lCore + "_TopSHJnt.splineEnd");

	delete `parentConstraint ($mod_lCore + "_TopJnt") ($mod_lCore + "_TopSHJnt")`;
	makeIdentity -apply 1 -r 1 	($mod_lCore + "_TopSHJnt");
	parentConstraint ($mod_lCore + "_TopJnt") ($mod_lCore + "_TopSHJnt");
	parent ($mod_lCore + "_TopSHJnt") ($mod_lCore + $numPadding + $crntNum + "SHJnt");
	//$JointOrient = `getAttr  ($mod_lCore + "_TopJnt.jointOrient")`;
	//setAttr (($mod_lCore + "_TopSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	
	if (`objExists ("RRM_" + $lPrfx + $core + "_Hip")`)
	{
		select -cl;
		joint -n ($mod_lCore + "_HipSHJnt");
		
		delete `parentConstraint ($mod_lCore + "_HipJnt") ($mod_lCore + "_HipSHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_lCore + "_HipSHJnt");
		parentConstraint ($mod_lCore + "_HipJnt") ($mod_lCore + "_HipSHJnt");
		parent ($mod_lCore + "_HipSHJnt") ($modName + "_" + $modAttachNode + "SHJnt");
		//$JointOrient = `getAttr  ($mod_lCore + "_HipJnt.jointOrient")`;
		//setAttr (($mod_lCore + "_HipSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	}
	
	//RIGHT SIDE/////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////////////////////////
	
	
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";

		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $rPrfx + $core + "_Parent.attachNode")`;
	
		$mod_rCore = ($modName + "_" + $rPrfx + $core);

	
		//GENERATE JOINTS
		$splineProxies = `ls ("RRM_" + $rPrfx + $core + "_??")`;
		int $crntNum = 0;
		$numPadding = "_0";
		$prevPadding = "_0";
		float $splineLoc[];
		for ($crntProxy in $splineProxies)
		{
			$crntNum++;
			if ($crntNum >= 10)
			{$numPadding = "_";}
			
				
			select -cl;
			joint -n ($mod_rCore + $numPadding + $crntNum + "SHJnt");
			delete `parentConstraint ($mod_rCore + $numPadding + $crntNum + "Jnt") ($mod_rCore + $numPadding + $crntNum + "SHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_rCore + $numPadding + $crntNum + "SHJnt");
			parentConstraint ($mod_rCore + $numPadding + $crntNum + "Jnt") ($mod_rCore + $numPadding + $crntNum + "SHJnt");
	
			if ($crntNum == 1)
			{
				parent ($mod_rCore + $numPadding + $crntNum + "SHJnt") ($modName + "_" + $modAttachNode + "SHJnt");
				addAttr -ln "splineStart"  -at bool ($mod_rCore + $numPadding + $crntNum + "SHJnt");
				setAttr -e-keyable 1 ($mod_rCore + $numPadding + $crntNum + "SHJnt.splineStart");
			}
			else
			{
				int $previousNum = ($crntNum - 1);
				if ($previousNum >=10)
				{$prevPadding = "_";}
				parent ($mod_rCore + $numPadding + $crntNum + "SHJnt")  ($mod_rCore + $prevPadding + $previousNum + "SHJnt");
			}
			//$JointOrient = `getAttr  ($mod_rCore + $numPadding + $crntNum + "Jnt.jointOrient")`;
			//setAttr (($mod_rCore + $numPadding + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		}
		
		select -cl;
		joint -n ($mod_rCore + "_TopSHJnt");
		addAttr -ln "splineEnd"  -at bool ($mod_rCore + "_TopSHJnt");
		setAttr -e-keyable 1 ($mod_rCore + "_TopSHJnt.splineEnd");
	
		delete `parentConstraint ($mod_rCore + "_TopJnt") ($mod_rCore + "_TopSHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_rCore + "_TopSHJnt");
		parentConstraint ($mod_rCore + "_TopJnt") ($mod_rCore + "_TopSHJnt");
		parent ($mod_rCore + "_TopSHJnt") ($mod_rCore + $numPadding + $crntNum + "SHJnt");
		//$JointOrient = `getAttr  ($mod_rCore + "_TopJnt.jointOrient")`;
		//setAttr (($mod_rCore + "_TopSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		
		if (`objExists ("RRM_" + $lPrfx + $core + "_Hip")`)
		{
			select -cl;
			joint -n ($mod_rCore + "_HipSHJnt");
			delete `parentConstraint ($mod_rCore + "_HipJnt") ($mod_rCore + "_HipSHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_rCore + "_HipSHJnt");
			parentConstraint ($mod_rCore + "_HipJnt") ($mod_rCore + "_HipSHJnt");
			parent ($mod_rCore + "_HipSHJnt") ($modName + "_" + $modAttachNode + "SHJnt");
			//$JointOrient = `getAttr  ($mod_rCore + "_HipJnt.jointOrient")`;
			//setAttr (($mod_rCore + "_HipSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		}
	}
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE ARM SH MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRig_V1Arm_V1SH_V1(string $modName, string $topNode)
{
	$core = `getAttr ($topNode + ".core")`;

	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}
	
	//GET ATTACH NODE
	$modAttachNode = `getAttr ("RRM_" + $lPrfx + $core + "_Parent.attachNode")`;
	
	$mod_lCore = ($modName + "_" + $lPrfx + $core);
	
	$mod_rCore = ($modName + "_" + $rPrfx + $core);
	
	//GENERATE JOINTS
	select -cl;
	joint -n ($mod_lCore + "_ClavicleSHJnt");
	addAttr -ln "shoulder"  -at bool ($mod_lCore + "_ClavicleSHJnt");
	setAttr -e-keyable 1 ($mod_lCore + "_ClavicleSHJnt.shoulder");

	delete `parentConstraint ($mod_lCore + "_ClavicleJnt") ($mod_lCore + "_ClavicleSHJnt")`;
	makeIdentity -apply 1 -r 1 ($mod_lCore + "_ClavicleSHJnt");
	parentConstraint ($mod_lCore + "_ClavicleJnt") ($mod_lCore + "_ClavicleSHJnt");
	parent  ($mod_lCore + "_ClavicleSHJnt") ($modName + "_" + $modAttachNode + "SHJnt");
	//$JointOrient = `getAttr  ($mod_lCore + "_ClavicleJnt.jointOrient")`;
	//setAttr (($mod_lCore + "_ClavicleSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	
	$parentJnt = ($mod_lCore + "_ClavicleSHJnt");
	
	if (!`objExists ($mod_rCore + "_Shoulder_CurveJnt")`)
	{
		select -cl;
		joint -n ($mod_lCore + "_ShoulderSHJnt");
		addAttr -ln "arm"  -at bool ($mod_lCore + "_ShoulderSHJnt");
		setAttr -e-keyable 1 ($mod_lCore + "_ShoulderSHJnt.arm");
	
		delete `parentConstraint ($mod_lCore + "_ShoulderJnt") ($mod_lCore + "_ShoulderSHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_lCore + "_ShoulderSHJnt");
		parentConstraint ($mod_lCore + "_ShoulderJnt") ($mod_lCore + "_ShoulderSHJnt");
		parent ($mod_lCore + "_ShoulderSHJnt") $parentJnt;
		//$JointOrient = `getAttr  ($mod_lCore + "_ShoulderJnt.jointOrient")`;
		//setAttr (($mod_lCore + "_ShoulderSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		$parentJnt = ($mod_lCore + "_ShoulderSHJnt");
	}
	else
	{
		select -cl;
		joint -n ($mod_lCore + "_ShoulderSHJnt");
		addAttr -ln "arm"  -at bool ($mod_lCore + "_ShoulderSHJnt");
		setAttr -e-keyable 1 ($mod_lCore + "_ShoulderSHJnt.arm");

		delete `parentConstraint ($mod_lCore + "_Shoulder_CurveJnt") ($mod_lCore + "_ShoulderSHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_lCore + "_ShoulderSHJnt");
		parentConstraint ($mod_lCore + "_Shoulder_CurveJnt") ($mod_lCore + "_ShoulderSHJnt");
		parent ($mod_lCore + "_ShoulderSHJnt") $parentJnt;
		//$JointOrient = `getAttr  ($mod_lCore + "_Shoulder_CurveJnt.jointOrient")`;
		//setAttr (($mod_lCore + "_ShoulderSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		$parentJnt = ($mod_lCore + "_ShoulderSHJnt");
	}		
	
	//CHECK FOR TOON ARMS
	if (`objExists ($mod_lCore + "_Upper_Curve1Jnt")`)
	{
		$upperJnt = `ls ($mod_lCore + "_Upper_Curve?Jnt")`;
		int $crntNum = 1;
		for ($crntUpper in $upperJnt)
		{
			select -cl;
			joint -n ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt");
			delete `parentConstraint ($mod_lCore + "_Upper_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt");
			parentConstraint ($mod_lCore + "_Upper_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt");
			parent ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_lCore + "_Upper_Curve" + $crntNum + "Jnt.jointOrient")`;
			//setAttr (($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			$crntNum++;
		}
	}
	if (`objExists ($mod_lCore + "_ElbowJnt")`)
	{
		select -cl;
		if (!`objExists ($mod_lCore + "_Elbow_CurveJnt")`)
		{
			joint -n ($mod_lCore + "_ElbowSHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_ElbowSHJnt");
			setAttr -e-keyable 1 ($mod_lCore + "_ElbowSHJnt.forearm");
	
			delete `parentConstraint  ($mod_lCore + "_ElbowJnt")  ($mod_lCore + "_ElbowSHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_ElbowSHJnt");
			parentConstraint  ($mod_lCore + "_ElbowJnt")  ($mod_lCore + "_ElbowSHJnt");
			parent ($mod_lCore + "_ElbowSHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_lCore + "_ElbowJnt.jointOrient")`;
			//setAttr (($mod_lCore + "_ElbowSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt =  ($mod_lCore + "_ElbowSHJnt");
		}
		else
		{
			joint -n ($mod_lCore + "_Elbow_CurveSHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_Elbow_CurveSHJnt");
			setAttr -e-keyable 1 ($mod_lCore + "_Elbow_CurveSHJnt.forearm");
	
			delete `parentConstraint ($mod_lCore + "_Elbow_CurveJnt") ($mod_lCore + "_Elbow_CurveSHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_Elbow_CurveSHJnt");
			parentConstraint ($mod_lCore + "_Elbow_CurveJnt") ($mod_lCore + "_Elbow_CurveSHJnt");
			parent ($mod_lCore + "_Elbow_CurveSHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_lCore + "_Elbow_CurveJnt.jointOrient")`;
			//setAttr (($mod_lCore + "_Elbow_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_lCore + "_Elbow_CurveSHJnt");
		}
	}
	else
	{
		select -cl;
		if (!`objExists ($mod_lCore + "_Elbow1_CurveJnt")`)
		{
			joint -n  ($mod_lCore + "_Elbow1SHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_Elbow1SHJnt");
			setAttr -e-keyable 1 ($mod_lCore + "_Elbow1SHJnt.forearm");
	
			delete `parentConstraint  ($mod_lCore + "_Elbow1Jnt")  ($mod_lCore + "_Elbow1SHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_Elbow1SHJnt");
			parentConstraint  ($mod_lCore + "_Elbow1Jnt")  ($mod_lCore + "_Elbow1SHJnt");
			parent ($mod_lCore + "_Elbow1SHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_lCore + "_Elbow1Jnt.jointOrient")`;
			//setAttr (($mod_lCore + "_Elbow1SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt =  ($mod_lCore + "_Elbow1SHJnt");
		}
		else
		{
			joint -n ($mod_lCore + "_Elbow1_CurveSHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_Elbow1_CurveSHJnt");
			setAttr -e-keyable 1 ($mod_lCore + "_Elbow1_CurveSHJnt.forearm");
	
			delete `parentConstraint ($mod_lCore + "_Elbow1_CurveJnt") ($mod_lCore + "_Elbow1_CurveSHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_Elbow1_CurveSHJnt");
			parentConstraint ($mod_lCore + "_Elbow1_CurveJnt") ($mod_lCore + "_Elbow1_CurveSHJnt");
			parent ($mod_lCore + "_Elbow1_CurveSHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_lCore + "_Elbow1_CurveJnt.jointOrient")`;
			//setAttr (($mod_lCore + "_Elbow1_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_lCore + "_Elbow1_CurveSHJnt");
		}
		
		if (`objExists ($mod_lCore + "_Middle_Curve1Jnt")`)
		{
			$middleCurveJnt = `ls ($mod_lCore + "_Middle_Curve?Jnt")`;
			int $crntNum = 1;
			for ($crntMiddleCurve in $middleCurveJnt)
			{
				select -cl;
				joint -n ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt");
				
				delete `parentConstraint ($mod_lCore + "_Middle_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt");
				parentConstraint ($mod_lCore + "_Middle_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt");
				parent ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_lCore + "_Middle_Curve" + $crntNum + "Jnt.jointOrient")`;
				//setAttr (($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				
				$crntNum++;
			}
		}
		
		select -cl;
		if (!`objExists ($mod_lCore + "_Elbow2_CurveJnt")`)
		{
			joint -n  ($mod_lCore + "_Elbow2SHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_Elbow2SHJnt");
			setAttr -e-keyable 1 ($mod_lCore + "_Elbow2SHJnt.forearm");
	
			delete `parentConstraint  ($mod_lCore + "_Elbow2Jnt")  ($mod_lCore + "_Elbow2SHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_Elbow2SHJnt");
			parentConstraint  ($mod_lCore + "_Elbow2Jnt")  ($mod_lCore + "_Elbow2SHJnt");
			parent ($mod_lCore + "_Elbow2SHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_lCore + "_Elbow2Jnt.jointOrient")`;
			//setAttr (($mod_lCore + "_Elbow2SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt =  ($mod_lCore + "_Elbow2SHJnt");
		}
		else
		{
			joint -n ($mod_lCore + "_Elbow2_CurveSHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_Elbow2_CurveSHJnt");
			setAttr -e-keyable 1 ($mod_lCore + "_Elbow2_CurveSHJnt.forearm");
	
			delete `parentConstraint ($mod_lCore + "_Elbow2_CurveJnt") ($mod_lCore + "_Elbow2_CurveSHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_Elbow2_CurveSHJnt");
			parentConstraint ($mod_lCore + "_Elbow2_CurveJnt") ($mod_lCore + "_Elbow2_CurveSHJnt");
			parent ($mod_lCore + "_Elbow2_CurveSHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_lCore + "_Elbow2_CurveJnt.jointOrient")`;
			//setAttr (($mod_lCore + "_Elbow2_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_lCore + "_Elbow2_CurveSHJnt");
		}
	}

	if (`objExists ($mod_lCore + "_Lower_Curve1Jnt")`)
	{
		$upperJnt = `ls ($mod_lCore + "_Lower_Curve?Jnt")`;
		int $crntNum = 1;
		for ($crntUpper in $upperJnt)
		{
			select -cl;
			joint -n ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt");
			
			delete `parentConstraint ($mod_lCore + "_Lower_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt");
			parentConstraint ($mod_lCore + "_Lower_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt");
			parent ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_lCore + "_Lower_Curve" + $crntNum + "Jnt.jointOrient")`;
			//setAttr (($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			$crntNum++;
		}
	}
	
	select -cl;
	joint -n ($mod_lCore + "_WristSHJnt");
	addAttr -ln "hand"  -at bool ($mod_lCore + "_WristSHJnt");
	setAttr -e-keyable 1 ($mod_lCore + "_WristSHJnt.hand");

	delete `parentConstraint ($mod_lCore + "_WristJnt") ($mod_lCore + "_WristSHJnt")`;
	makeIdentity -apply 1 -r 1 ($mod_lCore + "_WristSHJnt");
	parentConstraint ($mod_lCore + "_WristJnt") ($mod_lCore + "_WristSHJnt");
	parent  ($mod_lCore + "_WristSHJnt") $parentJnt;
	//$JointOrient = `getAttr  ($mod_lCore + "_WristJnt.jointOrient")`;
	//setAttr (($mod_lCore + "_WristSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	
	//RIGHT SIDE//////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////

	if (`objExists ($topNode + ".pair")`)
	{
		$rPrfx = "l_";
		$rPrfx = "r_";

		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $rPrfx + $core + "_Parent.attachNode")`;
	
		$mod_rCore = ($modName + "_" + $rPrfx + $core);

		//GENERATE JOINTS
		select -cl;
		joint -n ($mod_rCore + "_ClavicleSHJnt");
		addAttr -ln "shoulder"  -at bool ($mod_rCore + "_ClavicleSHJnt");
		setAttr -e-keyable 1 ($mod_rCore + "_ClavicleSHJnt.shoulder");
	
		delete `parentConstraint ($mod_rCore + "_ClavicleJnt") ($mod_rCore + "_ClavicleSHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_rCore + "_ClavicleSHJnt");
		parentConstraint ($mod_rCore + "_ClavicleJnt") ($mod_rCore + "_ClavicleSHJnt");
		parent  ($mod_rCore + "_ClavicleSHJnt") ($modName + "_" + $modAttachNode + "SHJnt");
		//$JointOrient = `getAttr  ($mod_rCore + "_ClavicleJnt.jointOrient")`;
		//setAttr (($mod_rCore + "_ClavicleSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		
		$parentJnt = ($mod_rCore + "_ClavicleSHJnt");
		
		if (!`objExists ($mod_rCore + "_Shoulder_CurveJnt")`)
		{
			select -cl;
			joint -n ($mod_rCore + "_ShoulderSHJnt");
			addAttr -ln "arm"  -at bool ($mod_rCore + "_ShoulderSHJnt");
			setAttr -e-keyable 1 ($mod_rCore + "_ShoulderSHJnt.arm");
	
			delete `parentConstraint ($mod_rCore + "_ShoulderJnt") ($mod_rCore + "_ShoulderSHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_rCore + "_ShoulderSHJnt");
			parentConstraint ($mod_rCore + "_ShoulderJnt") ($mod_rCore + "_ShoulderSHJnt");
			parent ($mod_rCore + "_ShoulderSHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_rCore + "_ShoulderJnt.jointOrient")`;
			//setAttr (($mod_rCore + "_ShoulderSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_rCore + "_ShoulderSHJnt");
		}
		else
		{
			select -cl;
			joint -n ($mod_rCore + "_ShoulderSHJnt");

			delete `parentConstraint ($mod_rCore + "_Shoulder_CurveJnt") ($mod_rCore + "_ShoulderSHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_rCore + "_ShoulderSHJnt");
			parentConstraint ($mod_rCore + "_Shoulder_CurveJnt") ($mod_rCore + "_ShoulderSHJnt");
			parent ($mod_rCore + "_ShoulderSHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_rCore + "_Shoulder_CurveJnt.jointOrient")`;
			//setAttr (($mod_rCore + "_ShoulderSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_rCore + "_ShoulderSHJnt");
		}		
		
		//CHECK FOR TOON ARMS
		if (`objExists ($mod_rCore + "_Upper_Curve1Jnt")`)
		{
			$upperJnt = `ls ($mod_rCore + "_Upper_Curve?Jnt")`;
			int $crntNum = 1;
			for ($crntUpper in $upperJnt)
			{
				select -cl;
				joint -n ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt");

				delete `parentConstraint ($mod_rCore + "_Upper_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt");
				parentConstraint ($mod_rCore + "_Upper_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt");
				parent ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_Upper_Curve" + $crntNum + "Jnt.jointOrient")`;
				//setAttr (($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				
				$crntNum++;
			}
		}
		if (`objExists ($mod_rCore + "_ElbowJnt")`)
		{
			select -cl;
			if (!`objExists ($mod_rCore + "_Elbow_CurveJnt")`)
			{
				joint -n ($mod_rCore + "_ElbowSHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_ElbowSHJnt");
				setAttr -e-keyable 1 ($mod_rCore + "_ElbowSHJnt.forearm");
		
				delete `parentConstraint  ($mod_rCore + "_ElbowJnt")  ($mod_rCore + "_ElbowSHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_ElbowSHJnt");
				parentConstraint  ($mod_rCore + "_ElbowJnt")  ($mod_rCore + "_ElbowSHJnt");
				parent ($mod_rCore + "_ElbowSHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_ElbowJnt.jointOrient")`;
				//setAttr (($mod_rCore + "_ElbowSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt =  ($mod_rCore + "_ElbowSHJnt");
			}
			else
			{
				joint -n ($mod_rCore + "_Elbow_CurveSHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_Elbow_CurveSHJnt");
				setAttr -e-keyable 1 ($mod_rCore + "_Elbow_CurveSHJnt.forearm");
		
				delete `parentConstraint ($mod_rCore + "_Elbow_CurveJnt") ($mod_rCore + "_Elbow_CurveSHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_Elbow_CurveSHJnt");
				parentConstraint ($mod_rCore + "_Elbow_CurveJnt") ($mod_rCore + "_Elbow_CurveSHJnt");
				parent ($mod_rCore + "_Elbow_CurveSHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_Elbow_CurveJnt.jointOrient")`;
				//setAttr (($mod_rCore + "_Elbow_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt = ($mod_rCore + "_Elbow_CurveSHJnt");
			}
		}
		else
		{
			select -cl;
			if (!`objExists ($mod_rCore + "_Elbow1_CurveJnt")`)
			{
				joint -n  ($mod_rCore + "_Elbow1SHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_Elbow1SHJnt");
				setAttr -e-keyable 1 ($mod_rCore + "_Elbow1SHJnt.forearm");
		
				delete `parentConstraint  ($mod_rCore + "_Elbow1Jnt")  ($mod_rCore + "_Elbow1SHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_Elbow1SHJnt");
				parentConstraint  ($mod_rCore + "_Elbow1Jnt")  ($mod_rCore + "_Elbow1SHJnt");
				parent ($mod_rCore + "_Elbow1SHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_Elbow1Jnt.jointOrient")`;
				//setAttr (($mod_rCore + "_Elbow1SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt =  ($mod_rCore + "_Elbow1SHJnt");
			}
			else
			{
				joint -n ($mod_rCore + "_Elbow1_CurveSHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_Elbow1_CurveSHJnt");
				setAttr -e-keyable 1 ($mod_rCore + "_Elbow1_CurveSHJnt.forearm");
		
				delete `parentConstraint ($mod_rCore + "_Elbow1_CurveJnt") ($mod_rCore + "_Elbow1_CurveSHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_Elbow1_CurveSHJnt");
				parentConstraint ($mod_rCore + "_Elbow1_CurveJnt") ($mod_rCore + "_Elbow1_CurveSHJnt");
				parent ($mod_rCore + "_Elbow1_CurveSHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_Elbow1_CurveJnt.jointOrient")`;
				//setAttr (($mod_rCore + "_Elbow1_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt = ($mod_rCore + "_Elbow1_CurveSHJnt");
			}
				
			if (`objExists ($mod_rCore + "_Middle_Curve1Jnt")`)
			{
				$middleCurveJnt = `ls ($mod_rCore + "_Middle_Curve?Jnt")`;
				int $crntNum = 1;
				for ($crntMiddleCurve in $middleCurveJnt)
				{
					select -cl;
					joint -n ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt");
					
					delete `parentConstraint ($mod_rCore + "_Middle_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt")`;
					makeIdentity -apply 1 -r 1 ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt");
					parentConstraint ($mod_rCore + "_Middle_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt");
					parent ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt") $parentJnt;
					//$JointOrient = `getAttr  ($mod_rCore + "_Middle_Curve" + $crntNum + "Jnt.jointOrient")`;
					//setAttr (($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
					
					$crntNum++;
				}
			}

			select -cl;
			if (!`objExists ($mod_rCore + "_Elbow2_CurveJnt")`)
			{
				joint -n  ($mod_rCore + "_Elbow2SHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_Elbow2SHJnt");
				setAttr -e-keyable 1 ($mod_rCore + "_Elbow2SHJnt.forearm");
		
				delete `parentConstraint  ($mod_rCore + "_Elbow2Jnt")  ($mod_rCore + "_Elbow2SHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_Elbow2SHJnt");
				parentConstraint  ($mod_rCore + "_Elbow2Jnt")  ($mod_rCore + "_Elbow2SHJnt");
				parent ($mod_rCore + "_Elbow2SHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_Elbow2Jnt.jointOrient")`;
				//setAttr (($mod_rCore + "_Elbow2SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt =  ($mod_rCore + "_Elbow2SHJnt");
			}
			else
			{
				joint -n ($mod_rCore + "_Elbow2_CurveSHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_Elbow2_CurveSHJnt");
				setAttr -e-keyable 1 ($mod_rCore + "_Elbow2_CurveSHJnt.forearm");
		
				delete `parentConstraint ($mod_rCore + "_Elbow2_CurveJnt") ($mod_rCore + "_Elbow2_CurveSHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_Elbow2_CurveSHJnt");
				parentConstraint ($mod_rCore + "_Elbow2_CurveJnt") ($mod_rCore + "_Elbow2_CurveSHJnt");
				parent ($mod_rCore + "_Elbow2_CurveSHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_Elbow2_CurveJnt.jointOrient")`;
				//setAttr (($mod_rCore + "_Elbow2_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt = ($mod_rCore + "_Elbow2_CurveSHJnt");
			}
		}
    	
		if (`objExists ($mod_rCore + "_Lower_Curve1Jnt")`)
		{
			$upperJnt = `ls ($mod_rCore + "_Lower_Curve?Jnt")`;
			string $crntUpper;
			int $crntNum = 1;
			for ($crntUpper in $upperJnt)
			{
				select -cl;
				joint -n ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt");
				
				delete `parentConstraint ($mod_rCore + "_Lower_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt");
				parentConstraint ($mod_rCore + "_Lower_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt");
				parent ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_Lower_Curve" + $crntNum + "Jnt.jointOrient")`;
				//setAttr (($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				
				$crntNum++;
			}
		}
		
		select -cl;
		joint -n ($mod_rCore + "_WristSHJnt");
		addAttr -ln "hand"  -at bool ($mod_rCore + "_WristSHJnt");
		setAttr -e-keyable 1 ($mod_rCore + "_WristSHJnt.hand");

		delete `parentConstraint ($mod_rCore + "_WristJnt") ($mod_rCore + "_WristSHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_rCore + "_WristSHJnt");
		parentConstraint ($mod_rCore + "_WristJnt") ($mod_rCore + "_WristSHJnt");
		parent  ($mod_rCore + "_WristSHJnt") $parentJnt;	
		//$JointOrient = `getAttr  ($mod_rCore + "_WristJnt.jointOrient")`;
		//setAttr (($mod_rCore + "_WristSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	}
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////GENERATE LEG SH MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRig_V1Leg_V1SH_V1(string $modName, string $topNode)
{
	$core = `getAttr ($topNode + ".core")`;

	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}
	
	//GET ATTACH NODE
	$modAttachNode = `getAttr ("RRM_" + $lPrfx + $core + "_Parent.attachNode")`;
	
	$mod_lCore = ($modName + "_" + $lPrfx + $core);
	
	$mod_rCore = ($modName + "_" + $rPrfx + $core);
	
	//GENERATE JOINTS
	$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
	
	if (!`objExists ($mod_rCore + "_HipCurveJnt")`)
	{
		select -cl;
		joint -n ($mod_lCore + "_HipSHJnt");
		addAttr -ln "upLeg"  -at bool ($mod_lCore + "_HipSHJnt");
		setAttr -e-keyable 1 ($mod_lCore + "_HipSHJnt.upLeg");
	
		delete `parentConstraint ($mod_lCore + "_HipJnt") ($mod_lCore + "_HipSHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_lCore + "_HipSHJnt");
		parentConstraint ($mod_lCore + "_HipJnt") ($mod_lCore + "_HipSHJnt");
		parent ($mod_lCore + "_HipSHJnt") $parentJnt;
		//$JointOrient = `getAttr  ($mod_lCore + "_HipJnt.jointOrient")`;
		//setAttr (($mod_lCore + "_HipSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		$parentJnt = ($mod_lCore + "_HipSHJnt");
	}
	else
	{
		select -cl;
		joint -n ($mod_lCore + "_HipCurveSHJnt");
		addAttr -ln "upLeg"  -at bool ($mod_lCore + "_HipCurveSHJnt");
		setAttr -e-keyable 1 ($mod_lCore + "_HipCurveSHJnt.upLeg");
	
		delete `parentConstraint ($mod_lCore + "_HipCurveJnt") ($mod_lCore + "_HipCurveSHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_lCore + "_HipCurveSHJnt");
		parentConstraint ($mod_lCore + "_HipCurveJnt") ($mod_lCore + "_HipCurveSHJnt");
		parent ($mod_lCore + "_HipCurveSHJnt") $parentJnt;
		//$JointOrient = `getAttr  ($mod_lCore + "_HipCurveJnt.jointOrient")`;
		//setAttr (($mod_lCore + "_HipCurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		$parentJnt = ($mod_lCore + "_HipCurveSHJnt");
	}		
	
	//CHECK FOR TOON LEGS
	if (`objExists ($mod_lCore + "_Upper_Curve1Jnt")`)
	{
		$upperJnt = `ls ($mod_lCore + "_Upper_Curve?Jnt")`;
		string $crntUpper;
		int $crntNum = 1;
		for ($crntUpper in $upperJnt)
		{
			select -cl;
			joint -n ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt");
			
			delete `parentConstraint ($mod_lCore + "_Upper_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt");
			parentConstraint ($mod_lCore + "_Upper_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt");
			parent ($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_lCore + "_Upper_Curve" + $crntNum + "Jnt.jointOrient")`;
			//setAttr (($mod_lCore + "_Upper_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			$crntNum++;
		}
	}
	if (`objExists ($mod_lCore + "_KneeJnt")`)
	{
		select -cl;
		if (!`objExists ($mod_lCore + "_Knee_CurveJnt")`)
		{
			joint -n  ($mod_lCore + "_KneeSHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_KneeSHJnt");
			setAttr -e-keyable 1 ($mod_lCore + "_KneeSHJnt.forearm");
	
			delete `parentConstraint  ($mod_lCore + "_KneeJnt")  ($mod_lCore + "_KneeSHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_KneeSHJnt");
			parentConstraint  ($mod_lCore + "_KneeJnt")  ($mod_lCore + "_KneeSHJnt");
			parent ($mod_lCore + "_KneeSHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_lCore + "_KneeJnt.jointOrient")`;
			//setAttr (($mod_lCore + "_KneeSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt =  ($mod_lCore + "_KneeSHJnt");
		}
		else
		{
			joint -n ($mod_lCore + "_Knee_CurveSHJnt");
			addAttr -ln "leg"  -at bool ($mod_lCore + "_Knee_CurveSHJnt");
			setAttr -e-keyable 1 ($mod_lCore + "_Knee_CurveSHJnt.leg");
	
			delete `parentConstraint ($mod_lCore + "_Knee_CurveJnt") ($mod_lCore + "_Knee_CurveSHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_Knee_CurveSHJnt");
			parentConstraint ($mod_lCore + "_Knee_CurveJnt") ($mod_lCore + "_Knee_CurveSHJnt");
			parent ($mod_lCore + "_Knee_CurveSHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_lCore + "_Knee_CurveJnt.jointOrient")`;
			//setAttr (($mod_lCore + "_Knee_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_lCore + "_Knee_CurveSHJnt");
		}
	}
	else
	{
		select -cl;
		if (!`objExists ($mod_lCore + "_Knee1_CurveJnt")`)
		{
			joint -n  ($mod_lCore + "_Knee1SHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_Knee1SHJnt");
			setAttr -e-keyable 1 ($mod_lCore + "_Knee1SHJnt.forearm");
	
			delete `parentConstraint  ($mod_lCore + "_Knee1Jnt")  ($mod_lCore + "_Knee1SHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_Knee1SHJnt");
			parentConstraint  ($mod_lCore + "_Knee1Jnt")  ($mod_lCore + "_Knee1SHJnt");
			parent ($mod_lCore + "_Knee1SHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_lCore + "_Knee1Jnt.jointOrient")`;
			//setAttr (($mod_lCore + "_Knee1SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt =  ($mod_lCore + "_Knee1SHJnt");
		}
		else
		{
			joint -n ($mod_lCore + "_Knee1_CurveSHJnt");
			addAttr -ln "leg"  -at bool ($mod_lCore + "_Knee1_CurveSHJnt");
			setAttr -e-keyable 1 ($mod_lCore + "_Knee1_CurveSHJnt.leg");
	
			delete `parentConstraint ($mod_lCore + "_Knee1_CurveJnt") ($mod_lCore + "_Knee1_CurveSHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_Knee1_CurveSHJnt");
			parentConstraint ($mod_lCore + "_Knee1_CurveJnt") ($mod_lCore + "_Knee1_CurveSHJnt");
			parent ($mod_lCore + "_Knee1_CurveSHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_lCore + "_Knee1_CurveJnt.jointOrient")`;
			//setAttr (($mod_lCore + "_Knee1_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_lCore + "_Knee1_CurveSHJnt");
		}
		
		if (`objExists ($mod_lCore + "_Middle_Curve1Jnt")`)
		{
			$middleCurveJnt = `ls ($mod_lCore + "_Middle_Curve?Jnt")`;
			int $crntNum = 1;
			for ($crntMiddleCurve in $middleCurveJnt)
			{
				
				select -cl;
				joint -n ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt");
				
				delete `parentConstraint ($mod_lCore + "_Middle_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt");
				parentConstraint ($mod_lCore + "_Middle_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt");
				parent ($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_lCore + "_Middle_Curve" + $crntNum + "Jnt.jointOrient")`;
				//setAttr (($mod_lCore + "_Middle_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				
				$crntNum++;
			}
		}
		
		select -cl;
		if (!`objExists ($mod_lCore + "_Knee2_CurveJnt")`)
		{
			joint -n  ($mod_lCore + "_Knee2SHJnt");
			addAttr -ln "forearm"  -at bool ($mod_lCore + "_Knee2SHJnt");
			setAttr -e-keyable 1 ($mod_lCore + "_Knee2SHJnt.forearm");
	
			delete `parentConstraint  ($mod_lCore + "_Knee2Jnt")  ($mod_lCore + "_Knee2SHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_Knee2SHJnt");
			parentConstraint  ($mod_lCore + "_Knee2Jnt")  ($mod_lCore + "_Knee2SHJnt");
			parent ($mod_lCore + "_Knee2SHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_lCore + "_Knee2Jnt.jointOrient")`;
			//setAttr (($mod_lCore + "_Knee2SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt =  ($mod_lCore + "_Knee2SHJnt");
		}
		else
		{
			joint -n ($mod_lCore + "_Knee2_CurveSHJnt");
			addAttr -ln "leg"  -at bool ($mod_lCore + "_Knee2_CurveSHJnt");
			setAttr -e-keyable 1 ($mod_lCore + "_Knee2_CurveSHJnt.leg");
	
			delete `parentConstraint ($mod_lCore + "_Knee2_CurveJnt") ($mod_lCore + "_Knee2_CurveSHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_Knee2_CurveSHJnt");
			parentConstraint ($mod_lCore + "_Knee2_CurveJnt") ($mod_lCore + "_Knee2_CurveSHJnt");
			parent ($mod_lCore + "_Knee2_CurveSHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_lCore + "_Knee2_CurveJnt.jointOrient")`;
			//setAttr (($mod_lCore + "_Knee2_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_lCore + "_Knee2_CurveSHJnt");
		}
	}

	if (`objExists ($mod_lCore + "_Lower_Curve1Jnt")`)
	{
		$upperJnt = `ls ($mod_lCore + "_Lower_Curve?Jnt")`;
		string $crntUpper;
		int $crntNum = 1;
		for ($crntUpper in $upperJnt)
		{
			select -cl;
			joint -n ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt");
			
			delete `parentConstraint ($mod_lCore + "_Lower_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt");
			parentConstraint ($mod_lCore + "_Lower_Curve" + $crntNum + "Jnt") ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt");
			parent ($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt") $parentJnt;
			//$JointOrient = `getAttr ($mod_lCore + "_Lower_Curve" + $crntNum + "Jnt.jointOrient")`;
			//setAttr (($mod_lCore + "_Lower_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			$crntNum++;
		}
	}
	
	select -cl;
	joint -n ($mod_lCore + "_AnkleSHJnt");
	addAttr -ln "foot"  -at bool ($mod_lCore + "_AnkleSHJnt");
	setAttr -e-keyable 1 ($mod_lCore + "_AnkleSHJnt.foot");

	delete `parentConstraint ($mod_lCore + "_AnkleJnt") ($mod_lCore + "_AnkleSHJnt")`;
	makeIdentity -apply 1 -r 1 ($mod_lCore + "_AnkleSHJnt");
	parentConstraint ($mod_lCore + "_AnkleJnt") ($mod_lCore + "_AnkleSHJnt");
	parent  ($mod_lCore + "_AnkleSHJnt") $parentJnt;
	//$JointOrient = `getAttr  ($mod_lCore + "_AnkleJnt.jointOrient")`;
	//setAttr (($mod_lCore + "_AnkleSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	$parentJnt = ($mod_lCore + "_AnkleSHJnt");
	
	select -cl;
	joint -n ($mod_lCore + "_BallSHJnt");
	addAttr -ln "toeBase"  -at bool ($mod_lCore + "_BallSHJnt");
	setAttr -e-keyable 1 ($mod_lCore + "_BallSHJnt.toeBase");

	delete `parentConstraint ($mod_lCore + "_BallJnt") ($mod_lCore + "_BallSHJnt")`;
	makeIdentity -apply 1 -r 1 ($mod_lCore + "_BallSHJnt");
	parentConstraint ($mod_lCore + "_BallJnt") ($mod_lCore + "_BallSHJnt");
	parent ($mod_lCore + "_BallSHJnt") $parentJnt;
	//$JointOrient = `getAttr  ($mod_lCore + "_BallJnt.jointOrient")`;
	//setAttr (($mod_lCore + "_BallSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	$parentJnt = ($mod_lCore + "_BallSHJnt");
	
	select -cl;
	joint -n ($mod_lCore + "_ToeSHJnt");
	
	delete `parentConstraint ($mod_lCore + "_ToeJnt") ($mod_lCore + "_ToeSHJnt")`;
	makeIdentity -apply 1 -r 1 ($mod_lCore + "_ToeSHJnt");
	parentConstraint ($mod_lCore + "_ToeJnt") ($mod_lCore + "_ToeSHJnt");
	parent  ($mod_lCore + "_ToeSHJnt") $parentJnt;
	//$JointOrient = `getAttr  ($mod_lCore + "_ToeJnt.jointOrient")`;
	//setAttr (($mod_lCore + "_ToeSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	
	//RIGHT SIDE//////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////////////

	if (`objExists ($topNode + ".pair")`)
	{
		$rPrfx = "l_";
		$rPrfx = "r_";

		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $rPrfx + $core + "_Parent.attachNode")`;
	
		$mod_rCore = ($modName + "_" + $rPrfx + $core);

		//GENERATE JOINTS
		$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
		
		if (!`objExists ($mod_rCore + "_HipCurveJnt")`)
		{
			select -cl;
			joint -n ($mod_rCore + "_HipSHJnt");
			addAttr -ln "upLeg"  -at bool ($mod_rCore + "_HipSHJnt");
			setAttr -e-keyable 1 ($mod_rCore + "_HipSHJnt.upLeg");

			delete `parentConstraint ($mod_rCore + "_HipJnt") ($mod_rCore + "_HipSHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_rCore + "_HipSHJnt");
			parentConstraint ($mod_rCore + "_HipJnt") ($mod_rCore + "_HipSHJnt");
			parent ($mod_rCore + "_HipSHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_rCore + "_HipJnt.jointOrient")`;
			//setAttr (($mod_rCore + "_HipSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_rCore + "_HipSHJnt");
		}
		else
		{
			select -cl;
			joint -n ($mod_rCore + "_HipCurveSHJnt");
			addAttr -ln "upLeg"  -at bool ($mod_rCore + "_HipCurveSHJnt");
			setAttr -e-keyable 1 ($mod_rCore + "_HipCurveSHJnt.upLeg");

			delete `parentConstraint ($mod_rCore + "_HipCurveJnt") ($mod_rCore + "_HipCurveSHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_rCore + "_HipCurveSHJnt");
			parentConstraint ($mod_rCore + "_HipCurveJnt") ($mod_rCore + "_HipCurveSHJnt");
			parent ($mod_rCore + "_HipCurveSHJnt") $parentJnt;
			//$JointOrient = `getAttr  ($mod_rCore + "_HipCurveJnt.jointOrient")`;
			//setAttr (($mod_rCore + "_HipCurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			$parentJnt = ($mod_rCore + "_HipCurveSHJnt");
		}		
		
		//CHECK FOR TOON LEGS
		if (`objExists ($mod_rCore + "_Upper_Curve1Jnt")`)
		{
			$upperJnt = `ls ($mod_rCore + "_Upper_Curve?Jnt")`;
			string $crntUpper;
			int $crntNum = 1;
			for ($crntUpper in $upperJnt)
			{
				select -cl;
				joint -n ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt");
				
				delete `parentConstraint ($mod_rCore + "_Upper_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt");
				parentConstraint ($mod_rCore + "_Upper_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt");
				parent ($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_Upper_Curve" + $crntNum + "Jnt.jointOrient")`;
				//setAttr (($mod_rCore + "_Upper_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				
				$crntNum++;
			}
		}
		if (`objExists ($mod_rCore + "_KneeJnt")`)
		{
			select -cl;
			if (!`objExists ($mod_rCore + "_Knee_CurveJnt")`)
			{
				joint -n  ($mod_rCore + "_KneeSHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_KneeSHJnt");
				setAttr -e-keyable 1 ($mod_rCore + "_KneeSHJnt.forearm");
		
				delete `parentConstraint  ($mod_rCore + "_KneeJnt")  ($mod_rCore + "_KneeSHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_KneeSHJnt");
				parentConstraint  ($mod_rCore + "_KneeJnt")  ($mod_rCore + "_KneeSHJnt");
				parent ($mod_rCore + "_KneeSHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_KneeJnt.jointOrient")`;
				//setAttr (($mod_rCore + "_KneeSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt =  ($mod_rCore + "_KneeSHJnt");
			}
			else
			{
				joint -n ($mod_rCore + "_Knee_CurveSHJnt");
				addAttr -ln "leg"  -at bool ($mod_rCore + "_Knee_CurveSHJnt");
				setAttr -e-keyable 1 ($mod_rCore + "_Knee_CurveSHJnt.leg");
		
				delete `parentConstraint ($mod_rCore + "_Knee_CurveJnt") ($mod_rCore + "_Knee_CurveSHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_Knee_CurveSHJnt");
				parentConstraint ($mod_rCore + "_Knee_CurveJnt") ($mod_rCore + "_Knee_CurveSHJnt");
				parent ($mod_rCore + "_Knee_CurveSHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_Knee_CurveJnt.jointOrient")`;
				//setAttr (($mod_rCore + "_Knee_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt = ($mod_rCore + "_Knee_CurveSHJnt");
			}
		}
		else
		{
			select -cl;
			if (!`objExists ($mod_rCore + "_Knee1_CurveJnt")`)
			{
				joint -n  ($mod_rCore + "_Knee1SHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_Knee1SHJnt");
				setAttr -e-keyable 1 ($mod_rCore + "_Knee1SHJnt.forearm");
		
				delete `parentConstraint  ($mod_rCore + "_Knee1Jnt")  ($mod_rCore + "_Knee1SHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_Knee1SHJnt");
				parentConstraint  ($mod_rCore + "_Knee1Jnt")  ($mod_rCore + "_Knee1SHJnt");
				parent ($mod_rCore + "_Knee1SHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_Knee1Jnt.jointOrient")`;
				//setAttr (($mod_rCore + "_Knee1SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt =  ($mod_rCore + "_Knee1SHJnt");
			}
			else
			{
				joint -n ($mod_rCore + "_Knee1_CurveSHJnt");
				addAttr -ln "leg"  -at bool ($mod_rCore + "_Knee1_CurveSHJnt");
				setAttr -e-keyable 1 ($mod_rCore + "_Knee1_CurveSHJnt.leg");
		
				delete `parentConstraint ($mod_rCore + "_Knee1_CurveJnt") ($mod_rCore + "_Knee1_CurveSHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_Knee1_CurveSHJnt");
				parentConstraint ($mod_rCore + "_Knee1_CurveJnt") ($mod_rCore + "_Knee1_CurveSHJnt");
				parent ($mod_rCore + "_Knee1_CurveSHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_Knee1_CurveJnt.jointOrient")`;
				//setAttr (($mod_rCore + "_Knee1_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt = ($mod_rCore + "_Knee1_CurveSHJnt");
			}
			
			if (`objExists ($mod_rCore + "_Middle_Curve1Jnt")`)
			{
				$middleCurveJnt = `ls ($mod_rCore + "_Middle_Curve?Jnt")`;
				int $crntNum = 1;
				for ($crntMiddleCurve in $middleCurveJnt)
				{
					
					select -cl;
					joint -n ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt");
					
					delete `parentConstraint ($mod_rCore + "_Middle_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt")`;
					makeIdentity -apply 1 -r 1 ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt");
					parentConstraint ($mod_rCore + "_Middle_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt");
					parent ($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt") $parentJnt;
					//$JointOrient = `getAttr  ($mod_rCore + "_Middle_Curve" + $crntNum + "Jnt.jointOrient")`;
					//setAttr (($mod_rCore + "_Middle_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
					
					$crntNum++;
				}
			}
			select -cl;
			if (!`objExists ($mod_rCore + "_Knee2_CurveJnt")`)
			{
				joint -n  ($mod_rCore + "_Knee2SHJnt");
				addAttr -ln "forearm"  -at bool ($mod_rCore + "_Knee2SHJnt");
				setAttr -e-keyable 1 ($mod_rCore + "_Knee2SHJnt.forearm");
		
				delete `parentConstraint  ($mod_rCore + "_Knee2Jnt")  ($mod_rCore + "_Knee2SHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_Knee2SHJnt");
				parentConstraint  ($mod_rCore + "_Knee2Jnt")  ($mod_rCore + "_Knee2SHJnt");
				parent ($mod_rCore + "_Knee2SHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_Knee2Jnt.jointOrient")`;
				//setAttr (($mod_rCore + "_Knee2SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt =  ($mod_rCore + "_Knee2SHJnt");
			}
			else
			{
				joint -n ($mod_rCore + "_Knee2_CurveSHJnt");
				addAttr -ln "leg"  -at bool ($mod_rCore + "_Knee2_CurveSHJnt");
				setAttr -e-keyable 1 ($mod_rCore + "_Knee2_CurveSHJnt.leg");
		
				delete `parentConstraint ($mod_rCore + "_Knee2_CurveJnt") ($mod_rCore + "_Knee2_CurveSHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_Knee2_CurveSHJnt");
				parentConstraint ($mod_rCore + "_Knee2_CurveJnt") ($mod_rCore + "_Knee2_CurveSHJnt");
				parent ($mod_rCore + "_Knee2_CurveSHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_Knee2_CurveJnt.jointOrient")`;
				//setAttr (($mod_rCore + "_Knee2_CurveSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				$parentJnt = ($mod_rCore + "_Knee2_CurveSHJnt");
			}
		}
    	
		if (`objExists ($mod_rCore + "_Lower_Curve1Jnt")`)
		{
			$upperJnt = `ls ($mod_rCore + "_Lower_Curve?Jnt")`;
			string $crntUpper;
			int $crntNum = 1;
			for ($crntUpper in $upperJnt)
			{
				
				select -cl;
				joint -n ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt");
				
				delete `parentConstraint ($mod_rCore + "_Lower_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt");
				parentConstraint ($mod_rCore + "_Lower_Curve" + $crntNum + "Jnt") ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt");
				parent ($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt") $parentJnt;
				//$JointOrient = `getAttr  ($mod_rCore + "_Lower_Curve" + $crntNum + "Jnt.jointOrient")`;
				//setAttr (($mod_rCore + "_Lower_Curve" + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				
				$crntNum++;
			}
		}
		
		select -cl;
		joint -n ($mod_rCore + "_AnkleSHJnt");
		addAttr -ln "foot"  -at bool ($mod_rCore + "_AnkleSHJnt");
		setAttr -e-keyable 1 ($mod_rCore + "_AnkleSHJnt.foot");

		delete `parentConstraint ($mod_rCore + "_AnkleJnt") ($mod_rCore + "_AnkleSHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_rCore + "_AnkleSHJnt");
		parentConstraint ($mod_rCore + "_AnkleJnt") ($mod_rCore + "_AnkleSHJnt");
		parent  ($mod_rCore + "_AnkleSHJnt") $parentJnt;
		//$JointOrient = `getAttr  ($mod_rCore + "_AnkleJnt.jointOrient")`;
		//setAttr (($mod_rCore + "_AnkleSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		$parentJnt = ($mod_rCore + "_AnkleSHJnt");
			
		select -cl;
		joint -n ($mod_rCore + "_BallSHJnt");
		addAttr -ln "toeBase"  -at bool ($mod_rCore + "_BallSHJnt");
		setAttr -e-keyable 1 ($mod_rCore + "_BallSHJnt.toeBase");

		delete `parentConstraint ($mod_rCore + "_BallJnt") ($mod_rCore + "_BallSHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_rCore + "_BallSHJnt");
		parentConstraint ($mod_rCore + "_BallJnt") ($mod_rCore + "_BallSHJnt");
		parent  ($mod_rCore + "_BallSHJnt") $parentJnt;
		//$JointOrient = `getAttr  ($mod_rCore + "_BallJnt.jointOrient")`;
		//setAttr (($mod_rCore + "_BallSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		$parentJnt = ($mod_rCore + "_BallSHJnt");
		
		select -cl;
		joint -n ($mod_rCore + "_ToeSHJnt");
		
		delete `parentConstraint ($mod_rCore + "_ToeJnt") ($mod_rCore + "_ToeSHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_rCore + "_ToeSHJnt");
		parentConstraint ($mod_rCore + "_ToeJnt") ($mod_rCore + "_ToeSHJnt");
		parent  ($mod_rCore + "_ToeSHJnt") $parentJnt;
		//$JointOrient = `getAttr  ($mod_rCore + "_ToeJnt.jointOrient")`;
		//setAttr (($mod_rCore + "_ToeSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	}
}


////////////////////////////////////////////////////////////////////////////////
/////////////////////////GENERATE FK CHAIN SH MODULE////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRig_V1FkChain_V1SH_V1(string $modName, string $topNode)
{
	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}
	
	//GET ATTACH NODE
	$modAttachNode = `getAttr ("RRM_" + $lPrfx + $core + "_Parent.attachNode")`;
	
	$mod_lCore = ($modName + "_" + $lPrfx + $core);
	$mod_rCore = ($modName + "_" + $rPrfx + $core);
	
	$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
	
	$allJoints = `ls ("RRM_" + $lPrfx + $core + "_??_??")`;
	$fKChain = `ls ("RRM_" + $lPrfx + $core + "_??_01")`;
	$fKChainSize = `size $fKChain`;
	string $crntFKChain;
	$crntCh = 1;
	$crntJnt = 1;
		
	for ($crntFKChain in $fKChain)                                    
	{
		$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
		string $nPdCh = "";
		if ($crntCh < 10)
		{
			$nPdCh = "0";
		}
		
		$fKJoints = `ls ("RRM_" + $lPrfx + $core + "_" + $nPdCh + $crntCh + "_" + "??")`;
		string $crntFKJoint;
		$crntJnt = 1;
		for ($crntFKJoint in $fKJoints)
		{
			string $nPd = "";
			if ($crntJnt < 10)
			{
				$nPd = "0";
			}
			$nextJnt = ($crntJnt + 1);
			$nPdNext = "";
			if ($nextJnt <10)
			{
				$nPdNext = "0";
			}
			select -cl;
			joint -n ($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
			
			delete `parentConstraint ($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
			parentConstraint ($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
			parent ($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt") $parentJnt;
			//$JointOrient = `getAttr ($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.jointOrient")`;
			//setAttr (($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			$parentJnt = ($mod_lCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
			
			$crntJnt++;
		}
		$crntCh++;
	}
	
	//RIGHT SIDE////////////////////////////////////////////////////////
	///////////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $rPrfx + $core + "_Parent.attachNode")`;
		
		$mod_lCore = ($modName + "_" + $lPrfx + $core);
		$mod_rCore = ($modName + "_" + $rPrfx + $core);
		
		$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
		
		$allJoints = `ls ("RRM_" + $lPrfx + $core + "_??_??")`;
		$fKChain = `ls ("RRM_" + $lPrfx + $core + "_??_01")`;
		$fKChainSize = `size $fKChain`;
		$crntCh = 1;
		$crntJnt = 1;
			
		for ($crntFKChain in $fKChain)                                    
		{
			$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
			string $nPdCh = "";
			if ($crntCh < 10)
			{
				$nPdCh = "0";
			}
			
			select ;
			$fKProxies = `ls ("RRM_" + $lPrfx + $core + "_" + $nPdCh + $crntCh + "_" + "??")`;
			$crntJnt = 1;
			for ($crntFKJoint in $fKProxies)
			{
				string $nPd = "";
				if ($crntJnt < 10)
				{
					$nPd = "0";
				}
				$nextJnt = ($crntJnt + 1);
				$nPdNext = "";
				if ($nextJnt <10)
				{
					$nPdNext = "0";
				}
				select -cl;
				joint -n ($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
				
				delete `parentConstraint ($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt")`;
				makeIdentity -apply 1 -r 1 ($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
				parentConstraint ($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt") ($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
				parent ($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt") $parentJnt;
				//$JointOrient = `getAttr ($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "Jnt.jointOrient")`;
				//setAttr (($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
				
				$parentJnt = ($mod_rCore + "_" + $nPdCh + $crntCh + "_" + $nPd + $crntJnt + "SHJnt");
				
				$crntJnt++;
			}
			$crntCh++;
		}
	}
}


////////////////////////////////////////////////////////////////////////////////
/////////////////////////GENERATE HEAD SH MODULE////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRig_V1Head_V1SH_V1(string $modName, string $topNode)
{
	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}
	
	//GET ATTACH NODE
	$modAttachNode = `getAttr ("RRM_" + $lPrfx + $core + "_Parent.attachNode")`;
	
	$mod_lCore = ($modName + "_" + $lPrfx + $core);
	$mod_rCore = ($modName + "_" + $rPrfx + $core);
	
	$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
	

	if (`objExists ($mod_lCore + "_JawJnt")`)
	{
		select -cl;
		joint -n ($mod_lCore + "_JawSHJnt");
		
		delete `parentConstraint ($mod_lCore + "_JawJnt") ($mod_lCore + "_JawSHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_lCore + "_JawSHJnt");
		parentConstraint ($mod_lCore + "_JawJnt") ($mod_lCore + "_JawSHJnt");
		parent ($mod_lCore + "_JawSHJnt") $parentJnt;
		//$JointOrient = `getAttr ($mod_lCore + "_JawJnt.jointOrient")`;
		//setAttr (($mod_lCore + "_JawSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		
		select -cl;
		joint -n ($mod_lCore + "_JawEndSHJnt");
		
		delete `parentConstraint ($mod_lCore + "_JawEndJnt") ($mod_lCore + "_JawEndSHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_lCore + "_JawEndSHJnt");
		parentConstraint ($mod_lCore + "_JawEndJnt") ($mod_lCore + "_JawEndSHJnt");
		parent ($mod_lCore + "_JawEndSHJnt") ($mod_lCore + "_JawSHJnt");
		//$JointOrient = `getAttr ($mod_lCore + "_JawEndJnt.jointOrient")`;
		//setAttr (($mod_lCore + "_JawEndSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	}

	select -cl;
	joint -n ($mod_lCore + "_TopSHJnt");
	
	delete `parentConstraint ($mod_lCore + "_TopJnt") ($mod_lCore + "_TopSHJnt")`;
	makeIdentity -apply 1 -r 1 ($mod_lCore + "_TopSHJnt");
	parentConstraint ($mod_lCore + "_TopJnt") ($mod_lCore + "_TopSHJnt");
	parent ($mod_lCore + "_TopSHJnt") $parentJnt;
	//$JointOrient = `getAttr ($mod_lCore + "_TopJnt.jointOrient")`;
	//setAttr (($mod_lCore + "_TopSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);

	//RIGHT SIDE
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
		
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $rPrfx + $core + "_Parent.attachNode")`;
    	
		$mod_lCore = ($modName + "_" + $lPrfx + $core);
		$mod_rCore = ($modName + "_" + $rPrfx + $core);
		
		$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
		
		if (`objExists ($mod_rCore + "_JawJnt")`)
		{
			select -cl;
			joint -n ($mod_rCore + "_JawSHJnt");
			
			delete `parentConstraint ($mod_rCore + "_JawJnt") ($mod_rCore + "_JawSHJnt")`;
			parentConstraint ($mod_rCore + "_JawJnt") ($mod_rCore + "_JawSHJnt");
			parent ($mod_rCore + "_JawSHJnt") $parentJnt;
			//$JointOrient = `getAttr ($mod_rCore + "_JawJnt.jointOrient")`;
			//setAttr (($mod_rCore + "_JawSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			select -cl;
			joint -n ($mod_rCore + "_JawEndSHJnt");
			
			delete `parentConstraint ($mod_rCore + "_JawEndJnt") ($mod_rCore + "_JawEndSHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_rCore + "_JawEndSHJnt");
			parentConstraint ($mod_rCore + "_JawEndJnt") ($mod_rCore + "_JawEndSHJnt");
			parent ($mod_rCore + "_JawEndSHJnt") ($mod_rCore + "_JawSHJnt");
			//$JointOrient = `getAttr ($mod_rCore + "_JawEndJnt.jointOrient")`;
			//setAttr (($mod_rCore + "_JawEndSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		}
    	
		select -cl;
		joint -n ($mod_rCore + "_TopSHJnt");
		
		delete `parentConstraint ($mod_rCore + "_TopJnt") ($mod_rCore + "_TopSHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_rCore + "_TopSHJnt");
		parentConstraint ($mod_rCore + "_TopJnt") ($mod_rCore + "_TopSHJnt");
		parent ($mod_rCore + "_TopSHJnt") $parentJnt;
		//$JointOrient = `getAttr ($mod_rCore + "_TopJnt.jointOrient")`;
		//setAttr (($mod_rCore + "_TopSHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);

	}
}
		
////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE LOOK AT SH MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRig_V1LookAt_V1SH_V1(string $modName, string $topNode)
{
	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}
	
	//GET ATTACH NODE
	$modAttachNode = `getAttr ("RRM_" + $lPrfx + $core + "_Parent.attachNode")`;
	
	$mod_lCore = ($modName + "_" + $lPrfx + $core);
	$mod_rCore = ($modName + "_" + $rPrfx + $core);
	
	$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
	
	//EYE JOINTS
	$lookAts = `ls ("RRM_" + $lPrfx + $core + "_??")`;
	string $crntLookAt;
	$crntNum = 1;
	for ($crntLookAt in $lookAts)
	{
		string $nPd = "";
		if ($crntNum < 10)
		{
			$nPd = "0";
		}
		select -cl;
		joint -n ($mod_lCore + "_" + $nPd + $crntNum + "SHJnt");
		
		delete `parentConstraint ($mod_lCore + "_" + $nPd + $crntNum + "Jnt") ($mod_lCore + "_" + $nPd + $crntNum + "SHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_lCore + "_" + $nPd + $crntNum + "SHJnt");
		parentConstraint ($mod_lCore + "_" + $nPd + $crntNum + "Jnt") ($mod_lCore + "_" + $nPd + $crntNum + "SHJnt");
		parent ($mod_lCore + "_" + $nPd + $crntNum + "SHJnt") $parentJnt;
		//$JointOrient = `getAttr ($mod_lCore + "_" + $nPd + $crntNum + "Jnt.jointOrient")`;
		//setAttr (($mod_lCore + "_" + $nPd + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
		
		$crntNum++;
	}
	
	//RIGHT SIDE		
	if (`objExists ($topNode + ".pair")`)
	{
		$rPrfx = "l_";
		$rPrfx = "r_";
	
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $rPrfx + $core + "_Parent.attachNode")`;
    	
		$mod_rCore = ($modName + "_" + $rPrfx + $core);

		$mod_lCore = ($modName + "_" + $lPrfx + $core);
		$mod_rCore = ($modName + "_" + $rPrfx + $core);
		
		$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
		
		//EYE JOINTS
		$lookAts = `ls ("RRM_" + $lPrfx + $core + "_??")`;
		string $crntLookAt;
		$crntNum = 1;
		for ($crntLookAt in $lookAts)
		{
			string $nPd = "";
			if ($crntNum < 10)
			{
				$nPd = "0";
			}
			select -cl;
			joint -n ($mod_rCore + "_" + $nPd + $crntNum + "SHJnt");
			
			delete `parentConstraint ($mod_rCore + "_" + $nPd + $crntNum + "Jnt") ($mod_rCore + "_" + $nPd + $crntNum + "SHJnt")`;
			makeIdentity -apply 1 -r 1 ($mod_rCore + "_" + $nPd + $crntNum + "SHJnt");
			parentConstraint ($mod_rCore + "_" + $nPd + $crntNum + "Jnt") ($mod_rCore + "_" + $nPd + $crntNum + "SHJnt");
			parent ($mod_rCore + "_" + $nPd + $crntNum + "SHJnt") $parentJnt;
			//$JointOrient = `getAttr ($mod_rCore + "_" + $nPd + $crntNum + "Jnt.jointOrient")`;
			//setAttr (($mod_rCore + "_" + $nPd + $crntNum + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
			
			$crntNum++;
		}
	}
}

		
////////////////////////////////////////////////////////////////////////////////
///////////////////////////GENERATE AUX AT SH MODULE//////////////////////////////
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRig_V1Auxiliary_V1SH_V1(string $modName, string $topNode)
{
	//GET MOD TYPE
	string $modType = `getAttr ($topNode + ".parent")`;     
		
	$core = `getAttr ($topNode + ".core")`;
	string $lPrfx = "";
	string $rPrfx = "";
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
	}
	
	//GET ATTACH NODE
	$modAttachNode = `getAttr ("RRM_" + $lPrfx + $core + "_Aux.attachNode")`;
	
	$mod_lCore = ($modName + "_" + $lPrfx + $core + "_Aux");
	$mod_rCore = ($modName + "_" + $rPrfx + $core + "_Aux");
	
	$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
	
	select -cl;
	joint -n ($mod_lCore + "SHJnt");
	
	delete `parentConstraint ($mod_lCore + "Jnt") ($mod_lCore + "SHJnt")`;
	makeIdentity -apply 1 -r 1 ($mod_lCore + "SHJnt");
	parentConstraint ($mod_lCore + "Jnt") ($mod_lCore + "SHJnt");
	parent ($mod_lCore + "SHJnt") $parentJnt;
	//$JointOrient = `getAttr ($mod_lCore + "Jnt.jointOrient")`;
	//setAttr (($mod_lCore + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);

	//RIGHT SIDE
	if (`objExists ($topNode + ".pair")`)
	{
		$lPrfx = "l_";
		$rPrfx = "r_";
		
		//GET ATTACH NODE
		$modAttachNode = `getAttr ("RRM_" + $rPrfx + $core + "_Aux.attachNode")`;
    	
		$mod_lCore = ($modName + "_" + $lPrfx + $core + "_Aux");
		$mod_rCore = ($modName + "_" + $rPrfx + $core + "_Aux");
		
		$parentJnt = ($modName + "_" + $modAttachNode + "SHJnt");
    	
		select -cl;
		joint -n ($mod_rCore + "SHJnt");
		
		delete `parentConstraint ($mod_rCore + "Jnt") ($mod_rCore + "SHJnt")`;
		makeIdentity -apply 1 -r 1 ($mod_rCore + "SHJnt");
		parentConstraint ($mod_rCore + "Jnt") ($mod_rCore + "SHJnt");
		parent ($mod_rCore + "SHJnt") $parentJnt;
		//$JointOrient = `getAttr ($mod_rCore + "Jnt.jointOrient")`;
		//setAttr (($mod_rCore + "SHJnt.jointOrient"), $JointOrient[0], $JointOrient[1], $JointOrient[2]);
	}
}


global proc RRM_MirrorAttributes_V1(string $modName, string $moduleName)
{
	if (`objExists ($modName + "_l_" + $moduleName + "*Ctrl")`)
	{
		select ;
		$lControls = `ls -type "transform" ($modName + "_l_" + $moduleName + "*Ctrl")`;
		
		for ($lCurrentControl in $lControls)
		{
			if (!`objExists ($lCurrentControl + ".rightControl")`)
			{
				addAttr -ln "rightControl"  -dt "string" $lCurrentControl;
				setAttr -e-keyable 1 ($lCurrentControl + ".rightControl");
				$name = substituteAllString ($lCurrentControl, ($modName + "_l_"), ("_r_"));
				setAttr -type "string" ($lCurrentControl + ".rightControl") $name;
				setAttr -l true ($lCurrentControl + ".rightControl");
			}
		}
		
		if (`objExists ($modName + "_r_" + $moduleName + "*Ctrl")`)  
		{
			$rControls = `ls -type "transform" ($modName + "_r_" + $moduleName + "*Ctrl")`;
			
			for ($rCurrentControl in $rControls)
			{
				if (!`objExists ($rCurrentControl + ".leftControl")`)
				{
					addAttr -ln "leftControl"  -dt "string" $rCurrentControl;
					setAttr -e-keyable 1 ($rCurrentControl + ".leftControl");
					$name = substituteAllString ($rCurrentControl, ($modName + "_r_"), ("_l_"));
					setAttr -type "string" ($rCurrentControl + ".leftControl") $name;
					setAttr -l true ($rCurrentControl + ".leftControl");
				}
			}
		}
	}
}

global proc RRM_AddRigName_V1(string $modName, string $modControls[])
{
	for ($crntControl in $modControls)
	{
		addAttr -ln "modRigName"  -dt "string" $crntControl;
		setAttr -e-keyable 1 ($crntControl + ".modRigName");
		setAttr -type "string" ($crntControl + ".modRigName") $modName;
		setAttr -l true ($crntControl + ".modRigName");
	}
	
	addAttr -ln "modRigConnection"  -dt "string" $modName;
	setAttr -e-keyable 1 ($modName + ".modRigConnection");
	setAttr -type "string" ($modName + ".modRigConnection") $modName;
	setAttr -l true ($modName + ".modRigConnection");
	
	for ($crntControl in $modControls)
	{
		addAttr -ln "modRigConnection"  -dt "string" $crntControl;
		setAttr -e-keyable 1 ($crntControl + ".modRigConnection");
		connectAttr -f ($modName + ".modRigConnection") ($crntControl + ".modRigConnection");
		setAttr -l true ($crntControl + ".modRigConnection");
	}
}

global proc RRM_AddControlsSize_V1(string $modControls[])
{
	for ($each in $modControls)
	{
		if (!`objExists ($each + ".nonControl")`)
		{
			addAttr -ln "controlSizeX"  -at double  -dv 1 $each;
			setAttr -e -keyable 1 ($each + ".controlSizeX");
			setAttr -lock 1 ($each + ".controlSizeX");

			addAttr -ln "controlSizeY"  -at double  -dv 1 $each;
			setAttr -e -keyable 1 ($each + ".controlSizeY");
			setAttr -lock 1 ($each + ".controlSizeY");

			addAttr -ln "controlSizeZ"  -at double  -dv 1 $each;
			setAttr -e -keyable 1 ($each + ".controlSizeZ");
			setAttr -lock 1 ($each + ".controlSizeZ");
			
			//ADD MIRROR ATTRIBUTE
			addAttr -ln "isMirrored"  -at double  -dv 1 $each;
			setAttr -e -keyable 0 ($each + ".isMirrored");
			setAttr ($each + ".isMirrored") 1015;
		}
	}
}

global proc RRM_LockAndHideNonModNodes_V1(string $modName)
{
	$allNodes = `listRelatives -ad ($modName + "_MAINCtrl")`;
	$nurbsCurveShapes = `listRelatives -ad -type "nurbsCurve" ($modName + "_MAINCtrl")`;
	$nurbsCurves = `listRelatives -p $nurbsCurveShapes`;
	$joints = `ls -type "joint" $allNodes`;
	$constraints = `ls -type "constraint" $allNodes`;
	
	select $allNodes ($modName + "_MAINCtrl");
	//select -d $nurbsCurves $nurbsCurveShapes $joints $constraints;
	select -d $nurbsCurves $nurbsCurveShapes;
	$nonKeyableNodes = `ls -sl`;
	
	global string $gMainProgressBar;
	progressBar -edit
    	-beginProgress
    	-isInterruptable true
    	-status "Finishing up..."
    	-maxValue (`size $nonKeyableNodes`)
    	$gMainProgressBar;
    	
    $crntNum = 1;
    string $crntNode;
	for ($crntNode in $nonKeyableNodes)
	{
		if (`nodeType $crntNode` == "transform" || `nodeType $crntNode` == "ikHandle" || `nodeType $crntNode` == "effector")
		{
			setAttr -l 1 -k 0 ($crntNode + ".tx");
			setAttr -l 1 -k 0 ($crntNode + ".ty");
			setAttr -l 1 -k 0 ($crntNode + ".tz");
			setAttr -l 1 -k 0 ($crntNode + ".rx");
			setAttr -l 1 -k 0 ($crntNode + ".ry");
			setAttr -l 1 -k 0 ($crntNode + ".rz");
			setAttr -l 1 -k 0 ($crntNode + ".sx");
			setAttr -l 1 -k 0 ($crntNode + ".sy");
			setAttr -l 1 -k 0 ($crntNode + ".sz");
			setAttr -l 1 -k 0 ($crntNode + ".visibility");
		}
		if (`gmatch $crntNode "*Constraint*"`)
		{
			$keyableAttributes = `listAttr -lf -k -v $crntNode`;
			for ($crntAttribute in $keyableAttributes)
			{
				if (`attributeExists $crntAttribute $crntNode`)
				{
					setAttr -k 0 -l 1 ($crntNode + "." + $crntAttribute);
				}
			}
		}
		progressBar -edit -step 1 $gMainProgressBar;		
		$crntNum++;
	}
	progressBar -edit -endProgress $gMainProgressBar;
}


global proc RRM_SingleHierarchyInterface_V1(string $modName, int $rebuild, int $singleHierarchy)
{
	string $returnVal_SH_Generate;
	if ($rebuild == 0)
	{
		$returnVal_SH_Generate = `confirmDialog
		-title "Do you wish to Generate a Single Hierarchy Joint Set?"
			-message "A single hierarchy is only recommended for use in a game environment.\n-Some features may not work properly.\n-Joints do not stretch, but will maintain volume."
			-button "No"
			-button "Yes"
			-button "Yes, and Create Joint at Origin"
			-defaultButton "No"`;
	}
	else if ($singleHierarchy == 0)
	{
		$returnVal_SH_Generate = "No";
	}
	else if ($singleHierarchy == 1)
	{
		$returnVal_SH_Generate = "Yes";
	}
	else if ($singleHierarchy == 2)
	{
		$returnVal_SH_Generate = "Yes, and Create Joint at Origin";
	}
		
	
	if ($returnVal_SH_Generate == "Yes"||$returnVal_SH_Generate == "Yes, and Create Joint at Origin") 
	{
		print {"\nBUILDING \"" + $modName + "\" SINGLE HIERARCHY...\n"};

		select -hi RRM_MAIN;
		$hierarchy = `ls -sl -type "transform"`;
		string $topNodes[];
		string $crntNode;
           
		//SELECT TOP NODES			
		for ($crntNode in $hierarchy)
		{
		    if (`objExists ($crntNode + ".top")`)
		    {
		    $topNodes = `ls $crntNode $topNodes`;
		    }
		}
		//REORDER
		int $topNodesSize = `size $topNodes`;
		int $crntNum = $topNodesSize;
		
		string $reOrder[];
		while ($topNodesSize > 0)
		{
		$topNodesSize--;
		$reOrder = `ls $reOrder $topNodes[$topNodesSize]`;
		}
		
		//GENERATE RIG
		if ($returnVal_SH_Generate == "Yes")
		{
			RRM_GenerateRig_V1Root_V1SH_V1($modName);
		}
		else
		{
			RRM_GenerateRig_V1Root_V1MainSH_V1($modName);
		}
		string $topNode;
		for ($topNode in $reOrder)
		{
			$modType = `getAttr ($topNode + ".top")`;
			if ($modType == "spline")
			{
				RRM_GenerateRig_V1Spline_V1SH_V1($modName, $topNode);
			}
			else if ($modType == "arm")
			{
				RRM_GenerateRig_V1Arm_V1SH_V1($modName, $topNode);
			}
			else if ($modType == "leg")
			{
				RRM_GenerateRig_V1Leg_V1SH_V1($modName, $topNode);
			}
			else if ($modType == "fkChain")
			{
				RRM_GenerateRig_V1FkChain_V1SH_V1($modName, $topNode);
			}
			else if ($modType == "head")
			{
				RRM_GenerateRig_V1Head_V1SH_V1($modName, $topNode);
			}
			else if ($modType == "lookAt")
			{
				RRM_GenerateRig_V1LookAt_V1SH_V1($modName, $topNode);
			}
			else if ($modType == "auxiliary")
			{
				RRM_GenerateRig_V1Auxiliary_V1SH_V1($modName, $topNode);
			}
		}
		////ADD SCALE CONSTRAINT TO ENTIRE RIG
		//$allSHJnts = `listRelatives -ad -type "joint" ($modName + "_SHJntGrp")`;
		//for ($each in $allSHJnts)
		//{
		//	connectAttr -f ($modName + "_MAINCtrl.scale") ($each + ".scale"); 
		//}

		print "\nSINGLE HIERARCHY COMPLETED!\n";
	}
}


////////////////////////////////////////////////////////////////////////////////
//BUTTON PROC
////////////////////////////////////////////////////////////////////////////////
global proc RRM_GenerateRig_V1(string $modName, int $rebuild, int $singleHierarchy)
{
	if (`objExists RRM_MAIN`)
	{
		select -hi RRM_MAIN;
		$hierarchy = `ls -sl -type "transform"`;
		if (`size $hierarchy` > 2)
		{
			string $topNodes[];
			string $crntNode;

			//SELECT TOP NODES			
			for ($crntNode in $hierarchy)
			{
			    if (`objExists ($crntNode + ".top")`)
			    {
			    	$topNodes = `ls $crntNode $topNodes`;
			    }
			}
			
			int $nodeNum = `size $topNodes`;
			if ($nodeNum > 0)
			{
				//select $topNodes;
				
				global string $gMainProgressBar;
				progressBar -edit
    				-beginProgress
    				-isInterruptable true
    				-status "Generating Rig"
    				-maxValue ($nodeNum + 2)
    				$gMainProgressBar;
    			
				//REORDER
				$topNodesSize = `size $topNodes`;
				$crntNum = $topNodesSize;
				
				string $reOrder[];
				while ($topNodesSize > 0)
				{
					$topNodesSize--;
					$reOrder = `ls $reOrder $topNodes[$topNodesSize]`;
				}
				
				//GENERATE RIG
				RRM_GenerateRig_V1Root_V1($modName);
				string $topNode;
				int $shoulderCheck = 0;
				int $hipCheck = 0;
				for ($topNode in $reOrder)
				{
					$modType = `getAttr ($topNode + ".top")`;
					$moduleName = `getAttr ($topNode + ".core")`;
					if ($modType == "spline")
					{
						progressBar -edit -step 1 -status "Building Spline" $gMainProgressBar;
						RRM_GenerateRig_V1Spline_V1($modName, $moduleName, $topNode);
					}    
					else if ($modType == "arm")
					{
						progressBar -edit -step 1 -status "Building Arm" $gMainProgressBar;
						RRM_GenerateRig_V1Arm_V1($modName, $moduleName, $topNode);
						$shoulderCheck = 1;
					}
					else if ($modType == "leg")
					{
						progressBar -edit -step 1 -status "Building Leg" $gMainProgressBar;
						RRM_GenerateRig_V1Leg_V1($modName, $moduleName, $topNode);
						$hipCheck = 1;
					}
					else if ($modType == "fkChain")
					{
						progressBar -edit -step 1 -status "Building FK Chain" $gMainProgressBar;
						RRM_GenerateRig_V1FkChain_V1($modName, $moduleName, $topNode);
					}
					else if ($modType == "head")
					{
						progressBar -edit -step 1 -status "Building Head" $gMainProgressBar;
						RRM_GenerateRig_V1Head_V1($modName, $moduleName, $topNode);
					}
					else if ($modType == "lookAt")
					{
						progressBar -edit -step 1 -status "Building Look-At" $gMainProgressBar;
						RRM_GenerateRig_V1LookAt_V1($modName, $moduleName, $topNode);
					}
					else if ($modType == "auxiliary")
					{
						progressBar -edit -step 1 -status "Building Auxiliary" $gMainProgressBar;
						RRM_GenerateRig_V1Auxiliary_V1($modName, $moduleName, $topNode);
					}
						
					//ADD MIRROR OBJECT ATTRIBUTE
					RRM_MirrorAttributes_V1($modName, $moduleName);
					select -cl;
					refresh;
				}
				
				$modControls = `ls -type "transform" ($modName + "_*Ctrl")`;
				
				//ADD RIG NAME TO CONTROLS
				RRM_AddRigName_V1($modName, $modControls);
				
				//ADD CORE CONTROL NAME
				RRM_ControlName_V1($modName, $modControls);
				
				//ADD CONTROL SIZE TO CONTROLS
				RRM_AddControlsSize_V1($modControls);
				
				//CREATE LAYERS
				//LAYER
				progressBar -edit -step 1 -status "Setting up Controls Layer" $gMainProgressBar;
				
				createDisplayLayer -n ($modName + "_ControlsLayer") -number 1 -empty;
				
				select ($modName + "_*Ctrl");
				select -d ($modName + "_MAINCtrl");
				editDisplayLayerMembers -noRecurse ($modName + "_ControlsLayer") `ls -sl`;
				
				
				progressBar -edit -step 1 -status "Setting up Joints Layer" $gMainProgressBar;
				createDisplayLayer -n ($modName + "_JointsLayer") -number 1 -empty;	
				select ($modName + "_*Jnt");
				if ($shoulderCheck == 1)
				{
					select -d -hierarchy ($modName + "*ShoulderJnt");
				}
				if ($hipCheck == 1)
				{
					if (`objExists ($modName + "*KneeJnt")`)
					{
						select -d -hierarchy ($modName + "*KneeJnt");
					}
					else
					{
						select -d -hierarchy ($modName + "*Knee1Jnt");
					}
				}
				
				editDisplayLayerMembers -noRecurse ($modName + "_JointsLayer") `ls -sl`;
				
				progressBar -edit -endProgress $gMainProgressBar;
				//MAKE ALL NODES UNKEYABLE
				RRM_LockAndHideNonModNodes_V1($modName);
				select -cl;
				refresh;
				RRM_SingleHierarchyInterface_V1($modName, $rebuild, $singleHierarchy);
				
				select ($modName + "_MAINCtrl");
			}
			else
			{
			string $returnVal_Generate = `confirmDialog
			-title "Your Rig Has No Modules"
			-message "You must create modules and attach them to your rig.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
			}
		}
		else
		{
			string $returnVal_Generate = `confirmDialog
			-title "Your Rig Has No Modules"
			-message "You must create modules and attach them to your rig.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
		}
	}
	else
	{
		string $returnVal_Generate = `confirmDialog
		-title "No Rig Exists"
		-message "You must first create a Proxy rig to RRM_Generate a final rig from.\n"
		-button "OK"
		-defaultButton "OK"
		-cancelButton "OK"
		-icon "critical"`;
	}
	if (`objExists ($modName + "_MAINCtrl")`)
	{
		lockNode ($modName) ($modName + "_MAINCtrl") ($modName + "_ROOTSecondaryCtrl");
		select ($modName + "_MAINCtrl");
	}
	
	////SET UNITS BACK
	//if ($crntUnit != "cm")
	//{
	//	//changeLinearUnit "centimeter"
	//}
	//changeLinearUnit $crntUnit;
}

///PROMPTS
global proc RRM_GenerateRig_V1Prompts_V1(string $modName)
{
	int $modNameSize = `size $modName`;

	if ($modNameSize == "0")
	{
		string $returnVal_Generate = `confirmDialog
			-title "Module Needs a Name"
			-message "You must enter a name for the rig in character Name text field.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (! RRM_CheckName_V1($modName))
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Rig's Name is Invalid"
			-message "A valid name must begin with a letter.\n    The rest of the name may only contain\nletters and/or numbers.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else if (`objExists ($modName)`)
	{
		string $returnVal_Generate = `confirmDialog
			-title "The Rig's Name is not Unique"
			-message "A rig already exists with that name.\nYou must create a unique name.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
	}
	else
	{
		//CHECK IF NODE EDITOR IS OPEN
		string $nodeEditor[] = `getPanel -scriptType nodeEditorPanel `;
		
		for ($editor in $nodeEditor )
		{
			string $tokens[];
			string $control = `scriptedPanel -q -ctl $editor`;
		
			if ( $control != "" )
			{
				if ( 0 < `tokenize $control "|" $tokens` )
				{
					print ( "Window for Node Editor: " + $tokens[0] + "\n" );
				  
					string $NodeEditorUI = `confirmDialog
						-title "Close Node Editor Before Proceeding?"
						-message "The Node Editor is open.\nGenerating a rig with the node editor opened will cause the rig to take much longer to RRM_Generate \n"
						-button "Close Node Editor"
						-button "Ignore"
						-button "Cancel"
						-defaultButton "Close Node Editor"
						-dismissString "Ignore"
						-cancelButton "Ignore"`;
						//-icon "critical"`;
						
					if ($NodeEditorUI == "Close Node Editor")
					{
						deleteUI -window $tokens[0];
					}
				}
		  	}
		}
		
		RRM_GenerateRig_V1($modName, 0, 0);
		if (`objExists ($modName + "_MAINCtrl")`)
		{
			RRM_ColorControls_V1($modName);
			if (`objExists RRM_ProxiesLayer`)
			{
				setAttr RRM_ProxiesLayer.visibility 0;
			}
		}
	}
	//LOAD RIG NAME INTO TEXT FIELD
	textFieldButtonGrp -e -tx $modName RRM_LoadRig_V1TextFieldButtonGrp;
	
	select -cl;
}

///////DEPENDENCIES
global proc RRM_ElbowNumLock_V1()
{
	$crntSetting = `radioButtonGrp -q -select RRM_ElbowJoints`;
	if ($crntSetting == 1)
	{
		intSliderGrp -e -enable 0 RRM_ElbowNum;
	}
	else
	{
		intSliderGrp -e -enable 1 RRM_ElbowNum;
	}
}

global proc RRM_KneeNumLock_V1()
{
	$crntSetting = `radioButtonGrp -q -select RRM_KneeJoints`;
	if ($crntSetting == 1)
	{
		intSliderGrp -e -enable 0 RRM_KneeNum;
	}
	else
	{
		intSliderGrp -e -enable 1 RRM_KneeNum;
	}
}

global proc RRM_ElbowEditNumLock_V1()
{
	$crntSetting = `radioButtonGrp -q -select RRM_ElbowEditJoints`;
	if ($crntSetting == 1)
	{
		intSliderGrp -e -enable 0 RRM_ElbowEditNum;
	}
	else
	{
		intSliderGrp -e -enable 1 RRM_ElbowEditNum;
	}
}

global proc RRM_KneeEditNumLock_V1()
{
	$crntSetting = `radioButtonGrp -q -select RRM_KneeEditJoints`;
	if ($crntSetting == 1)
	{
		intSliderGrp -e -enable 0 RRM_KneeEditNum;
	}
	else
	{
		intSliderGrp -e -enable 1 RRM_KneeEditNum;
	}
}

global proc RRM_ToggleTemplate_V1()
{
	$crntSetting = `checkBox -q -v RRM_TemplateCheckBox`;
	if ($crntSetting == 1)
	{
		optionMenu -e -enable 1 RRM_TemplateType;
		button -e -label "Create Template Proxy Rig" RRM_CreateProxyMainProxy_V1;
	}
	else
	{
		optionMenu -e -enable 0 RRM_TemplateType;
		button -e -label "Create New Proxy Rig" RRM_CreateProxyMainProxy_V1;
	}
}

global proc RRM_ToggleTransferParent_V1()
{
	$crntSetting = `radioButtonGrp -q -select RRM_TransferSelectionButton`;
	if ($crntSetting == 1)
	{
		checkBox -e -enable 0 RRM_TransferParent;
	}
	else
	{
		checkBox -e -enable 1 RRM_TransferParent;
	}
}

//DELETE PROXY RIG
global proc RRM_DeleteProxyRig_V1()
{
	if (`objExists RRM_MAIN`)
	{
		string $confirmDeleteProxies = `confirmDialog
			-title "Delete Proxies"
			-message "Are you sure you want to delete your proxy rig?\n"
			-button "Delete Proxies"
			-button "Cancel"
			-defaultButton "Cancel"
			-dismissString "Cancel"
			-cancelButton "Cancel"`;
			//-icon "critical"`;
			
		if ($confirmDeleteProxies == "Delete Proxies")
		{
			if (`objExists RRM_MAIN`)
			{
				select -hi RRM_MAIN;
				$rigHierarchy = `ls -sl`;
				lockNode -lock off $rigHierarchy;
				delete RRM_MAIN;
				
				if (`objExists RRM_ProxiesLayer`)
				{
					delete RRM_ProxiesLayer;
				}
			}
		}
	}
	else
	{
		warning "A proxy rig (that is not referenced) does not exist in this scene.";
	}
}


//STANDARD JOINT SELECTION
global proc RRM_SelectStandardJoints_V1(string $modName)
{
	select ($modName + "_*Jnt");
	if (`objExists ($modName + "_ROOTSHJnt")`)
	{
		select -d ($modName + "_*SHJnt");
	}
	$allStandardJoints = `ls -sl`;
	string $skinningJoints[];
	for ($each in $allStandardJoints)
	{
		$drawStyle = `getAttr ($each + ".drawStyle")`;
		$visibility = `getAttr ($each + ".visibility")`;

		if ($drawStyle == 0 && $visibility == 1)
		{
			$skinningJoints = `ls $skinningJoints $each`;
		}
	}
	select $skinningJoints;
}

//SINGLE HIERARCHY JOINT SELECTION
global proc RRM_SelectSingleHierarchyJoints_V1(string $modName)
{
	select ($modName + "_*SHJnt");
}


///SELECT JOINTS
global proc RRM_LoadRig_V1()
{
	$selection = `ls -sl`;
	if (`size $selection` > 0)
	{
		if (`objExists ($selection[0] + ".modRigConnection")`)
		{
			//$rigName = `getAttr ($selection[0] + ".modRigConnection")`;
			string $modRigConnections[] = `listConnections ($selection[0] + ".modRigConnection")`;
			string $modRigName = $modRigConnections[0];
			textFieldButtonGrp -e -tx $modRigName RRM_LoadRig_V1TextFieldButtonGrp;
		}
		else
		{warning "Selected Object is not a Rapid Rig Modular Control";}
	}
	else
	{warning "Nothing Selected. Please Select a Rapid Rig Modular Control";}
}

global proc RRM_SelectJoints_V1(string $modName)
{
	if (`objExists ($modName + "_ROOTSHJnt")`)
	{
		string $returnVal_Skin = `confirmDialog
		-title "Select Skinning Joints"
		-message "Which joints do you wish to select?"
		-button "Standard"
		-button "Single Hierarchy"
		-button "Cancel"
		-defaultButton "Cancel"
		-cancelButton "Cancel"`;
	
		if ($returnVal_Skin == "Standard")
		{
			RRM_SelectStandardJoints_V1($modName);
			print "STANDARD JOINTS SELECTED! NOW SELECT THE GEOMETRY YOU WANT TO ATTACH TO THE RIG.\n";
		}
	
		if ($returnVal_Skin == "Single Hierarchy")
		{
			RRM_SelectSingleHierarchyJoints_V1($modName);
			print "SINGLE HIERARCHY JOINTS SELECTED! NOW SELECT THE GEOMETRY YOU WANT TO ATTACH TO THE RIG.\n";
		}
	}
	else if (`objExists ($modName + "_ROOTJnt")`)
	{
		RRM_SelectStandardJoints_V1($modName);
		print "SUCCESS! NOW SELECT THE GEOMETRY YOU WANT TO ATTACH TO THE RIG.\n";		
	}
	else
	{
		error "NO JOINTS HAVE BEEN CREATED YET!\n";
	}
}

global proc RRM_CreateCharacterSet_V1(int $subCharSet)
{
	$selection = `ls -sl`;
	if (`size $selection` == 1)
	{
		//CHECK IF MAINC IS SELECTED
		if (`objExists ($selection[0] + ".isMain")`)
		{
			//CREATE CHARACTER SET
			$rigName = `getAttr ($selection[0] + ".modRigName")`;
			if (!`objExists ($rigName + "_CharSet")`)
			{
				character -em -name ($rigName + "_CharSet") -excludeVisibility;
				if ($subCharSet == 0)
				{
					$curveHierarchy = `listRelatives -ad -type "nurbsCurve" $selection[0]`;
					$hierarchy = `listRelatives -p $curveHierarchy`;
					for ($each in $hierarchy)
					{
						if (`objExists ($each + ".modControlName")` && !`objExists ($each + ".nonControl")`)
						{
							character -add ($rigName + "_CharSet") $each;
							print ("Adding \"" + $each + "\" to " + ($rigName + "_CharSet") + ".\n");
						}
					}
				}
				else
				{
					//CREATE SUB CHARACTER SETS
					select -hi $selection[0];
					$hierarchy = `ls -sl -type "transform"`;
					$hierarchy = `listRelatives -ad -type "transform" $selection[0]`;
					
					//FIND MODULE TOP GROUPS
					$children = `listRelatives -c $selection[0]`;
					string $modules[];
					for ($eachChild in $children)
					{
						if (`objExists ($eachChild + ".topNode")`)
						{
							$modules = `ls $modules $eachChild`;
						}
					}					
					
					for ($each in $modules)
					{
						int $i;
						character -em -name ($each + "_CharSet") -excludeVisibility;
						character -add ($rigName + "_CharSet") ($each + "_CharSet");
						
						$curveHierarchy = `listRelatives -ad -type "nurbsCurve" $selection[0]`;
						$hierarchy = `listRelatives -p $curveHierarchy`;
						for ($eachControl in $hierarchy)
						{
							if (`objExists ($eachControl + ".modControlName")` && !`objExists ($eachControl + ".nonControl")`)
							{
								$existingChar = `listConnections -d 0 -t "character" $eachControl`;
								$charSize = `size $existingChar`;
								if ($charSize == 0)
								{
									character -add ($each + "_CharSet") $eachControl;
									print ("Adding \"" + $eachControl + "\" to " + ($each + "_CharSet") + ".\n");
								}
							}
						}
					}
				}
			}
			else
			{
				warning ("A character set already exists for \"" + $rigName + "\".");
			}
		}
	}
	else if (`size $selection` > 1)
	{
		warning "Please select only the MAINC of your rig";
	}
	else
	{
		warning "You must select the MAINC of your rig";
	}
	select $selection;
}



//////////////////////////REBUILD RIG////////////////////////////////////////

global proc string[] RRM_SavePose_V1(string $modRigName)
{
	$controls = `listRelatives -ad -type "transform" ($modRigName + "_MAINCtrl")`;
	$controls = `ls $modRigName $controls`; 
	string $ctrlVals[];
	$i = 0;
	for ($ctrl in $controls)
	{
		if (`objExists ($ctrl + ".modRigName")`)
		{
			if (`getAttr -lock ($ctrl + ".tx")` == 0 && `getAttr ($ctrl + ".tx")` != 0)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".tx\" " + `getAttr ($ctrl + ".tx")` + ";");
				$i++;
			}
			if (`getAttr -lock ($ctrl + ".ty")` == 0 && `getAttr ($ctrl + ".ty")` != 0)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".ty\" " + `getAttr ($ctrl + ".ty")` + ";");
				$i++;
			}
			if (`getAttr -lock ($ctrl + ".tz")` == 0 && `getAttr ($ctrl + ".tz")` != 0)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".tz\" " + `getAttr ($ctrl + ".tz")` + ";");
				$i++;
			}

			if (`getAttr -lock ($ctrl + ".rx")` == 0 && `getAttr ($ctrl + ".rx")` != 0)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".rx\" " + `getAttr ($ctrl + ".rx")` + ";");
				$i++;
			}
			if (`getAttr -lock ($ctrl + ".ry")` == 0 && `getAttr ($ctrl + ".ry")` != 0)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".ry\" " + `getAttr ($ctrl + ".ry")` + ";");
				$i++;
			}
			if (`getAttr -lock ($ctrl + ".rz")` == 0 && `getAttr ($ctrl + ".rz")` != 0)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".rz\" " + `getAttr ($ctrl + ".rz")` + ";");
				$i++;
			}

			if (`getAttr -lock ($ctrl + ".sx")` == 0 && `getAttr ($ctrl + ".sx")` != 1)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".sx\" " + `getAttr ($ctrl + ".sx")` + ";");
				$i++;
			}
			if (`getAttr -lock ($ctrl + ".sy")` == 0 && `getAttr ($ctrl + ".sy")` != 1)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".sy\" " + `getAttr ($ctrl + ".sy")` + ";");
				$i++;
			}
			if (`getAttr -lock ($ctrl + ".sz")` == 0 && `getAttr ($ctrl + ".sz")` != 1)
			{
				$ctrlVals[$i] = ("setAttr " + "\"" + $ctrl + ".sz\" " + `getAttr ($ctrl + ".sz")` + ";");
				$i++;
			}

		}
	}
	return $ctrlVals;
}

global proc RRM_RebuildRig_V1()
{
	//GET RIG NAME
	$selection = `ls -sl`;
	if (`size $selection` > 0)
	{
		//MAKE SURE A PROXY RIG EXISTS
		if (`objExists "RRM_MAIN"`)
		{
			if (`objExists ($selection[0] + ".modRigName")`)
			{
				$modRigName = `getAttr ($selection[0] + ".modRigName")`;
				
				string $result = `confirmDialog -title "Rebuild Rig"
					-message "Are you sure you want to rebuild?\nThis is not undoable and all animation will be lost."
					-button "Yes" -button "Cancel" -defaultButton "Yes"
					-cancelButton "Cancel" -dismissString "Cancel"`;
    
    			if ($result == "Yes")
				{
					//CLOSE NODE EDITOR
					string $nodeEditor[] = `getPanel -scriptType nodeEditorPanel `;
					
					for ($editor in $nodeEditor )
					{
						string $tokens[];
						string $control = `scriptedPanel -q -ctl $editor`;
					
						if ( $control != "" )
						{
							if ( 0 < `tokenize $control "|" $tokens` )
							{
								deleteUI -window $tokens[0];
							}
						}
					}
					
					//SAVE WEIGHTS
					//GET SKIN CLUSTERS
					RRM_SelectStandardJoints_V1($modRigName);
					$stJoints = `ls -sl`;
					string $shJoints[];
					if (`objExists ($modRigName + "_ROOTSHJnt")`)
					{
						RRM_SelectSingleHierarchyJoints_V1($modRigName);
						$shJoints = `ls -sl`;
						select $stJoints;
					}
					if (`size $shJoints` > 0)
					{
						select -add $shJoints;
					}
					$allJnts = `ls -sl -type "joint"`;
					$skinClusters = `listConnections -d 1 -s 0 -type "skinCluster" $allJnts`;
					$allSkinClusters = stringArrayRemoveDuplicates($skinClusters);
					select $allSkinClusters;
					
					string $geomBind[];
					string $geomClusters[];
					if (`getApplicationVersionAsFloat` >= 2015)
					{
						$geomBind = `listConnections -d 0 -s 1 -type "geomBind" $skinClusters`;
						select $geomBind;
						$geomBind = `ls -sl`;
						$geomClusters = `listConnections -d 1 -s 0 -type "skinCluster" $geomBind`;
						select $geomClusters;
						$geomClusters = `ls -sl`;
						//print ("geomBind are ");
						//print $geomBind
						//print "\n";
						//print ("geomClusters are ");
						//print $geomClusters;
						//print "\n";
						select $allSkinClusters;
						select -d $geomClusters;
					}
					$skinClusters = `ls -sl`;
					
					string $skinPercentCommand[];
					string $skinnedMesh[];
					string $skinningCommand[];
					

					$skinNum = 0;
					
					//SAVE WEIGHTS
					for ($cluster in $allSkinClusters)
					{
						//GET THE MESHES ASSOCIATED WITH THE SKIN CLUSTERS
						$skinnedMesh = `listConnections -d 1 -s 0 -type "mesh" $cluster`;
						
						//FOR MESH IN SKINNEDMESH:
						for ($mesh in $skinnedMesh)
						{
							//#GET ALL THE VERTICES
							$verts = `polyEvaluate -vertex $mesh`;
							int $v = 0;
							while ($v < $verts[0])
							{
								$skinInfluence = `skinPercent -q -t $cluster ($mesh + ".vtx[" + $v + "]")`;
								$skinWeight = `skinPercent -q -v $cluster ($mesh + ".vtx[" + $v + "]")`;
								
								//#DEFINE THE COMMAND STRING PER VERTEX
								$skinPercentCommand[$skinNum] = ("skinPercent" );
								$infNum = 0;
								for ($inf in $skinInfluence)
								{
									$skinPercentCommand[$skinNum] = ($skinPercentCommand[$skinNum] + " -transformValue \"" + $skinInfluence[$infNum] + "\" " + $skinWeight[$infNum]);
									$infNum ++;
									
									//if ($infNum < `size $skinInfluence`)
									//{
									//	$skinPercentCommand[$v] = ($skinPercentCommand[$v] + " ");
									//}
								}
								$skinPercentCommand[$skinNum] = ($skinPercentCommand[$skinNum] + " \"" + $cluster + "\" \"" + $mesh + ".vtx[" + $v + "]\";");
								$v++;
								$skinNum++;
							}
						}
						//$skinNum++;
					}
					//print $skinPercentCommand;
					//select "break";
					
					$skinNum = 0;
					
					//SAVE SKIN CLUSTER DATA
					for ($cluster in $skinClusters)
					{
						//GET THE MESHES ASSOCIATED WITH THE SKIN CLUSTERS
						$skinnedMesh = `listConnections -d 1 -s 0 -type "mesh" $cluster`;
						
						
						//CREATE COMMAND FOR GENERATING SKIN CLUSTER
						//$skinningCommand[$skinNum] = ("select ");
						//FOR MESH IN SKINNEDMESH:
						for ($mesh in $skinnedMesh)
						{
							$skinningCommand[$skinNum] = ("select " + $mesh + " ");
						}
						//GET ALL THE JOINTS ASSOCIATED WITH THE SKIN CLUSTER
						$joints = `listConnections -d 0 -s 1 -type "joint" $cluster`;
						for ($jnt in $joints)
						{
							$skinningCommand[$skinNum] = ($skinningCommand[$skinNum] + $jnt + " "); 
						}
						$skinningCommand[$skinNum] = ($skinningCommand[$skinNum] + ";");
							
						//QUERY SKIN CLUSTER SETTINGS
						$skMthd = `skinCluster -q -skinMethod $cluster`;
						$nrml = `skinCluster -q -nw $cluster`;
						$mxInfNum = `skinCluster -q -mi $cluster`;
						$mxInfChk = `skinCluster -q -obeyMaxInfluences $cluster`;

							
						if (`getApplicationVersionAsFloat` >= 2013)
						{
							$bndMthd = `skinCluster -q -bindMethod $cluster`;
							//$wtDist = `skinCluster -q -weightDistribution $cluster`;
							//if ($bindMthd != 3)
							//{
								$skinningCommand[$skinNum] = ($skinningCommand[$skinNum] + ("skinCluster -n " + $cluster + " -bindMethod " + $bndMthd + " -skinMethod " + $skMthd + " -toSelectedBones " + " -nw " + $nrml + " -mi " + $mxInfNum + ";"));
							//}
							//else
							//{
							//	$skinningCommand[$skinNum] = ($skinningCommand[$skinNum] + ("skinCluster -n " + $cluster + " -bindMethod 0 -skinMethod " + $skMthd + " -toSelectedBones " + " -nw " + $nrml + " -mi " + $mxInfNum + ";"));
							//	$geomBinds = `listConnections -s 1 -d 0 -type "geomBind" $cluster;
							//}
							
						}
						else
						{
							$skinningCommand[$skinNum] = ($skinningCommand[$skinNum] + ("skinCluster -n " + $cluster + " -skinMethod " + $skMthd + " -toSelectedBones " + " -nw " + $nrml + " -mi " + $mxInfNum + ";"));
						}
						$skinNum++;
					}
					//SAVE SKINNING DATA FOR GEODESIC CLUSTERS
					if (`size $geomClusters` > 0)
					{
						for ($gBnd in $geomBind)
						{
							$gBndClusters = `listConnections -d 1 -s 0 -type "skinCluster" $gBnd`;
							string $clstrString;
							int $mxInfNum;
							for ($clstr in $gBndClusters)
							{
								$joints = `listConnections -s 1 -d 0 -type "joint" $clstr`;
								//print ("\n" + $clstr + " joints are ");
								//print $joints;
								//print ("jointSize is " + `size $joints`);
								
								$skMthd = `skinCluster -q -skinMethod $clstr`;
								$nrml = `skinCluster -q -nw $clstr`;
								$mxInfNum = `skinCluster -q -mi $clstr`;
								$mxInfChk = `skinCluster -q -obeyMaxInfluences $clstr`;
								string $transform[] = `listConnections -d 1 -s 0 $clstr`;
								$transform = `ls -type "transform" $transform`;
								
								string $transformString;
								for ($tForm in $transform)
								{
									$transformString = ($transformString + " " + $tForm);
								}
								
								if (`size $joints` != 0)
								{
									string $jointString;
									for ($jnt in $joints)
									{
										$jointString = ($jointString + " " + $jnt);
									}
									
									$skinningCommand[$skinNum] = ("select " + $transformString + " " + $jointString + "; skinCluster -n " + $clstr + " -skinMethod " + $skMthd + " -toSelectedBones " + " -nw " + $nrml + " -mi " + $mxInfNum + ";");
									//$skinningCommand[$skinNum] = ("select " + $transformString + " " + $jointString + "; skinCluster " + " -skinMethod " + $skMthd + " -toSelectedBones " + " -nw " + $nrml + " -mi " + $mxInfNum + ";");

									//$geoRez = `geomBind -q -gvp $gBnd`;
									//$skinningCommand[$skinNum] = ($skinningCommand[$skinNum] + "geomBind -bm 3 -mi " + $mxInfNum + " -gvp " + $geoRez + " " + $clstr + ";");
									
									$clstrString = ($clstrString + " " + $clstr);
								}
								else
								{
									$skinningCommand[$skinNum] = ("warning (\"The skin cluster " + $clstr + " has no influences. " + $transformString + " will not be skinned.\");");
								}
								$skinNum++;
							}
							//for ($clstr in $gBndClusters)
							//{
							//	$clstrString = ($clstrString + " " + $clstr);
							//}
							
							// ......THIS SHOULD BE USED........
							//$geoRez = `geomBind -q -gvp $gBnd`;
							//$skinningCommand[$skinNum] = ($skinningCommand[$skinNum] + "geomBind -bm 3 -mi " + $mxInfNum + " -gvp " + $geoRez + " " + $clstrString + ";");
							//..................................
							////FIND TRANSFORM ASSOCIATED WITH THE ORIGINAL CLUSTERS
							//for ($clstr in $gBndClusters)
							//{
							//	string $transform[] = `listConnections -d 1 -s 0 $clstr`;
							//	$skinningCommand[$skinNum] = ($skinningCommand[$skinNum] + "$clstr = `listConnections -s 1 -d 0 -type \"skinCluster\" " + $transform[0] + "`;");
							//	$skinningCommand[$skinNum] = ($skinningCommand[$skinNum] + "rename $clstr[0] " + $clstr + ";");
							//}
							$skinNum++;
						}
					}
					//print $skinningCommand;
					//select "break";
					
					//CHECK FOR SINGLE HIERARCHY
					$singleHierarchy = 0;
					if (`objExists ($modRigName + "_ROOTSHJnt")`)
					{
						$singleHierarchy = 1;
					}
					if (`objExists ($modRigName + "_MAINSHJnt")`)
					{
						$singleHierarchy = 2;						
					}
					
					//SAVE POSE
					string $pose[] = RRM_SavePose_V1($modRigName);
					
					//DELETE RIG
					RRM_DeleteRig_V1($modRigName, 0);
					
					//REBUILD RIG

					print "\nRebuilding Rig...\n";
					RRM_GenerateRig_V1($modRigName, 1, $singleHierarchy);
					{
						RRM_ColorControls_V1($modRigName);
						if (`objExists RRM_ProxiesLayer`)
						{
							setAttr RRM_ProxiesLayer.visibility 0;
						}
					}					
					
					//SKIN AND REAPPLY WEIGHTS
					print "\nApplying Skin Weights.";
					for ($cmd in $skinningCommand)
					{
						//print $cmd;
						eval $cmd;
					}
					for ($skin in $skinPercentCommand)
					{
						//print $skin;
						eval $skin;
					}
					
					//APPLY POSE
					for ($pos in $pose)
					{
						eval $pos;
					}
					select ($modRigName + "_MAINCtrl");
					print ("\nSuccess! \"" + $modRigName + "\" has been rebuilt.");
				}
			}
			else
			{
				warning "The selected node needs to be a RRM control.";
			}
		}
		else
		{
			warning "There is no proxy rig in this scene to rebuild the rig from.";
		}
	}
	else
	{
		warning "Nothing Selected. Please select a control of the rig you wish to rebuild.";
	}
}
	
	
//////////////////////////CONTROLLER RESIZING////////////////////////////////////////
global proc RRM_ControlEnableDisableMirror_V1()
{
    $checkVal = `radioButtonGrp -q -select RRM_ControlScale_V1Selection`;
    if ($checkVal == 3)
    {
        checkBox -edit -en 0  RRM_ControlMirror;
    }
    else
    {
        checkBox -edit -en 1  RRM_ControlMirror;
    }
}
global proc RRM_ControlEnableDisableUniformScales_V1()
{
    $checkVal = `checkBox -q -value RRM_ControlUniformScale`;
    if ($checkVal == 0)
    {
        checkBoxGrp -edit -en1 1 -en2 1 -en3 1 RRM_ControlScale_V1Axes;
    }
    else if ($checkVal == 1)
    {
        checkBoxGrp -edit -en1 0 -en2 0 -en3 0 RRM_ControlScale_V1Axes;
    }
}



global proc RRM_ControlScale_V1(float $RRM_ControlScale_V1Change, int $selectionType, int $modScaleMirror, int $modUniformScaleAxes, int $RRM_ControlScale_V1Axis1, int $RRM_ControlScale_V1Axis2, int $RRM_ControlScale_V1Axis3)
{
	//GO THROUGH CURVES
	$selection = `ls -sl`;
	$controls = `ls -sl`;
	//string $controls[];
	string $tempControls[];
	string $modRigName;
	string $each;
	
	if (`size $selection` > 0)
	{
		for ($each in $selection)
		{
			if (`objExists ($selection[0] + ".modRigName")`)
			{
				$modRigName = `getAttr ($each + ".modRigName")`; 
				if ($selectionType == 1 && $modScaleMirror == 1)
				{
					if ($modScaleMirror == 1)
					{
						if (`objExists ($each + ".rightControl")`)
						{
							$oppControl = `getAttr ($each + ".rightControl")`;
							$oppControl = ($modRigName + $oppControl);
							$controls = `ls $controls $oppControl`;
						}
						else if (`objExists ($each + ".leftControl")`)
						{
							$oppControl = `getAttr ($each + ".leftControl")`;
							$oppControl = ($modRigName + $oppControl);
							$controls = `ls $controls $oppControl`;
						}
					}
				}
				else if ($selectionType == 2)
				{
					for ($each in $selection)
					{
						if (`objExists ($each + ".modRigName")`)
						{
							$modRigName = `getAttr ($each + ".modRigName")`; 
							//GET BRANCHES
							$coreName = `getAttr ($each + ".modCoreName")`;
							$crntBranch = ($modRigName + $coreName + "Grp");
							$controls = `ls $controls $crntBranch`;
							//GET MIRRORED BRANCHES
							if ($modScaleMirror == 1)
							{
								if (`objExists ($each + ".rightControl")`)
								{
									$oppControl = `getAttr ($each + ".rightControl")`;
									$oppCoreName = `getAttr ($modRigName + $oppControl + ".modCoreName")`;
									$oppBranch = ($modRigName + $oppCoreName + "Grp");
									$controls = `ls $controls $oppBranch`;
								}
								else if (`objExists ($each + ".leftControl")`)
								{
									$oppControl = `getAttr ($each + ".leftControl")`;
									$oppCoreName = `getAttr ($modRigName + $oppControl + ".modCoreName")`;
									$oppBranch = ($modRigName + $oppCoreName + "Grp");
									$controls = `ls $controls $oppBranch`;
								}
							}
						}
					}
				}
				else if ($selectionType == 3)
				{
					for ($each in $selection)
					{
						if (`objExists ($each + ".modRigName")`)
						{
							$modRigName = `getAttr ($each + ".modRigName")`; 
							//GET RIG NAMES
							$controls = `ls $controls $modRigName`;
						}
					}
				}
			}
			else
				{warning ($each + " IS NOT A VALID CONTROL. SKIPPING.");}
		}
	}
	else
		{warning "NOTHING SELECTED. PLEASE SELECT A VALID RRM CONTROL";}

				
	if ($selectionType == 2||$selectionType == 3)
	{
		select -hi $controls;
		$controlsHierarchy = `ls -sl -type "nurbsCurve"`;
		select $controlsHierarchy;
		pickWalk -d up;
		$controls = `ls -sl`;
		for ($each in $controls)
		{
			if (!`objExists ($each + ".nonControl")`)
			{
				$tempControls = `ls $tempControls $each`;
			}
		}
		$controls = `ls $tempControls`;
	}
				
	for ($each in $controls)
	{
		//CHECK NODE TYPE
		if (`objExists ($each + ".modRigName")`)
		{
			//SCALE
			float $controlScaleX = 1;
			float $controlScaleY = 1;
			float $controlScaleZ = 1;
			if ($modUniformScaleAxes == 1)
			{
				$controlScaleX = $RRM_ControlScale_V1Change;
				$controlScaleY = $RRM_ControlScale_V1Change;
				$controlScaleZ = $RRM_ControlScale_V1Change;
			}
			else
			{
				if ($RRM_ControlScale_V1Axis1 == 1)
				{
					$controlScaleX = $RRM_ControlScale_V1Change;
				}
				if ($RRM_ControlScale_V1Axis2 == 1)
				{
					$controlScaleY = $RRM_ControlScale_V1Change;
				}
				if ($RRM_ControlScale_V1Axis3 == 1)
				{
					$controlScaleZ = $RRM_ControlScale_V1Change;
				}
			}
			//GET SHAPES
			$worldSpace = `xform -q -ws -rp $each`;
			$curveShapes = `listRelatives -shapes $each`;
			string $eachShape;
			for ($eachShape in $curveShapes)
			{
				$cvs = `ls ($eachShape + ".cv[*]")`;
				if (!`objExists ($each + ".kneeLock")`)
				{
					scale -r -p $worldSpace[0] $worldSpace[1] $worldSpace[2] $controlScaleX $controlScaleY $controlScaleZ $cvs;
				}
				else
				{
					scale -r -p $worldSpace[0] 0 $worldSpace[2] $controlScaleX $controlScaleY $controlScaleZ $cvs;
				}						
			}
			//UPDATE SIZE ATTRIBUTE
			setAttr -l false ($each + ".controlSizeX");
			setAttr -l false ($each + ".controlSizeY");
			setAttr -l false ($each + ".controlSizeZ");
			float $valX = `getAttr ($each + ".controlSizeX")`;
			float $valY = `getAttr ($each + ".controlSizeY")`;
			float $valZ = `getAttr ($each + ".controlSizeZ")`;
			setAttr ($each + ".controlSizeX") ($valX * $controlScaleX);
			setAttr ($each + ".controlSizeY") ($valY * $controlScaleY);
			setAttr ($each + ".controlSizeZ") ($valZ * $controlScaleZ);
			setAttr -l true ($each + ".controlSizeX");
			setAttr -l true ($each + ".controlSizeY");
			setAttr -l true ($each + ".controlSizeZ");
		}
	}
	select $selection;
}


//////////////////////////SAVE CONTROL SHAPES////////////////////////////////////////
global proc RRM_WriteControlShapes_V1()
{
	$initialSelection = `ls -sl`;
	$controls = `ls -sl -type "transform"`;
	if (`size $controls` > 0)
	{
		//GET ALL CONTROLS
		if (`objExists ($controls[0] + ".modRigName")`)
		{
			int $mayaVer = `about -version`;
			string $mayaFolder;
			string $fileName[];		
				
			if ($mayaVer > 2011)
			{
				$fileFilter = "RRM Proxy Transforms (.rrmctrl) (*.rrmctrl)";
				$fileName = `fileDialog2 -cap "Save Control Shapes & Colors" -fileFilter $fileFilter -selectFileFilter $fileFilter`;
				if ($fileName[0] != "")
				{
					RRM_SaveControlShapes_V1("empty", $fileName[0], "empty");
				}
			}
			else
			{
				fileBrowserDialog -mode 1
				-fileCommand ( "RRM_SaveControlShapes_V1 \"" + $mayaFolder + "\"" )
				-actionName "Save";
			}
		}
		else
		{
			string $returnVal_Generate = `confirmDialog
			-title "No RRM Control Selected"
			-message "You must first select a control from your modular rig that you wish to save the transforms from.\n"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"
			-icon "critical"`;
		}
	}
	else
	{
		string $returnVal_Generate = `confirmDialog
		-title "Nothing Selected"
		-message "You must first select a control from your modular rig that you wish to load the transforms to.\n"
		-button "OK"
		-defaultButton "OK"
		-cancelButton "OK"
		-icon "critical"`;
	}
	select $initialSelection;
}

global proc RRM_SaveControlShapes_V1(string $mayaFolder, string $result, string $type)
{
	print ("\nSAVING TO: "+ $result + "\n");
	$fileID = `fopen $result "w"`;

	$selection = `ls -sl`;
	$modRigName = `getAttr ($selection[0] + ".modRigName")`;
	select -hi ($modRigName + "_MAINCtrl");
	
	$controls = `ls -sl -type "transform"`;
	for ($each in $controls)
	{
		if (`objExists ($each + ".controlSizeX")` && `objExists ($each + ".modRigName")`)
		{
			//GET NAME OF CONTROL WITHOUT RIG NAME
			$shapes = `listRelatives -shapes $each`;
			
			for ($eachShape in $shapes)
			{
				if (`objExists ($eachShape + ".cv[0]")`)
				{
					fprint $fileID ("if (`objExists " + $eachShape + "`) {");
					int $numSpans = `getAttr ($eachShape + ".spans")`;
					int $degree   = `getAttr ($eachShape + ".degree")`;
					int $form     = `getAttr ($eachShape + ".form")`;
				
					int $numCVs   = $numSpans + $degree;
				
					// Adjust for periodic curve:
					if ( $form == 2 ) $numCVs -= $degree;
					
					int $i = 0;
					while ($i <= $numCVs)
					{
						$pos = `xform -q -os -t ($eachShape + ".cv[" + $i + "]")`;
						fprint $fileID ("move -os " + $pos[0] + " " + $pos[1] + " " + $pos[2] + " " + ($eachShape + ".cv[" + $i + "]; "));
						$i++;
					}
					$overrideColor = `getAttr ($eachShape + ".overrideColor")`;
					fprint $fileID ("setAttr " + $eachShape + ".overrideColor " + $overrideColor + "; ");
					fprint $fileID ("} else {warning (\"" + $eachShape + " does not exist. Skipping\");}\n");
				}
			}
		}
	}
	fclose $fileID;
	
	print ("\nFILE SUCCESSFULLY SAVED TO: "+ $result + "\n");
}

global proc RRM_ReadControlShapes_V1()
{
	int $mayaVer = `about -version`;
	
	string $mayaFolder2;
	string $fileName[];

	if ($mayaVer > 2011)
	{
		$fileFilter = "RRM Proxy Transforms (.rrmctrl) (*.rrmctrl)";
		$fileName = `fileDialog2 -fileMode 1 -cap "Load Control Shapes & Colours" -fileFilter $fileFilter -selectFileFilter $fileFilter`;
		if ($fileName[0] != "")
		{
			RRM_LoadControlShapes_V1("empty", $fileName[0], "empty");
		}
	}
	else
	{
		fileBrowserDialog -mode 0
		-fileCommand ( "RRM_LoadControlShapes_V1 \"" + $mayaFolder2 + "\"" )
		-actionName "Load";
	}
}

global proc RRM_LoadControlShapes_V1(string $mayaFolder2, string $result2, string $type2)
{
	//FILE PATH
	print ("LOADING SHAPES FROM "+$result2+"\n");
	//OPEN FILE FOR READING
	$fileID = `fopen $result2 "r"`;
	//GET FIRST LINE
	string $nextLine = `fgetline $fileID`;
	//LOOP
	while (size($nextLine) > 0)
	{
		eval ($nextLine);
		print ($nextLine);
		$nextLine = `fgetline $fileID`;
	}
	//RETURN ARRAY
	fclose $fileID;
}


//////////////////////////OVERRIDE COLOR////////////////////////////////////////

global proc RRM_ControlOverrideColor_V1(int $colorVal)
{
	$selection = `ls -sl -type "transform"`;
	for ($each in $selection)
	{
		if (`objExists ($each + ".modRigName")`)
		{
			$shapes = `listRelatives -fullPath -shapes $each`;
			for ($eachShape in $shapes)
			{
				setAttr ($eachShape + ".overrideColor") $colorVal;
			}
		}
	}
	select $selection;
}

//DELETE RIG
global proc RRM_DeleteRig_V1(string $rigName, int $keep)
{
	if ($keep == 1)
	{
		parent -w ($rigName + "_SHJntGrp");
		select -hi ($rigName + "_SHJntGrp");
		$SHJoints = `ls -sl -type "joint"`;
		string $each;
		for ($each in $SHJoints)
		{
			delete -constraints $each;
		}
	}
	
	select -cl;
	select -hi $rigName;
	$dagNodes = `ls -sl`;
	select -d $dagNodes;
	$nonDagNodes = `ls -sl`;

		
	//DELETE NODES
	lockNode -lock off $rigName ($rigName + "_MAINCtrl") ($rigName + "_ROOTSecondaryCtrl");
	delete $rigName;
	for ($each in $nonDagNodes)
	{
		if (`objExists $each`)
		{
			delete $each;
		}
	}

	//EXTRA UTILITY NODES
	$MD_Nodes = `ls -type "multiplyDivide" ($rigName + "_*")`;
	$Blend_Nodes = `ls -type "blendColors" ($rigName + "_*")`;
	$Condition_Nodes = `ls -type "condition" ($rigName + "_*")`;
	$Additive_Nodes = `ls -sl -type "plusMinusAverage" ($rigName + "_*")`;
	
	delete `ls $MD_Nodes $Blend_Nodes $Condition_Nodes $Additive_Nodes`;
	
	//LAYERS
	if (`objExists ($rigName + "_SHJointsLayer")`)
	{
		delete ($rigName + "_SHJointsLayer");
	}
	if (`objExists ($rigName + "_GeoLayer")`)
	{
		delete ($rigName + "_GeoLayer");
	}
	if (`objExists ($rigName + "_ControlsLayer")`)
	{
		delete ($rigName + "_ControlsLayer");
	}
	if (`objExists ($rigName + "_JointsLayer")`)
	{
		delete ($rigName + "_JointsLayer");
	}
	
	//MATERIALS
	if (`objExists ($rigName + "_geoColor01")`)
	{
		delete ($rigName + "_geoColor01");
	}
	if (`objExists ($rigName + "_geoColor02")`)
	{
		delete ($rigName + "_geoColor02");
	}
	if (`objExists ($rigName + "_EyeWhites")`)
	{
		delete ($rigName + "_EyeWhites");
	}
	if (`objExists ($rigName + "_Pupils")`)
	{
		delete ($rigName + "_Pupils");
	}
}


global proc RRM_DeleteRig_V1UI_V1()
{
	$selection = `ls -sl`;
	
	if (`size $selection` == 1)
	{
		if (`objExists ($selection[0] + ".modRigName")`)
		{
			$isReferenced = `referenceQuery -isNodeReferenced $selection[0]`;
			if ($isReferenced == 0)
			{
				string $modRigConnections[] = `listConnections ($selection[0] + ".modRigConnection")`;
				string $modRigName = $modRigConnections[0];
				
				if (!`objExists ($modRigName + "_ROOTSHJnt")`)
				{
					string $returnVal_DeleteRig = `confirmDialog
					-title ("Are you sure you want to delete \"" + ($modRigName) + "\" rig?")
					-message ("This will delete the entire rig and anything you may have added to the \"" + ($modRigName) + "\" hierarchy. You may not be able to undo.")
					-button "Proceed"
					-button "Cancel"
					-defaultButton "Cancel"
					-cancelButton "Cancel"`;
					
					if ($returnVal_DeleteRig == "Proceed") 
					{
						print ("DELETING \"" + ($modRigName) + "\"...\n");
						RRM_DeleteRig_V1($modRigName, 0);
						print ("\"" + ($modRigName) + "\" DELETED\n");
					}
				}
				else
				{
					string $returnVal_DeleteRig = `confirmDialog
					-title ("Are you sure you want to delete \"" + ($modRigName) + "\" rig?")
					-message ("This will delete the entire rig and anything you may have added to the \"" + ($modRigName) + "\" hierarchy. You may not be able to undo.")
					-button "Proceed"
					-button "Proceed, Keep SH Joints"
					-button "Cancel"
					-defaultButton "Cancel"
					-cancelButton "Cancel"`;
					
					if ($returnVal_DeleteRig == "Proceed") 
					{
						print ("DELETING \"" + ($modRigName) + "\"...\n");
						RRM_DeleteRig_V1($modRigName, 0);
						print ("\"" + ($modRigName) + "\" DELETED\n");
					}
					if ($returnVal_DeleteRig == "Proceed, Keep SH Joints") 
					{
						print ("DELETING \"" + ($modRigName) + "\"...\n");
						RRM_DeleteRig_V1($modRigName, 1);
						print ("\"" + ($modRigName) + "\" DELETED. SINGLE HIERARCHY JOINTS PRESERVED\n");
					}
				}
			}
			else
			{
				warning ("\"" + $selection[0] + "\" IS REFERENCED AND CANNOT BE DELETED.");
			}
		}
		else
		{
			confirmDialog
			-title "Warning: Select \"MAINC\""
			-message "You need to select a control of the rig you wish to delete"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
		}
	}
	else if (`size $selection` == 0)
	{
			confirmDialog
			-title "Warning: Nothing Selected"
			-message "You need to select a control of the rig you wish to delete"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
	}
	else
	{
			confirmDialog
			-title "Warning: More Than One Object Selected"
			-message "Please select only one control of the rig you wish to delete"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
	}
}
//////////////////////////////////////////////////////////////////////////////////////////
//CONNECT SCALES
global proc RRM_SH_ScaleConnect_V1(int $x, int $y, int $z)
{
	$sel = `ls -sl -type "joint"`;
	if (`size $sel` > 0)
	{
		if (($x + $y + $z) > 0)
		{
			for ($j in $sel)
			{
				$constraints = `listConnections -s 1 -d 0 -type "constraint" ($j + ".translateX")`;
				$constraints = `stringArrayRemoveDuplicates $constraints`;
				if (`size $constraints` > 0)
				{
					$targetJnt = `listConnections -s 1 -d 0 -type "joint" ($constraints[0] + ".target")`;
					$targetJnt = `stringArrayRemoveDuplicates $targetJnt`;

					//CONNECTIONS
					if ($x == 1)
					{
						connectAttr -f ($targetJnt[0] + ".sx") ($j + ".sx");
					}
					if ($y == 1)
					{
						connectAttr -f ($targetJnt[0] + ".sy") ($j + ".sy");
					}
					if ($z == 1)
					{
						connectAttr -f ($targetJnt[0] + ".sz") ($j + ".sz");
					}
						
				}
				else
				{
					warning ("\"" + $j + "\" is not connected to a RRM joint.");
				}
			}
		}
		else
		{
			warning "All checkboxes are disabled. No action taken.";
		}
	}
	else
	{
		warning "No joints are selected.";
	}
}

//////////////////////////////////////////////////////////////////////////////////////////
global proc RRM_SH_RenameHead_V1()
{
	$headJoint = `ls -sl`;
	$headJointCheck = `nodeType $headJoint[0]`;
	
	if ($headJointCheck == "joint")
	{
		rename $headJoint[0] "Head";
	}
	else
	{
		warning "Selected object is not a joint";
	}
	select $headJoint;
}

global proc RRM_SH_RenameHips_V1()
{
	$ROOTJoint = `ls -sl`;
	$ROOTJointCheck = `nodeType $ROOTJoint[0]`;
	
	if ($ROOTJointCheck == "joint")
	{
		rename $ROOTJoint[0] "Hips";
		select "Hips";
	}
	else
	{
		warning "Selected object is not a joint";
		select $ROOTJoint;
	}
}

global proc RRM_SH_RenameSpline_V1()
{
	$splineJoint = `ls -sl`;
	$splineJointCheck = `nodeType $splineJoint[0]`;
	int $hierarchySize;
	
	if ($splineJointCheck == "joint")
	{
		if (`objExists ($splineJoint[0] + ".splineStart")`)
		{
			select -hi $splineJoint;
			$splineHierarchy = `ls -sl -type "joint"`;
			$hierarchySize = `size $splineHierarchy`;
			int $splineEnd;
			int $i;
			string $splineJoints[];// = $splineJoint[0];
			string $iString;
			
			while ($i < $hierarchySize)
			{
				if (!`objExists ($splineHierarchy[$i] + ".splineEnd")`)
				{
					$iString = $i;
					if ($i == 0)
					{
						rename $splineHierarchy[$i] ("Spine");
					}
					else
					{
						rename $splineHierarchy[$i] ("Spine" + $iString);
					}
				}
				else
				{
					$iString = $i;
					rename $splineHierarchy[$i] ("Spine" + $iString);
					$i=100;
				}
				$i++;
			}
			select "Spine";
		}
		else
		{
			warning "Selected object is not the first joint of a spline";
			select $splineJoint;
		}
	}
	else
	{
		warning "Selected object is not a joint";
		select $splineJoint;
	}
}

global proc RRM_SH_RenameNeck_V1()
{
	$splineJoint = `ls -sl`;
	$splineJointCheck = `nodeType $splineJoint[0]`;
	int $hierarchySize;
	
	if ($splineJointCheck == "joint")
	{
		if (`objExists ($splineJoint[0] + ".splineStart")`)
		{
			select -hi $splineJoint;
			$splineHierarchy = `ls -sl -type "joint"`;
			$hierarchySize = `size $splineHierarchy`;
			int $splineEnd;
			int $i;
			string $splineJoints[];// = $splineJoint[0];
			string $iString;
			
			while ($i < $hierarchySize)
			{
				if (!`objExists ($splineHierarchy[$i] + ".splineEnd")`)
				{
					$iString = $i;
					if ($i == 0)
					{
						rename $splineHierarchy[$i] ("Neck");
					}
					else
					{
						rename $splineHierarchy[$i] ("Neck" + $iString);
					}
				}
				else
				{
					$iString = $i;
					rename $splineHierarchy[$i] ("Neck" + $iString);
					$i=100;
				}
				$i++;
			}
			select "Neck";
		}
		else
		{
			warning "Selected object is not the first joint of a spline";
			select $splineJoint;
		}
	}
	else
	{
		warning "Selected object is not a joint";
		select $splineJoint;
	}
}

global proc RRM_SH_RenameLeftArm_V1()
{
	$clavicleJoint = `ls -sl`;
	$clavicleJointCheck = `nodeType $clavicleJoint[0]`;
	int $hierarchySize;
	
	if ($clavicleJointCheck == "joint")
	{
		if (`objExists ($clavicleJoint[0] + ".shoulder")`)
		{
			select -hi $clavicleJoint;
			$armHierarchy = `ls -sl -type "joint"`;
			$hierarchySize = `size $armHierarchy`;
			int $i = 1;
			
			rename $clavicleJoint[0] "LeftShoulder";
			while ($i < $hierarchySize)
			{
				if (`objExists ($armHierarchy[$i])`)
					{
					if (`objExists ($armHierarchy[$i] + ".arm")`)
					{
						rename $armHierarchy[$i] "LeftArm";
					}
					if (`objExists ($armHierarchy[$i] + ".forearm")`)
					{
						rename $armHierarchy[$i] "LeftForeArm";
					}
					if (`objExists ($armHierarchy[$i] + ".hand")`)
					{
						rename $armHierarchy[$i] "LeftHand";
					}
				}
				$i++;
			}
			select "LeftShoulder";
		}
		else
		{
			warning "Selected joint is not the first joint of a arm";
			select $clavicleJoint;
		}
	}
	else
	{
		warning "Selected object is not a joint";
		select $clavicleJoint;
	}
}

global proc RRM_SH_RenameRightArm_V1()
{
	$clavicleJoint = `ls -sl`;
	$clavicleJointCheck = `nodeType $clavicleJoint[0]`;
	int $hierarchySize;
	
	if ($clavicleJointCheck == "joint")
	{
		if (`objExists ($clavicleJoint[0] + ".shoulder")`)
		{
			select -hi $clavicleJoint;
			$armHierarchy = `ls -sl -type "joint"`;
			$hierarchySize = `size $armHierarchy`;
			int $i = 1;
			
			rename $clavicleJoint[0] "RightShoulder";
			while ($i < $hierarchySize)
			{
				if (`objExists ($armHierarchy[$i])`)
					{
					if (`objExists ($armHierarchy[$i] + ".arm")`)
					{
						rename $armHierarchy[$i] "RightArm";
					}
					if (`objExists ($armHierarchy[$i] + ".forearm")`)
					{
						rename $armHierarchy[$i] "RightForeArm";
					}
					if (`objExists ($armHierarchy[$i] + ".hand")`)
					{
						rename $armHierarchy[$i] "RightHand";
					}
				}
				$i++;
			}
			select "RightShoulder";
		}
		else
		{
			warning "Selected joint is not the first joint of a arm";
			select $clavicleJoint;
		}
	}
	else
	{
		warning "Selected object is not a joint";
		select $clavicleJoint;
	}
}

global proc RRM_SH_RenameLeftLeg_V1()
{
	$hipJoint = `ls -sl`;
	$hipJointCheck = `nodeType $hipJoint[0]`;
	int $hierarchySize;
	
	if ($hipJointCheck == "joint")
	{
		if (`objExists ($hipJoint[0] + ".upLeg")`)
		{
			select -hi $hipJoint;
			$legHierarchy = `ls -sl -type "joint"`;
			$hierarchySize = `size $legHierarchy`;
			int $i = 1;
			string $legJoints[];
			
			rename $hipJoint[0] "LeftUpLeg";
			while ($i <= $hierarchySize)
			{
				if (`objExists ($legHierarchy[$i])`)
				{
					if (`objExists ($legHierarchy[$i] + ".leg")`)
					{
						rename $legHierarchy[$i] "LeftLeg";
					}
					if (`objExists ($legHierarchy[$i] + ".foot")`)
					{
						rename $legHierarchy[$i] "LeftFoot";
					}
					if (`objExists ($legHierarchy[$i] + ".toeBase")`)
					{
						rename $legHierarchy[$i] "LeftToeBase";
					}
				}
				$i++;
			}
			select "LeftUpLeg";
		}
		else
		{
			warning "Selected joint is not the first joint of a leg";
			select $hipJoint;
		}
	}
	else
	{
		warning "Selected object is not a joint";
		select $hipJoint;
	}
}

global proc RRM_SH_RenameRightLeg_V1()
{
	$hipJoint = `ls -sl`;
	$hipJointCheck = `nodeType $hipJoint[0]`;
	int $hierarchySize;
	
	if ($hipJointCheck == "joint")
	{
		if (`objExists ($hipJoint[0] + ".upLeg")`)
		{
			select -hi $hipJoint;
			$legHierarchy = `ls -sl -type "joint"`;
			$hierarchySize = `size $legHierarchy`;
			int $i = 1;
			string $legJoints[];
			
			rename $hipJoint[0] "RightUpLeg";
			while ($i <= $hierarchySize)
			{
				if (`objExists ($legHierarchy[$i])`)
				{
					if (`objExists ($legHierarchy[$i] + ".leg")`)
					{
						rename $legHierarchy[$i] "RightLeg";
					}
					if (`objExists ($legHierarchy[$i] + ".foot")`)
					{
						rename $legHierarchy[$i] "RightFoot";
					}
					if (`objExists ($legHierarchy[$i] + ".toeBase")`)
					{
						rename $legHierarchy[$i] "RightToeBase";
					}
				}
				$i++;
			}
			select "RightUpLeg";
		}
		else
		{
			warning "Selected joint is not the first joint of a leg";
			select $hipJoint;
		}
	}
	else
	{
		warning "Selected object is not a joint";
		select $hipJoint;
	}
}

global proc RRM_GetVersionNumber_V1()
{
	$selection = `ls -sl`;
	
	if (`size $selection` == 1)
	{
		if (`objExists ($selection[0] + ".versionNumber")`)
		{
			$rigName = `getAttr ($selection[0] + ".modRigName")`;
			$rigVersionNumber = `getAttr ($selection[0] + ".versionNumber")`;
			
			string $returnVal_DeleteRig = `confirmDialog
			-title ("The rig \"" + ($rigName) + "\" is version: " + $rigVersionNumber)
			-message ("Click the \"Go To Rapid Rig Web Page\" button to see if you have the latest version.")
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK"`;
		}
		else
		{
			confirmDialog
			-title "Warning: Select \"MAINC\""
			-message "You need to select the Main Controller to check your rig's version"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
		}
	}
	else if (`size $selection` == 0)
	{
			confirmDialog
			-title "Warning: Nothing Selected"
			-message "You need to select the Main Controller to check your rig's version"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
	}
	else
	{
			confirmDialog
			-title "Warning: More Than One Object Selected"
			-message "You need to select the Main Controller to check your rig's version"
			-button "OK"
			-defaultButton "OK"
			-cancelButton "OK";
	}
}

global proc RRM_GoToCreativeCrash_V1()
{
	launch -web "http://www.creativecrash.com/maya/script/-rapid-rig-modular-procedural-auto-rig-for-maya";
}
//////////////////////////////////////////////////////////////////
////////////////////////Main Window///////////////////////////////
//////////////////////////////////////////////////////////////////

global proc RRM_CreateProxyMainGUI_V1()
{
	string $form = `formLayout`;
	string $tabs = `tabLayout -cr false RRM_RigTab`;
	
	//TAB 1////////////////////////////////////////////////////////////////////////
	rowColumnLayout -nc 2 -cw 1 385 -cw 2 385 RRM_ProxySteps;
	//STEP 1.1: Name
		frameLayout -label "Step 1.1: Create Proxy Module Base"
			-width 375
			RRM_ProxyCreateProxyBaseFrameLayout;
			
		columnLayout RRM_ProxyCreateProxyBaseColumnLayout;
			
		rowColumnLayout -nc 2 -columnWidth 1 110 -columnWidth 2 180;
			checkBox -label "Use Template:"
			-v 0 -cc RRM_ToggleTemplate_V1
			RRM_TemplateCheckBox;
			optionMenu -w 120
			-en 0
			RRM_TemplateType;
			menuItem -label "Bi-Ped (human)";
			menuItem -label "Quadruped";
			menuItem -label "Arachnid";
			menuItem -label "Bird";
			setParent RRM_ProxyCreateProxyBaseColumnLayout;

		rowColumnLayout -nc 3 -cw 1 320 -cw 2 10 -cw 3 26;
			button -label "Create New Proxy Rig" -bgc 0.7 0.7 0.7
			-command "RRM_CreateProxyMainProxy_V1(`checkBox -q -v RRM_TemplateCheckBox`)" RRM_CreateProxyMainProxy_V1;
			separator -vis 0;
			button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(25)";

			setParent RRM_ProxyCreateProxyBaseColumnLayout;
		
	string $RRM_ProxyTabs = `tabLayout -cr false -h 545 RRM_ProxyTabs`;
	//STEP 1.2
	columnLayout RRM_AddModules;
		frameLayout -label "Step 1.2: Add Modules"
		RRM_AddModulesFrameLayout;
			scrollLayout
				-w 376
				-h 499
        		-horizontalScrollBarThickness 16
        		-verticalScrollBarThickness   16
        		addModScrollLayout;
        		
        columnLayout RRM_AddModulesColumnLayout;

		
	//RIBBON SPLINE
		frameLayout -label "Ribbon Spline Options (Spine, Neck)"
			-width 350
			-collapsable 1
			-bgc 0.114 0.356 0.451
			RRM_SplineOptionsFrameLayout;
			
			columnLayout RRM_SplineOptionsColumnLayout;
	
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 68 -columnWidth 2 276;


        text -label "Name";
        textField -enterCommand "setFocus RRM_SplineButton" -aie 1 RRM_TextFieldSplineName;
        
        setParent..;

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 1
			-max 100
			-label "Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 4
			RRM_SplineNum;

		radioButtonGrp -numberOfRadioButtons 2
			-labelArray2 "X-axis twist" "Y-Axis twist" -sl 2 RRM_SplineTwistAxis;
		
	    checkBox
			-label "Mirror Module"
			-value 0
			RRM_SplineMirror;
			
		rowColumnLayout -nc 3 -cw 1 296 -cw 2 10 -cw 3 26;
		
		button -label "Create Spline" -bgc 0.114 0.356 0.451
		-command "RRM_SplinePrompts_V1_V1(\
		`textField -q -text RRM_TextFieldSplineName`,\
		`intSliderGrp -q -v RRM_SplineNum`,\
		`radioButtonGrp -q -select RRM_SplineTwistAxis`,\
		`checkBox -q -v RRM_SplineMirror`);"
		RRM_SplineButton;
		
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(216)";
		
		setParent RRM_AddModulesColumnLayout;
	
	//ARM
		frameLayout -label "Arm Options"
			-width 350
			-collapsable 1
			-bgc 0 .275 .098
			RRM_ArmOptionsFrameLayout;
			
		columnLayout RRM_ArmOptionsColumnLayout;
	
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 68 -columnWidth 2 276;


        text -label "Name";
        textField -enterCommand "setFocus RRM_ArmButton" -aie 1 RRM_TextFieldArmName;
        
        setParent RRM_ArmOptionsColumnLayout;

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 0
			-max 4
			-label "Upper Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 RRM_UpperArmNum;
			
		intSliderGrp
			-min 0
			-max 4
			-label "Lower Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 RRM_ForearmNum;
			
		radioButtonGrp -numberOfRadioButtons 2
		/*-label "Three Buttons"*/ -labelArray2 "One Elbow Joint" "Two Elbow Joints"
		-sl 1 -cc RRM_ElbowNumLock_V1 RRM_ElbowJoints;

		intSliderGrp
			-min 0
			-max 4
			-label "Mid Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0
			-en 0 RRM_ElbowNum;
			
	    checkBox
			-label "Toon Arms (Requires at least 1 roll joint)"
			-value 1
			RRM_ToonArmCheckBox;
			
		radioButtonGrp -numberOfRadioButtons 3
		/*-label "Three Buttons"*/ -labelArray3 "Left" "Pair" "Right"
		-sl 2 RRM_ArmMirror;
    
		rowColumnLayout -nc 3 -cw 1 296 -cw 2 10 -cw 3 26;

		button -label "Create Arm" -bgc 0 .275 .098		
		-command "RRM_ArmPrompts_V1(\
		`textField -q -text RRM_TextFieldArmName`,\
		`intSliderGrp -q -v RRM_UpperArmNum`,\
		`intSliderGrp -q -v RRM_ForearmNum`,\
		`intSliderGrp -q -v RRM_ElbowNum`,\
		`radioButtonGrp -q -select RRM_ElbowJoints`,\
		`checkBox -q -v RRM_ToonArmCheckBox`,\
		`radioButtonGrp -q -select RRM_ArmMirror`);"		
		RRM_ArmButton;
		
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(638)";

		setParent RRM_AddModulesColumnLayout;
		
		
	//LEG
		frameLayout -label "Leg Options"
			-width 350
			-collapsable 1
			-bgc .631 .188 .412
			RRM_LegOptionsFrameLayout;
			
			columnLayout RRM_LegOptionsColumnLayout;
	
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 68 -columnWidth 2 276;


        text -label "Name";
        textField -enterCommand "setFocus RRM_LegButton" -aie 1 RRM_TextFieldLegName;
        
        setParent..;


		columnLayout -cw 200 -cat "left" 5;
		$RRM_UpperLegNum = `intSliderGrp
			-min 0
			-max 4
			-label "Upper Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 RRM_UpperLegNum`;
			
		intSliderGrp
			-min 0
			-max 4
			-label "Lower Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 RRM_LowerLegNum;
			
		radioButtonGrp -numberOfRadioButtons 2
		/*-label "Three Buttons"*/ -labelArray2 "One Knee Joint" "Two Knee Joints"
		-sl 1 -cc RRM_KneeNumLock_V1 RRM_KneeJoints;

		intSliderGrp
			-min 0
			-max 4
			-label "Mid Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0
			-en 0 RRM_KneeNum;
			
	    checkBox
			-label "Toon Legs (Requires at least 1 roll joint)"
			-value 1
			RRM_ToonLegCheckBox;
			
		radioButtonGrp -numberOfRadioButtons 2
		/*-label "Three Buttons"*/ -labelArray2 "Single" "Pair"
		-sl 2 RRM_LegMirror;
    
		rowColumnLayout -nc 3 -cw 1 296 -cw 2 10 -cw 3 26;

		button -label "Create Leg" -bgc .631 .188 .412
		-command "RRM_LegPrompts_V1(\
		`textField -q -text RRM_TextFieldLegName`,\
		`intSliderGrp -q -v RRM_UpperLegNum`,\
		`intSliderGrp -q -v RRM_LowerLegNum`,\
		`intSliderGrp -q -v RRM_KneeNum`,\
		`radioButtonGrp -q -select RRM_KneeJoints`,\
		`checkBox -q -v RRM_ToonLegCheckBox`,\
		`radioButtonGrp -q -select RRM_LegMirror`);"
		RRM_LegButton;
		
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(1369)";

		setParent RRM_AddModulesColumnLayout;

		
	//FK CHAINS
		frameLayout -label "FK Chain Options (Fingers, Toes, Tail, Tentacle, Antenna)"
			-width 350
			-collapsable 1
			-bgc .784 0 .784
			RRM_FKChainOptionsFrameLayout;
			
			columnLayout RRM_FKChainOptionsColumnLayout;
	
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 68 -columnWidth 2 276;


        text -label "Name";
        textField -enterCommand "setFocus RRM_FKChainButton" -aie 1 RRM_TextFieldFKChainName;
        
        setParent..;

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 1
			-label "Chains"
			-field true
			-cal 1 center
			-cw 1 90
			-value 5 RRM_FkChain_Chains;
			
		intSliderGrp
			-min 1
			-label "Joints per Chain"
			-field true
			-cal 1 center
			-cw 1 90
			-value 4 RRM_FkChain_JointsPerChain;
			
		radioButtonGrp -numberOfRadioButtons 3
		-labelArray3 "X Outward" "+Y" "+Z" -sl 1 RRM_FkChainDirection;
		radioButtonGrp -numberOfRadioButtons 3
		-shareCollection RRM_FkChainDirection
		-labelArray3 "X Inward" "-Y" "-Z" RRM_FkChainDirection2;
		
		checkBox
			-label "Enable IK"
			-value 1
			RRM_FKEnableIK;
			
	    checkBox
			-label "Mirror Module"
			-value 1
			RRM_FkMirror;
    

		rowColumnLayout -nc 3 -cw 1 296 -cw 2 10 -cw 3 26;

		button -label "Create FK Chain" -bgc .784 0 .784
		-command "RRM_FKChainPrompts_V1(\
		`textField -q -text RRM_TextFieldFKChainName`,\
		`intSliderGrp -q -v RRM_FkChain_Chains`,\
		`intSliderGrp -q -v RRM_FkChain_JointsPerChain`,\
		`checkBox -q -v RRM_FKEnableIK`,\
		`checkBox -q -v RRM_FkMirror`,\
		`radioButtonGrp -q -select RRM_FkChainDirection`,\
		`radioButtonGrp -q -select RRM_FkChainDirection2`);"
		RRM_FKChainButton;
		
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(1797)";

		setParent RRM_AddModulesColumnLayout;

	
	//HEAD
		frameLayout -label "Head"
			-width 350
			-collapsable 1
			-bgc .608 0 .157
			RRM_HeadOptionsFrameLayout;
			
		columnLayout RRM_HeadOptionsColumnLayout;
	
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 68 -columnWidth 2 276;


        text -label "Name";
        textField -enterCommand "setFocus RRM_HeadButton" -aie 1 RRM_TextFieldHeadName;
        
        setParent..;
			
		columnLayout -cw 200 -cat "left" 5;
	    checkBox
			-label "Jaw"
			-value 1
			RRM_Jaw;
			
		columnLayout -cw 200 -cat "left" -1;
	    checkBox
			-label "Mirror Module"
			-value 0
			RRM_HeadMirror;
			
		setParent..;
    
		rowColumnLayout -nc 3 -cw 1 296 -cw 2 10 -cw 3 26;

		button -label "Create Head" -bgc .608 0 .157
		-command "RRM_HeadPrompts_V1(\
		`textField -q -text RRM_TextFieldHeadName`,\
		`checkBox -q -v RRM_Jaw`,\
		`checkBox -q -v RRM_HeadMirror`);"
		RRM_HeadButton;
		
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(2463)";

		setParent RRM_AddModulesColumnLayout;
		
	//LOOK-AT
		frameLayout -label "Look-At Joints (Eyes, etc)"
			-width 350
			-collapsable 1
			-bgc .435 .188 .631
			RRM_LookAtOptionsFrameLayout;
			
		columnLayout RRM_LookAtOptionsColumnLayout;
	
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 68 -columnWidth 2 276;


        text -label "Name";
        textField -enterCommand "setFocus RRM_LookAtButton" -aie 1 textFieldLookAtModName;
        
        setParent RRM_LookAtOptionsColumnLayout;
                

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 1
			-label "Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 1 lookAtModJoints;
			
		radioButtonGrp -numberOfRadioButtons 3
		-labelArray3 "X Outward" "+Y" "+Z" -sl 3 RRM_LookAtDirection;
		radioButtonGrp -numberOfRadioButtons 3
		-shareCollection RRM_LookAtDirection
		-labelArray3 "X Inward" "-Y" "-Z" RRM_LookAtDirection2;
		
	    checkBox
			-label "Mirror Module"
			-value 1
			lookAtModMirror;
    
		rowColumnLayout -nc 3 -cw 1 296 -cw 2 10 -cw 3 26;

		button -label "Create Look-At" -bgc .435 .188 .631		
		-command "RRM_LookAtPrompts_V1_V1(\
		`textField -q -text textFieldLookAtModName`,\
		`intSliderGrp -q -v lookAtModJoints`,\
		`checkBox -q -v lookAtModMirror`,\
		`radioButtonGrp -q -select RRM_LookAtDirection`,\
		`radioButtonGrp -q -select RRM_LookAtDirection2`);"
		RRM_LookAtButton;
		
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(2682)";

		setParent RRM_AddModulesColumnLayout;

	//AUXILIARY
		frameLayout -label "Auxiliary Joints (Single Joint)"
			-width 350
			-collapsable 1
			-bgc .639 .416 .169
			RRM_AuxiliaryOptionsFrameLayout;
			
		columnLayout RRM_AuxiliaryOptionsColumnLayout;
	
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 68 -columnWidth 2 276;


        text -label "Name";
        textField -enterCommand "setFocus RRM_AuxiliaryButton" -aie 1 textFieldAuxiliaryModName;
        
		setParent RRM_AuxiliaryOptionsColumnLayout;

		columnLayout -cw 200 -cat "left" 5;
	    checkBox
			-label "Mirror Module"
			-value 1
			AuxiliaryModMirror;
			
		rowColumnLayout -nc 3 -cw 1 296 -cw 2 10 -cw 3 26;

		button -label "Create Auxiliary" -bgc .639 .416 .169
		-command "RRM_AuxiliaryPrompts_V1(\
		`textField -q -text textFieldAuxiliaryModName`,\
		`checkBox -q -v AuxiliaryModMirror`);"
		RRM_AuxiliaryButton;

		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(2853)";

		setParent RRM_AuxiliaryOptionsColumnLayout;

        setParent RRM_ProxyTabs;

	
	//STEP 1.3
	columnLayout RRM_EditModules;
		frameLayout -label "Step 1.3: Edit Modules" RRM_EditModuleFrameLayout;
			scrollLayout
				-w 376
				-h 499
        		-horizontalScrollBarThickness 16
        		-verticalScrollBarThickness   16
        		-bgc .45 .45 .45
        		RRM_EditScrollFrameLayout;
        		
        	columnLayout RRM_EditScrollColumnLayout;
		
	//EDIT SPLINE
		frameLayout -label "Edit Ribbon Splines"
			-width 350
			-collapsable 1
			-bgc 0.114 0.356 0.451
			RRM_EditSpline_V1FrameLayout;
			
			columnLayout RRM_EditSpline_V1ColumnLayout;
	
        textFieldButtonGrp -label " Spline Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent_V1(\"spline\" )" RRM_EditLoadsplineTextField;


		setParent ..;
		
		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 1
			-max 99
			-label "Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 4
			RRM_SplineEditNum;
			
		radioButtonGrp -numberOfRadioButtons 2
			-labelArray2 "X-axis twist" "Y-Axis twist" -sl 2 RRM_SplineEditTwistAxis;
			
		setParent ..;
		columnLayout;
		button -label "Apply Edits to Loaded Spline" -w 340 -bgc 0.114 0.356 0.451 -command RRM_EditSpline_V1;

		
		setParent RRM_EditScrollColumnLayout;
	
	//EDIT ARM
		frameLayout -label "Edit Arms"
			-width 350
			-collapsable 1
			-bgc 0 .275 .098
			RRM_EditArm_V1sFrameLayout;
			
		columnLayout RRM_EditArm_V1sColumnLayout;
	
        textFieldButtonGrp -label " Arm Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent_V1(\"arm\" )" RRM_EditLoadarmTextField;

		setParent ..;

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 0
			-max 4
			-label "Upper Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 upperArmModEditNum;
			
		intSliderGrp
			-min 0
			-max 4
			-label "Lower Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 forearmModEditNum;
			
		radioButtonGrp -numberOfRadioButtons 2
		-labelArray2 "One Elbow Joint" "Two Elbow Joints"
		-sl 1 -cc RRM_ElbowEditNumLock_V1 RRM_ElbowEditJoints;

		intSliderGrp
			-min 0
			-max 4
			-label "Mid Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0
			-en 0 RRM_ElbowEditNum;
		
	    checkBox
			-label "Toon Arms (Requires at least 1 roll joint)"
			-value 1
			RRM_ToonArmEditCheckBox;
			
		setParent ..;
		button -label "Apply Edits to Loaded Arm" -w 340 -bgc 0 .275 .098 -command RRM_EditArm_V1;
		
		setParent RRM_EditScrollColumnLayout;
		
	//EDIT LEGS
		frameLayout -label "Edit Legs"
			-width 350
			-collapsable 1
			-bgc .631 .188 .412
			RRM_EditLeg_V1sFrameLayout;
			
		columnLayout RRM_EditLeg_V1sColumnLayout;
	
        textFieldButtonGrp -label " Leg Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent_V1(\"leg\" )" RRM_EditLoadlegTextField;


		setParent ..;

		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 0
			-max 4
			-label "Upper Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 upperLegModEditNum;
			
		intSliderGrp
			-min 0
			-max 4
			-label "Lower Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0 lowerLegModEditNum;
			
		radioButtonGrp -numberOfRadioButtons 2
		-labelArray2 "One Knee Joint" "Two Knee Joints"
		-sl 1 -cc RRM_KneeEditNumLock_V1 RRM_KneeEditJoints;
		
	    checkBox
			-label "Toon Legs (Requires at least 1 roll joint)"
			-value 1
			RRM_ToonLegEditCheckBox;
			
			
		intSliderGrp
			-min 0
			-max 4
			-label "Mid Roll Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 0
			-en 0 RRM_KneeEditNum;
		
		setParent ..;
		columnLayout;
		button -label "Apply Edits to Loaded Leg" -w 340 -bgc .631 .188 .412 -command RRM_EditLeg_V1;
		
		setParent RRM_EditScrollColumnLayout;
		
		
	//EDIT FK CHAINS
		frameLayout -label "Edit FK Chains"
			-width 350
			-collapsable 1
			-bgc .784 0 .784
			RRM_EditFKChainFrameLayout;
			
		columnLayout RRM_EditFKChainColumnLayout;
	

        textFieldButtonGrp -label " Fk Chain Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent_V1(\"fkChain\" )" RRM_EditLoadfkChainTextField;
        
        setParent..;


		columnLayout -cw 200 -cat "left" 5;
		intSliderGrp
			-min 1
			-label "Chains"
			-field true
			-cal 1 center
			-cw 1 90
			-value 5 fkChainModEditChains;
			
		intSliderGrp
			-min 1
			-label "Joints per Chain"
			-field true
			-cal 1 center
			-cw 1 90
			-value 4 fkChainModEditJointsPerChain;
			
		columnLayout -cw 200 -cat "left" 5;
		checkBox
			-label "Enable IK"
			-value 1
			fkChainModEditIK;
			
		button -w 340 -label "Apply Edits to Loaded FK Chain" -bgc .784 0 .784 -command RRM_EditFkChain_V1;
		
		setParent RRM_EditScrollColumnLayout;

	
	//EDIT HEAD
		frameLayout -label "Edit Head"
			-width 350
			-collapsable 1
			-bgc 0.529 0.162 0.199
			RRM_EditHead_V1FrameLayout;
	
	    columnLayout;
        textFieldButtonGrp -label " Head Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent_V1(\"head\" )" RRM_EditLoadheadTextField;

		button -label "Toggle Jaw" -w 340 -bgc 0.529 0.162 0.199 -command RRM_EditHead_V1;
		
		setParent RRM_EditScrollColumnLayout;
	
		
	//EDIT LOOK-AT
		frameLayout -label "Edit Look-Ats"
			-width 350
			-collapsable 1
			-bgc .435 .188 .631
			RRM_EditLookAt_V1FrameLayout;
	
	    columnLayout;
        textFieldButtonGrp -label " Look-At Name:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 95 205 50 -bc "RRM_EditLoadParent_V1(\"lookAt\" )" RRM_EditLoadlookAtTextField;

        
		intSliderGrp
			-min 1
			-label "Joints"
			-field true
			-cal 1 center
			-cw 1 90
			-value 1 lookAtModEditJoints;
			
		button -label "Apply Edits to Loaded Look-At" -w 340 -bgc .435 .188 .631 -command RRM_EditLookAt_V1;

		
		setParent RRM_EditScrollColumnLayout;
		setParent..;

		
        
        tabLayout -edit -h 545 -tabLabel RRM_AddModules "Create Modules" -tabLabel RRM_EditModules "Edit Modules" $RRM_ProxyTabs;
        
        setParent RRM_ProxySteps;

    
    //STEP 2.1 CHANGE PROXY COLOURS
    columnLayout RRM_ModifyProxies;
		frameLayout -label "Step 2.1 Override Selected Proxy Branch Color" -bgc .25 .25 .25 RRM_ControlColorOverrides;
		rowColumnLayout -nc 16 -bgc .25 .25 .25 -w 384;
		button -bgc  .471 .471 .471		-label "D" -w 24 -ann "0"  -c "RRM_ProxyOverrideColor_V1(00)";
		button -bgc  0 0 0				-label ""  -w 24 -ann "1"  -c "RRM_ProxyOverrideColor_V1(01)";
		button -bgc  .251 .251 .251		-label ""  -w 24 -ann "2"  -c "RRM_ProxyOverrideColor_V1(02)";
		button -bgc  .502 .502 .502		-label ""  -w 24 -ann "3"  -c "RRM_ProxyOverrideColor_V1(03)";
		button -bgc  .608 0 .157		-label ""  -w 24 -ann "4"  -c "RRM_ProxyOverrideColor_V1(04)";
		button -bgc  0 .016 .376		-label ""  -w 23 -ann "5"  -c "RRM_ProxyOverrideColor_V1(05)";
		button -bgc  0 0 1				-label ""  -w 23 -ann "6"  -c "RRM_ProxyOverrideColor_V1(06)";
		button -bgc  0 .275 .098		-label ""  -w 23 -ann "7"  -c "RRM_ProxyOverrideColor_V1(07)";
		button -bgc  .149 0 .263		-label ""  -w 23 -ann "8"  -c "RRM_ProxyOverrideColor_V1(08)";
		button -bgc  .784 0 .784		-label ""  -w 23 -ann "9"  -c "RRM_ProxyOverrideColor_V1(09)";
		button -bgc  .541 .282 .2		-label ""  -w 24 -ann "10" -c "RRM_ProxyOverrideColor_V1(10)";
		button -bgc  .247 .137 .122		-label ""  -w 24 -ann "11" -c "RRM_ProxyOverrideColor_V1(11)";
		button -bgc  .6 .149 0			-label ""  -w 24 -ann "12" -c "RRM_ProxyOverrideColor_V1(12)";
		button -bgc  1 0 0				-label ""  -w 24 -ann "13" -c "RRM_ProxyOverrideColor_V1(13)";
		button -bgc  0 1 0				-label ""  -w 24 -ann "14" -c "RRM_ProxyOverrideColor_V1(14)";
		
		button -bgc  0 .255 .6			-label ""  -w 24 -ann "15" -c "RRM_ProxyOverrideColor_V1(15)";
		button -bgc  1 1 1				-label ""  -w 24 -ann "16" -c "RRM_ProxyOverrideColor_V1(16)";
		button -bgc  1 1 0				-label ""  -w 24 -ann "17" -c "RRM_ProxyOverrideColor_V1(17)";
		button -bgc  .392 .863 1		-label ""  -w 24 -ann "18" -c "RRM_ProxyOverrideColor_V1(18)";
		button -bgc  .263 1 .639		-label ""  -w 24 -ann "23" -c "RRM_ProxyOverrideColor_V1(23)";
		button -bgc  1 .69 .69			-label ""  -w 23 -ann "20" -c "RRM_ProxyOverrideColor_V1(20)";
		button -bgc  .967 .675 .475		-label ""  -w 23 -ann "21" -c "RRM_ProxyOverrideColor_V1(21)";
		button -bgc  1 1 .388			-label ""  -w 23 -ann "22" -c "RRM_ProxyOverrideColor_V1(22)";
		button -bgc  0 .6 .329			-label ""  -w 23 -ann "23" -c "RRM_ProxyOverrideColor_V1(23)";
		button -bgc  .631 .412 .188		-label ""  -w 23 -ann "24" -c "RRM_ProxyOverrideColor_V1(24)";
		button -bgc  .624 .631 .188		-label ""  -w 23 -ann "25" -c "RRM_ProxyOverrideColor_V1(25)";
		button -bgc  .408 .631 .188		-label ""  -w 23 -ann "26" -c "RRM_ProxyOverrideColor_V1(26)";
		button -bgc  .188 .631 .365		-label ""  -w 24 -ann "27" -c "RRM_ProxyOverrideColor_V1(27)";
		button -bgc  .188 .631 .631		-label ""  -w 24 -ann "28" -c "RRM_ProxyOverrideColor_V1(28)";
		button -bgc  .188 .404 .631		-label ""  -w 24 -ann "29" -c "RRM_ProxyOverrideColor_V1(29)";
		button -bgc  .435 .188 .631		-label ""  -w 24 -ann "30" -c "RRM_ProxyOverrideColor_V1(30)";
		button -bgc  .631 .188 .412		-label ""  -w 24 -ann "31" -c "RRM_ProxyOverrideColor_V1(31)";

		setParent RRM_ModifyProxies;
	

	//STEP 2.2 RENAME MODULE
		frameLayout -label "Step 2.2: Rename Selected Module"
			-width 384
			-bgc -.35 .35 .35
			RRM_Rename_V1ModFrameLayout;
	
	    columnLayout 
	    -bgc .35 .35 .35
	    RRM_Rename_V1ModColumnLayout;
    
	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 120 -columnWidth 2 258;
    
	    text -label "Module's New Name: ";
		textField -enterCommand "setFocus RRM_Rename_V1Button" -aie 1 textFieldRenameName;
		
	    setParent RRM_Rename_V1ModColumnLayout;
	    
		rowColumnLayout -nc 3 -cw 1 340 -cw 2 10 -cw 3 26;
	    				
		button -label "Rename Selected Module" -command "RRM_Clone_V1Prompts_V1(\
		`textField -q -text textFieldRenameName`,\
		0, 0);"
		RRM_Rename_V1Button;

		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(2968)";
		
		setParent RRM_ModifyProxies;
  
		
	//STEP 2.3 CLONE MODULE
		frameLayout -label "Step 2.3: Clone Selected Module"
			-width 384
			-bgc .25 .25 .25
			RRM_Clone_V1ModFrameLayout;
	
	    columnLayout
	    -bgc .25 .25 .25 RRM_Clone_V1ModColumnLayout;

	    rowColumnLayout -numberOfColumns 2 -columnAttach 1 "right" 0
	    	-columnWidth 1 132 -columnWidth 2 246;

	    text -label "Cloned Module's Name: ";
		textField -enterCommand "setFocus RRM_Clone_V1Button" -aie 1 textFieldCloneName;
		
	    setParent RRM_Clone_V1ModColumnLayout;
	    
	    rowColumnLayout -numberOfColumns 4 -columnAttach 1 "right" 0
	    	-columnWidth 1 128 -columnWidth 2 212 -cw 3 10 -cw 4 26;
	    	
	    checkBox
			-label "Include branches"
			-value 1
			RRM_Clone_V1BranchCheckBox;
			
		button -label "Clone Selected Module" -command "RRM_Clone_V1Prompts_V1(\
		`textField -q -text textFieldCloneName`,\
		`checkBox -q -v RRM_Clone_V1BranchCheckBox`,1);"
		RRM_Clone_V1Button;
		
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(3013)";
		
		setParent RRM_ModifyProxies;
      

		//STEP 2.4 RE-ATTACH
		frameLayout -label "Step 2.4: Attach Module to New Node"
			-width 384
			-bgc .35 .35 .35
			RRM_RetargetModFrameLayout;
		
		columnLayout -bgc .35 .35 .35;
        textFieldButtonGrp -label " New Attach Module:" -buttonLabel "Load" -cal 1 "left" -columnWidth3 114 220 80 -bc RRM_LoadNewModuleAttachNode_V1 RRM_LoadNewModuleAttachNode_V1TextField;

		rowColumnLayout -nc 3 -cw 1 340 -cw 2 10 -cw 3 26;

        button -label "Attach Selected Modules to New Module"
        -command "RRM_AttachToNewModule_V1 (`textFieldButtonGrp -q -text RRM_LoadNewModuleAttachNode_V1TextField`)";
        
		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(3126)";
      
			setParent RRM_ModifyProxies;
			
		//STEP 2.5 DELETE MODULE
		frameLayout -label "Step 2.5: Delete Module"
			-width 384
			-bgc .25 .25 .25
			RRM_DeleteModFrameLayout;
	
		//DELETE
		columnLayout -bgc .25 .25 .25;
		rowColumnLayout -nc 3 -cw 1 340 -cw 2 10 -cw 3 26;

		button -label "Delete Selected Module and Branches" -bgc .5 0.0 0.0 -command RRM_DeleteBranch_V1Prompts_V1;

		separator -vis 0;
		button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(3169)";

		setParent RRM_ModifyProxies;
		
		//STEP 2.6 POSE
		frameLayout -label "Step 2.6: Pose Proxy Rig (Does not affect ROOT or Parent nodes)"
			-width 384
			-bgc .35 .35 .35
			RRM_PoseProxyFrameLayout;
	
		columnLayout -cw 200 -cat "left" 0 -bgc .35 .35 .35;
		radioButtonGrp -numberOfRadioButtons 4
		/*-label "Three Buttons"*/ -labelArray4 "Selected" "Module" "Branch" "All"
		-sl 1 RRM_PoseSelection;
		
		rowColumnLayout -nc 5 -cw 1 113 -cw 2 114 -cw 3 113 -cw 4 10 -cw 5 26;
			button -label "Right to Left"
			-command ("RRM_TransferProxies_V1 (\"right\", " +  "`radioButtonGrp -q -select RRM_PoseSelection`)")
			RRM_RightToLeftProxiesButton;
			button -label "Reset"
			-command "RRM_ResetProxies_V1 (`radioButtonGrp -q -select RRM_PoseSelection`)"
			RRM_ResetProxies_V1;		
			button -label "Left to Right"
			-command ("RRM_TransferProxies_V1 (\"left\", " +  "`radioButtonGrp -q -select RRM_PoseSelection`)")
			RRM_LeftToRightProxiesButton;

			separator -vis 0;
			button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(3225)";

			setParent RRM_ModifyProxies;

			
	//STEP 2.7 PINNING
		frameLayout -label "Step 2.7: Pinning (pinned modules are not influenced by parent)"
			-width 384
			-bgc .25 .25 .25
			RRM_PinProxyFrameLayout;
				
			rowColumnLayout -nc 4 -cw 1 171 -cw 2 171  -cw 3 10 -cw 4 26 -bgc .25 .25 .25;
			button -label "Pin Module" -bgc 0.780 0.330 0.330
			-command "RRM_PinProxies_V1(1, 0)";
			button -label "Unpin Module" -bgc 0.330 0.420 0.780
			-command "RRM_PinProxies_V1(0, 1)";		
	
			separator -vis 0;
			button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(3342)";

			setParent RRM_ModifyProxies;
	
	
	//STEP 2.8 TRANSFER
		frameLayout -label "Step 2.8: Transfer Transforms  *Select Target Then Destination*"
			-width 384
			-bgc .35 .35 .35
			RRM_TransferProxyTransformsFrameLayout;
			
		columnLayout 
		-bgc .35 .35 .35 RRM_TransferProxyTransformsColumnLayout;
	
		//rowColumnLayout -nc 2 -cw 1 220 -cw 2 150
		//-bgc .35 .35 .35;
			$selectedOrBranch = `radioButtonGrp -numberOfRadioButtons 3
			-labelArray3 "Selected" "Module" "Branch"
			-sl 1
			-cc RRM_ToggleTransferParent_V1
			RRM_TransferSelectionButton`;
			
			$transferParentCheck = `checkBox -v 0 -label "Include Parent" -ed 0 RRM_TransferParent`;
		
			setParent RRM_TransferProxyTransformsColumnLayout;
		//columnLayout ;//-cw 370 -cat "left" 5;
		
		rowColumnLayout -nc 3 -cw 1 340 -cw 2 10 -cw 3 26;

			button -label "Transfer"
			-bgc .35 .35 .35
			-command "RRM_TransferModTransforms_V1"
			RRM_TransferModTransforms_V1Button;

			separator -vis 0;
			button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(3409)";

		setParent RRM_ModifyProxies;

			
		//STEP 2.9 SAVE LOAD
		frameLayout -label "Step 2.9: Save/Load Proxy Transforms"
			-width 384
			-bgc .25 .25 .25
			RRM_SaveLoadProxyTransformsFrameLayout;
				
			rowColumnLayout -nc 4 -cw 1 171 -cw 2 171 -cw 3 10 -cw 4 26
			-bgc .25 .25 .25;
			button -label "Save Transforms"       
			-command "RRM_WritePathProxyTransforms_V1";
			button -label "Load Transforms"
			-command "RRM_ReadPathProxyTransform_V1";		
	
			separator -vis 0;
			button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(3489)";

			setParent RRM_ModifyProxies;
			
			
		//STEP 2.10 SAVE LOAD
		frameLayout -label "Step 2.10: Save/Load Proxy Setup"
			-width 384
			-bgc .35 .35 .35
			RRM_SaveLoadProxySetupFrameLayout;
				
			rowColumnLayout -nc 4 -cw 1 171 -cw 2 171 -cw 3 10 -cw 4 26
			-bgc .35 .35 .35;
			button -label "Save Setup"       
			-command "RRM_WritePathProxySetup_V1";
			button -label "Load Setup"
			-command "RRM_ReadPathProxySetup_V1";		
	
			separator -vis 0;
			button -label "?" -bgc 0.15 0.15 0.15 -command "RRM_GotToTutorial_V1(3590)";
			
			setParent RRM_RigTab;
	
	
	//TAB 2////////////////////////////////////////////////////////////////////////
	rowColumnLayout -nc 2 -cw 1 355 -cw 2 415 RRM_RigSteps;
	//STEP 3.1
		frameLayout -label "Step 3.1: Character Name" -bgc .25 .25 .25
			-width 350 RRM_GenerateRig_V1FrameLayout;
			
		columnLayout  -bgc .25 .25 .25 RRM_GenerateRig_V1ColumnLayout;
		
		columnLayout -cw 350 -cat "left" 1;
		$charModName = `textField
			-width 345 RRM_TextFieldCharName`;
			
			setParent RRM_GenerateRig_V1ColumnLayout;

		
	//STEP 3.2
		frameLayout -label "Step 3.2: Create Character Rig" -bgc -.35 .35 .35
			-width 350
			RRM_CreateRigFrameLayout;
	
			button -bgc .30 .65 .30 -label "Generate Modular Rig"
			-command "RRM_GenerateRig_V1Prompts_V1(`textField -q -text RRM_TextFieldCharName`)"
			RRM_GenerateRig_V1Prompts_V1Button;
	
			setParent RRM_GenerateRig_V1ColumnLayout;
	
	//STEP 3.3
		frameLayout -label "Step 3.3: Skin Geometry to Rig" -bgc .25 .25 .25
			-width 350
			RRM_SelectSkinningJointsFrameLayout;
		
			columnLayout RRM_SelectSkinningJointsColumnLayout;
	
			textFieldButtonGrp -buttonLabel "Load Rig"
			-cal 1 "left"
			-columnWidth2 290 70
			-ann "Select a control of the Rapid Rig you want to load"
			-buttonCommand "RRM_LoadRig_V1"
			RRM_LoadRig_V1TextFieldButtonGrp;
			
			columnLayout -cw 350 -cat "left" 5;
			
			setParent..;

			button -w 350 -label "Select Skinning Joints"
			-command "RRM_SelectJoints_V1(`textFieldButtonGrp -q -tx RRM_LoadRig_V1TextFieldButtonGrp`)"
			RRM_SelectJoints_V1Button;
	
		setParent RRM_GenerateRig_V1ColumnLayout;
		
	//STEP 3.4
	frameLayout -label "Step 3.4: Character Set Creation" -bgc -.35 .35 .35
		-width 350
		RRM_CreateCharacterSet_V1FrameLayout;
		
		columnLayout -bgc -.35 .35 .35 RRM_CreateCharacterSet_V1ColumnLayout;
		checkBox -label "Create Subcharacter Set for Each Module" RRM_SubCharacterCheckBox;
		
		button -w 350 -label "Create Character Set"
			-ann "Select MAINC of the Rig you want to create the character set for."
			-command "RRM_CreateCharacterSet_V1(`checkBox -q -v RRM_SubCharacterCheckBox`)"
			RRM_CreateCharacterSet_V1Button;
			
			
	//STEP 3.5
	frameLayout -label "Step 3.5: Rebuild Rig" -bgc .25 .25 .25
		-width 350
		RRM_RebuildRig_V1FrameLayout;
		
		columnLayout -bgc -.25 .25 .25 RRM_RebuildRig_V1ColumnLayout;
		text -ww 1 -w 320 -align "left" -label "Use this to rebuild your rig after making adjustments to your proxies.";
		text -ww 1 -w 320 -align "left" -label "Your weights will be preserved on any meshes that are skinned to the joints of your rig.";
		text -ww 1 -w 320 -align "left" -label "This only works if your proxy rig still exists in your scene.";
		text -ww 1 -w 320 -align "left" -label "Beware that any animation on the rig will be lost.";
		button -w 350 -label "Rebuild Rig" -bgc 1.00 .50 .00
		-command "RRM_RebuildRig_V1"
		RRM_RebuildRig_V1Button;
		
	
		setParent RRM_RigSteps;

	//STEP 4.1
		columnLayout "RRM_Tab2_RightColumn";
		frameLayout -label "Step 4.1: Resize Controllers"
			-width 415
			RRM_ResizeControllersFrameLayout;
			
		columnLayout -cw 415 -cat "left" 0;

        rowColumnLayout -nc 2 -cw 1 340 -cw 2 75;
		radioButtonGrp -numberOfRadioButtons 3
		-labelArray3 "Selected" "Branch" "All"
		-sl 1
		-cc RRM_ControlEnableDisableMirror_V1
		RRM_ControlScale_V1Selection;
		
		checkBox -label "Mirror"
		-v 1 -enable 1 RRM_ControlMirror;
		setParent..;		

		columnLayout -cal "left";
		checkBox -label "Uniform Scale"
		-v 1 -enable 1
		-cc RRM_ControlEnableDisableUniformScales_V1
		RRM_ControlUniformScale;
		
		checkBoxGrp -numberOfCheckBoxes 3
		-label "Local Axes:"
		-labelArray3 "X" "Y" "Z"
		-valueArray3 1 1 1
		-en1 0 -en2 0 -en3 0
		RRM_ControlScale_V1Axes;
		
		
		floatSliderGrp -label "Scale Factor:" -field true
		-min 0.1 -max 2 -fieldMaxValue 10 -value 1
		-precision 3
		RRM_ControlScale_V1Change;
		setParent..;
		columnLayout;
		button -label "Scale Control(s)"
		-width 410
		-command "RRM_ControlScale_V1(`floatSliderGrp -query -value RRM_ControlScale_V1Change`,\
		`radioButtonGrp -q -select RRM_ControlScale_V1Selection`,\
		`checkBox -q -v RRM_ControlMirror`,\
		`checkBox -q -v RRM_ControlUniformScale`,\
		`checkBoxGrp -q -value1 RRM_ControlScale_V1Axes`,\
		`checkBoxGrp -q -value2 RRM_ControlScale_V1Axes`,\
		`checkBoxGrp -q -value3 RRM_ControlScale_V1Axes`);"
		RRM_ControlScale_V1Button;
		
		setParent RRM_Tab2_RightColumn;
		
	//STEP 4.2: SAVE CONTROLS
		frameLayout -label "Step 4.2: Save & Load Control Shapes and Colors" -width 415 RRA_SaveLoadControlShapes;
		rowColumnLayout -nc 2;
		button -label "Save Shapes and Colors" -w 206 -c "RRM_WriteControlShapes_V1";
		button -label "Load Shapes and Colors" -w 206 -c "RRM_ReadControlShapes_V1";
		
		setParent RRM_Tab2_RightColumn;
		
	//STEP 4.3
		frameLayout -label "Step 4.3: Override Control Color" RRM_ControlColorOverrides;
		rowColumnLayout -nc 16;
		button -bgc  .471 .471 .471		-label "D" -w 25 -ann "0"  -c "RRM_ControlOverrideColor_V1(00)";
		button -bgc  0 0 0				-label ""  -w 25 -ann "1"  -c "RRM_ControlOverrideColor_V1(01)";
		button -bgc  .251 .251 .251		-label ""  -w 25 -ann "2"  -c "RRM_ControlOverrideColor_V1(02)";
		button -bgc  .502 .502 .502		-label ""  -w 25 -ann "3"  -c "RRM_ControlOverrideColor_V1(03)";
		button -bgc  .608 0 .157		-label ""  -w 25 -ann "4"  -c "RRM_ControlOverrideColor_V1(04)";
		button -bgc  0 .016 .376		-label ""  -w 25 -ann "5"  -c "RRM_ControlOverrideColor_V1(05)";
		button -bgc  0 0 1				-label ""  -w 25 -ann "6"  -c "RRM_ControlOverrideColor_V1(06)";
		button -bgc  0 .275 .098		-label ""  -w 25 -ann "7"  -c "RRM_ControlOverrideColor_V1(07)";
		button -bgc  .149 0 .263		-label ""  -w 25 -ann "8"  -c "RRM_ControlOverrideColor_V1(08)";
		button -bgc  .784 0 .784		-label ""  -w 25 -ann "9"  -c "RRM_ControlOverrideColor_V1(09)";
		button -bgc  .541 .282 .2		-label ""  -w 25 -ann "10" -c "RRM_ControlOverrideColor_V1(10)";
		button -bgc  .247 .137 .122		-label ""  -w 25 -ann "11" -c "RRM_ControlOverrideColor_V1(11)";
		button -bgc  .6 .149 0			-label ""  -w 25 -ann "12" -c "RRM_ControlOverrideColor_V1(12)";
		button -bgc  1 0 0				-label ""  -w 25 -ann "13" -c "RRM_ControlOverrideColor_V1(13)";
		button -bgc  0 1 0				-label ""  -w 25 -ann "14" -c "RRM_ControlOverrideColor_V1(14)";
		button -bgc  0 .255 .6			-label ""  -w 25 -ann "15" -c "RRM_ControlOverrideColor_V1(15)";
		button -bgc  1 1 1				-label ""  -w 25 -ann "16" -c "RRM_ControlOverrideColor_V1(16)";
		button -bgc  1 1 0				-label ""  -w 25 -ann "17" -c "RRM_ControlOverrideColor_V1(17)";
		button -bgc  .392 .863 1		-label ""  -w 25 -ann "18" -c "RRM_ControlOverrideColor_V1(18)";
		button -bgc  .263 1 .639		-label ""  -w 25 -ann "19" -c "RRM_ControlOverrideColor_V1(19)";
		button -bgc  1 .69 .69			-label ""  -w 25 -ann "20" -c "RRM_ControlOverrideColor_V1(20)";
		button -bgc  .967 .675 .475		-label ""  -w 25 -ann "21" -c "RRM_ControlOverrideColor_V1(21)";
		button -bgc  1 1 .388			-label ""  -w 25 -ann "22" -c "RRM_ControlOverrideColor_V1(22)";
		button -bgc  0 .6 .329			-label ""  -w 25 -ann "23" -c "RRM_ControlOverrideColor_V1(23)";
		button -bgc  .631 .412 .188		-label ""  -w 25 -ann "24" -c "RRM_ControlOverrideColor_V1(24)";
		button -bgc  .624 .631 .188		-label ""  -w 25 -ann "25" -c "RRM_ControlOverrideColor_V1(25)";
		button -bgc  .408 .631 .188		-label ""  -w 25 -ann "26" -c "RRM_ControlOverrideColor_V1(26)";
		button -bgc  .188 .631 .365		-label ""  -w 25 -ann "27" -c "RRM_ControlOverrideColor_V1(27)";
		button -bgc  .188 .631 .631		-label ""  -w 25 -ann "28" -c "RRM_ControlOverrideColor_V1(28)";
		button -bgc  .188 .404 .631		-label ""  -w 25 -ann "29" -c "RRM_ControlOverrideColor_V1(29)";
		button -bgc  .435 .188 .631		-label ""  -w 25 -ann "30" -c "RRM_ControlOverrideColor_V1(30)";
		button -bgc  .631 .188 .412		-label ""  -w 25 -ann "31" -c "RRM_ControlOverrideColor_V1(31)";
		
			
			setParent RRM_RigSteps;
			setParent ..;
	//TAB 3////////////////////////////////////////////////////////////////////////	
	rowColumnLayout -nc 2 -cw 1 355 -cw 2 415 RRM_RigExtras;
	
		frameLayout -label "Step 5.1: Delete the Proxy Rig"
			-width 355
			RRM_DeleteProxyRig_V1FrameLayout;
			
		columnLayout RRM_DeleteProxyRig_V1ColumnLayout;

			
			//STEP 5.1
			button -label "Delete Proxies" -w 354
			-bgc .8 0.25 0.25
			-ann "This will delete your proxy rig once you have no further use for it."
			-command "RRM_DeleteProxyRig_V1"
			RRM_DeleteProxyRig_V1Button;
			
			
			setParent RRM_DeleteProxyRig_V1ColumnLayout;
			
			//STEP 5.2
		frameLayout -label "Step 5.2: Select Any Control to Delete the Entire Rig"
			-width 355
			RRM_DeleteModularRigFrameLayout;
			
		button -label "Delete Rig"
		-bgc .8 0.25 0.25
		-annotation "Select a control of your rig and click this button to delete that rig."
		-command "RRM_DeleteRig_V1UI_V1"
		RRM_DeleteRig_V1UI_V1Button;
		
		setParent RRM_DeleteProxyRig_V1ColumnLayout;

		//STEP 5.3
		frameLayout -label "Rapid Rig Info"
			-width 355
			RRM_RapidRigInfoFrameLayout;
			
		columnLayout -cw 355;

		columnLayout -cw 50 -cat "left" 5;
		button -w 355 -label "RRM Version Number"
		-annotation "Select the Main Control and click this button to see what version your rig is."
		-command "RRM_GetVersionNumber_V1"
		RRM_GetVersionNumber_V1Button;
		
		button -w 355 -label "Go To \"Rapid Rig: Modular\" Web Page"
		-annotation "Go to the CreativecCrash webpage for Rapid Rig: Modular."
		-command "RRM_GoToCreativeCrash_V1"
		RRM_GoToCreativeCrash_V1Button;
		
		
		text -label "\n\n\n\n                email me with questions and feedback:\n\n                             dustin@rapidrig.com\n\n\n" -align "left";
	
	
		//STEP 6.1
			//setParent RRM_DeleteProxyRig_V1ColumnLayout;
			setParent RRM_RigExtras;
			columnLayout RRM_ExtrasColumn2;
			
			frameLayout -label "Step 6.1 Connect Scale for Single Joint Hierarchy";
			checkBoxGrp
			-numberOfCheckBoxes 3
			-label "axis:" -labelArray3 "X" "Y" "Z" -valueArray3 1 1 1
			RRM_SH_ScaleConnect_V1CheckBox;
			button -label "Connect Scale of Selected Single Hierarchy Joints"
			-c "RRM_SH_ScaleConnect_V1(`checkBoxGrp -q -value1 RRM_SH_ScaleConnect_V1CheckBox`,\
			`checkBoxGrp -q -value2 RRM_SH_ScaleConnect_V1CheckBox`,\
			`checkBoxGrp -q -value3 RRM_SH_ScaleConnect_V1CheckBox`);"
			RRM_SH_ScaleConnect_V1Button;
			
			setParent RRM_ExtrasColumn2;
			
		//STEP 6.2
			frameLayout -label "Step 6.2: Rename Single Hierarchy to Match Motionbuilder Naming"
			-w 415 RRM_Rename_V1SHJointsFrameLayout;
			
			rowColumnLayout -nc 2 -cw 1 205 -cw 2 205;
			button -label "Rename Head" -ann "Select a joint to rename to Head" -c RRM_SH_RenameHead_V1;
			button -label "Rename Neck" -ann "Select the first joint of a chain to rename to Neck" -c RRM_SH_RenameNeck_V1;
			button -label "Rename Spine" -ann "Select the first joint of a chain to rename to Spine" -c RRM_SH_RenameSpline_V1;
			button -label "Rename Hips"  -ann "Select a joint to rename to Hips" -c RRM_SH_RenameHips_V1;
			button -label "Rename Left Arm"  -ann "Select clavicle joint of an Arm" -c RRM_SH_RenameLeftArm_V1;
			button -label "Rename Right Arm" -ann "Select clavicle joint of an Arm" -c RRM_SH_RenameRightArm_V1;
			button -label "Rename Left Leg"  -ann "Select hip joint of a Leg" -c RRM_SH_RenameLeftLeg_V1;
			button -label "Rename Right Leg" -ann "Select hip joint of a Leg" -c RRM_SH_RenameRightLeg_V1;
			
			setParent ..;
			
	
	tabLayout -edit -tabLabel RRM_ProxySteps "Setup Proxies" /*-tabLabel RRM_EditProxy "Modify Proxies"*/ -tabLabel RRM_RigSteps "Generate Rig" -tabLabel RRM_RigExtras "Extras" $tabs;

		int $top, $left, $value[2];
		$value = `scrollLayout -query -scrollAreaValue addModScrollLayout`;
		$top = $value[0];
		$left = $value[1];
}


//MAIN PROCEDURE FOR WINDOW
global proc RapidRig_Modular()                                        
{
	if (`window -exists RRM_Window`) 
	{
		deleteUI RRM_Window; 
	}
	window -title "Rapid Rig: Modular 1.8.3"
		-wh 375 212
		-rtf on
		-mnb false
		-mxb false
		-s 1
		RRM_Window;
	
	RRM_CreateProxyMainGUI_V1();
	
	showWindow RRM_Window;
	window -e -w 375 -h 212 RRM_Window;
}

RapidRig_Modular();
